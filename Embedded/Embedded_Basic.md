



# **Embedded_Basic**

# **0. 무엇을 배워야 임베디드 리눅스 개발을 잘할 수 있을까?**

---

좁게 보면 임베디드 리눅스 개발자가 알아야할 지식은 다음과 같다.

- 리눅스 디바이스 드라이버
- 리눅스 커널
- CPU 아키텍쳐
- SoC

조금 넓게 보면 다음 내용도 알면 좋다.

- 유저 공간 HAL(Hardware Abstraction Layer) 코드 구현
- 빌드 스크립트 구현
- 테스트용 디바이스 드라이버 구현
- git과 형상관리

## < 디바이스 드라이버 >

> 임베디드 리눅스 개발을 시작하면 바로 디바이스 드라이버를 맡는 경우가 많다. 물론 프로세스나 개발 회사 규모에 따라 드라이버 개발 범위가 다르다. 제품을 이루는 디바이스 드라이버의 특정 분야를 맡을 수도 있고 어떤 경우 한 명의 임베디드 개발자가 임베디드 리눅스를 책임지는 경우도 있다.

디바이스 드라이버의 사니로와 제어하는 하드웨어의 종류가 다양하다. 하지만 다음 내용 정도는 알아두는 것이 좋다.

- **인터럽트 핸들러 함수와 인터럽트를 처리하는 방식**
- **디바이스 파일로 open/read/write 연산 함수 등록하는 방법**
- **디바이스 트리를 읽어 디바이스 속성을 저장하는 방식**

개발에 투입이 되면 자신이 작성한 디바이스 드라이버 코드보다 다른사람이 작성한 코드를 읽을 가능성이 높다. 따라서 디바이스 드라이버 코드를 빨리 읽고 이해하는 능력을 키우는 것도 중요하다.

## < 리눅스 커널 >

디바이스 드라이버는 리눅스 커널에서 제공하는 함수로 이루어져 있다. 호출한 함수 원리를 알려면 자연히 리눅스 커널 코드를 분석할 수 밖에 없다. 어떤 분은 "리눅스 디바이스 드라이버는 리눅스 커널 그자체"라고 말하는데 그 의견에 동의한다.

또한 디바이스 드라이버 개발 과정은 코드를 입력해 드라이버를 구현하는 데 그치지 않는다. 인증 테스트 부서를 통해 드라이버 안정화 테스트 과정을 거치고 그 과정에서 다양한 버그나 문제 증상이 리포트 된다.

카메라 리눅스 디바이스의 경우 사진을 찍은 후 저장한 화면이 모두 검은색일 수 도 있고 그래픽 디바이스의 경우 화면이 깨질 수도 있다.

이 과정에서 만나는 다양한 버그를 수정해 문제를 해결하기 위해서는 리눅스 커널을 잘 알아야 한다.

## < CPU 아키텍쳐 >

리눅스 커널 코드를 조금 깊게 들여다 보면 만날 수 밖에 없는 것이 있다.

***바로 어셈블리 코드이다.***

리눅스 커널의 핵심 개념들은 대부분 어셈블리 코드로 구현돼 있다. 그 이유는 리눅스 커널 핵심동작은 CPU와 연관된 부분이 많기 때문이다.

- **컨텍스트 스위칭**
- **익셉션 벡터**
- **시스템 콜**
- **시그널 핸들러**
- **메모리 관리(MMU)**

처음 리눅스를 접하는 분은 무리해서 CPU 세부원리와 어셈블리 코드를 공부할 필요는 없다. 일단 리눅스 시스템과 커널 로그와 ftrace에 친숙해지는 것이 먼저이다.

위에 언급된 내용은 중간 정도만 하면 된다. 대신 시간을 모두 쏟아 부을 필요는 없다. 임베디드 및 BSP 리눅스 개발자의 핵심은 디바이스 드라이버와 커널이다. 하지만 위에서 언급한 기술에 신경을 안 쓰면 실전 개발에서 많은 걸림돌은 만나게 될 것이다.





# **0. 임베디드 기본적인 몇가지**

## 버스

통신을 하기 위한 물리적(회로) 신호의 묶음(Bus). 전기적 신호 논할 때 사용

## 버스 프로토콜

버스 신호를 이용하여 통신 시작/종료, 방법 등 구체적으로 동작하는 버스 신호의 변화를 칭함



간단히 말하면 **버스는 전기신호를 말하고 프로토콜은 신호를 제어해서 통신하는 방법**을 말하는 것이다 !

대부분의 프로토콜은 H/W에서, 즉 IC레벨에서 구현되어 있다. 제어하는 엔지니어가 무언가를 바꾸거나 할 수는 없다. 하지만 개발자는 이것을 알아야 하는데 그 이유는 **H/W가 잘못 된 경우 어떤 부분이 잘못 되었는지 디버깅을 하기 위함**이다. 이미 구현되었으니 출력신호는 정해져 있으며 만일 정해진 대로 출력이 안되면 해당 부분을 디버깅하는 식으로 개발이 진행된다.

시스템이 항상 잘 동작하기만 한다면 단순 구현만 하면 되지만 반대인 경우 원인을 찾기 위해서는 그 배경 지식인 개념을 이해하고 있어야 시스템을 볼 수 있는 눈이 생기게 된다.



진짜진짜 시작하기에 앞서.... LSB와 MSB에대해서 알아보자. 우선 이들은 어떠한 크기의 데이터 형이 있다면 그 데이터에서 가장 왼쪽에 있는 비트인지 혹은 가장 오른쪽에 있는 비트인지를 나타내는 비트이다.

## LSB란?

Least Significnat Bit의 약자로 하나의 데이터 형에서 가장 낮은 위치의 Bit를 의미한다. 예를 들어 `signed char` 데이터 형과 `unsigned char` 데이터 형에 대해서 예를 들면 아래와 같다.

![image-20200728152327402](https://user-images.githubusercontent.com/58545240/89979211-29ad5d80-dcaa-11ea-81a4-21cdebd22f09.png)

일단 LSB의 위치는 가장 값이 작은 비트인 2^0에 위치하고 잇는 것을 알 수 있다. 이 LSB의 값을 이용하여 해당 데이터 형에 들어 있는 실제 숫자가 짝수인지 홀수인지 손쉽게 알아낼 수 있다.

이런 LSB는 프로그래밍 시 주로 난수발생 함수, 해시 함수, 검사합(CheckSum) 함수 등에서 많이 쓰이고 있다. 왜냐하면 LSB는 값이 조금이라도 변경된다면, 데이터형의 최하위 비트이므로 그 값이 거의 100% 변화가 발생하기 때문이다.

![image-20200728152551110](https://user-images.githubusercontent.com/58545240/89979228-35008900-dcaa-11ea-96cb-bd281c802d6c.png)

다음은 `signed char` 데이터 형에서의 LSB에 대해 알아보자. signed char 데이터 형의 LSB역시 unsigned char 데이터 형에서의 큰 차이점은 없다. 즉 LSB에서 중요한 점은 바로 특정한 데이터 형의 가장 최하위 비트라는 점이다.

## MSB란?

Most Significant Bit의 약자로 어떠한 데이터 형의 최상위 비트를 의미한다. 이 MSB는 데이터 형에 따라서 특징이 조금 나뉘는데 우선 위에서 소개했던 unsigned char 데이터형의 MSB에 대해 살펴보면 2^7이라는 값을 지니고 있는 위치의 비트이다. 그 외에는 unsigned char 데이터 형의 가장 값이 큰 위치의 최상위 비트정도로 정의를 내릴수가 있다.

다음은 가장 중요하게 살펴볼 signed char 데이터 형에서의 MSB이다. 위에 소개했던 signed char 데이터 형의 MSB를 살펴보면 MSB위치가 부호자리를 나타내고 있는 것을 알 수 있다. 따라서 해당 데이터 형의 값이 MSB만 확인하면, 양수인지 혹은 음수인지를 손쉽게 알아낼 수 있다.

### 중요점

LSB와 MSB의 그 뜻 자체를 이해하는 것도 중요하지만 LSB나 MSB를 집적적으로 프로그래밍을 할 때 조사를 하는 경우는 매우 드물다. 따라서 LSB와 MSB의 보다 실무적인 본질을 알아야 한다 !

그것은 바로.. 임베디드 시스템 등에서 `시리얼 통신`을 할 때 시리얼 통신의 경우 송수신할 데이터의 각 비트를 단위시간에 따라서 순차적으로 보내게 된다. 즉 하나의 단위시간 동안 0혹은 1밖에 보낼 수 없는 구조라는 것이다.

이를 다시 전자에서 예를 들었던 unsigned char나 signed char 데이터 형에 비추어 바라봤을 때는 어떤 위치의 비트들이 단위시간 동안 가장 먼저 보내지고 가장 늦게 보내질지를 알야아 한다. 즉, MSB의 비트부터 순차적으로 데이터 비트를 보내 맨 마지막에 LSB의 비트를 보내는 것인지, 혹은 정반대로 LSB의 비트부터 차례로 보낸 다음 MSB를 맨 마지막에 보내는지를 명확히 알아야 할 때 매우 중요한 사항이 될것이다.

![image-20200728153414336](https://user-images.githubusercontent.com/58545240/89979236-3d58c400-dcaa-11ea-8a38-91b18fd35b43.png)

위의 그림과 같이 LSB부터 송신할 때와 MSB부터 송신할 때 수신지에서 받아들이는 값은 LSB부터 송신할 때와 MSB부터 송신할 때에 상이한 것을 알 수 있다. 즉 어떠한 데이터의 가장 최상위 비트부터 송신할 때는 수신지에서 해당 MSB를 LSB위치로 밀어넣게 되어있기 때문에 위와 같은 그림으로 데이터 송수신이 발생한다.

## FTP

> **File Transfer Protocol**

파일전송 프로토콜의 약자로 [TCP](https://namu.wiki/w/TCP)/[IP](https://namu.wiki/w/IP) 네트워크 상에서 컴퓨터들이 파일을 교환하기 위해 1971년에 최초로 공개된 통신 규약이다. 네트워크에 연결된 컴퓨터끼리 데이터를 원활하게 교환하기 위한 목적으로 개발되었다. 파생형으로 FTP에 [TLS](https://namu.wiki/w/TLS) 프로토콜이 적용된 [FTPS](http://en.wikipedia.org/wiki/FTPS)가 있으며, 비슷한 기능을 제공하는 [SSH](https://namu.wiki/w/SSH) 프로토콜 기반의 [SFTP](http://en.wikipedia.org/wiki/SSH_File_Transfer_Protocol)가 있다. SFTP는 FTP라는 키워드를 포함하고 있으며 용도 또한 같으나 FTP와 기술적인 연관성은 없는 완전히 다른 프로토콜임을 주의해야 한다.

FTP는 비밀번호가 평문으로 전송되어 보안성이 매우 떨어지므로 FTPS를 사용하는걸 적극 권장한다. FTPS의 경우 PROT P를 사용하면 데이터 전송까지 암호화되어 높은 보안성을 지니며, PROT C를 사용하면 데이터 전송을 암호화하지 않아 보안성이 떨어지지만 빠른 파일 전송이 가능하다. SFTP의 경우 포트를 하나만 사용하기 때문에 방화벽이 설치된 환경에서 셋팅하기가 쉬워 초보자한테 권장되나, 프로토콜 구조상 PROT P를 사용한 FTPS보다 속도가 느리다는 결함이 있다. FTP와 FTPS는 보통 제어용으로 21번 포트 및 데이터 전송용으로 20번 포트를, 패시브 모드의 경우 50000번대 이상의 포트를 추가적으로 많이 사용하며 FTPS의 경우 990포트를 사용하는 경우도 있다. SFTP는 보통 22번 포트를 사용한다.



**세부사항**

- 네트워크에서 사용하는 프로토콜 중에서는 드물게 제어 채널과 전송 채널이 분리되어 있다. 쉽게 설명하면 전화기 한 대와 팩스 한 대를 가지고 전화기로는 지금 가지고 있는 자료에 대해서 물어보고, 필요한 자료를 요청하면 팩스로 열심히 자료를 전송 받는 형태이다.

- FTP를 사용하여 데이터를 주고받기 위해서는 FTP 서버와 FTP 클라이언트가 필요하다. 원래 데이터 교환을 목적으로 개발된 것이기 때문에 안정성과 신뢰성이 보장된다. 그렇기에 회사나 동아리 같은 곳에서 FTP 서버 하나 구축해두면 자료를 공유할 때 상당히 유용한 물건이 된다. 하지만 국내의 경우에는 자료를 공유하기 위한 대안이 많다 보니 있으면 유용하지만 없어도 그만인 수준.

- 많은 FTP 클라이언트들이 휘황찬란한 GUI 환경을 제공하지만, 본래는 아래 그림과 같이 명령어 입력 방식이다. GUI 환경에서 작동하는 FTP 클라이언트들은 단지 명령어들을 자동으로 전송해 주는 것 뿐이다.

- [웹 브라우저](https://namu.wiki/w/웹 브라우저)도 FTP를 지원한다. 위의 명령어 입력 방식이 어려울 경우에는 이 방법을 써도 된다. 인터넷 주소창에서 http:// 대신 ftp:// 를 붙이고 FTP 서버 주소를 치면 ID와 비밀번호를 묻는 화면이 뜨고, 그걸 치고 들어가면 브라우저 화면에 FTP 서버의 파일 목록이 링크 형태로 주르륵 뜬다. 이것은 대용량 파일 전송은 웹에서 사용하는 HTTP 프로토콜보다는 파일 전송용으로 나온 FTP 프로토콜이 유리한 점이 많기 때문에 지원하는 것. [엣지](https://namu.wiki/w/엣지(웹 브라우저))에서는 지원하지 않는다.

- 1990년대에는 대부분의 소프트웨어 업체나 게임 업체 등이 별도의 FTP 서버를 구축하고 익명의 접속을 허용한 후에 자신들이 개발한 프로그램의 셰어웨어나 데모 버전, 패치 등을 공개하곤 하였다. 사실 그 시절에는 지금처럼 인터넷이 발달한 것이 아니었기에 FTP 말고는 불특정 다수에게 효과적으로 자료를 배포할 수 있는 방법이 거의 없었다. 외국의 다른 게임 회사들 대부분은 비슷한 방식으로 FTP 서버를 운용하는 곳이 있고 간혹 예전에 발매했던 추억의 게임들을 FTP에서 무료로 받을 수 있는 경우도 있는 경우도 있으니 찾아보는 것도 나쁘지는 않다. 다만 현재는 자사 웹사이트에 공개하는 게 여러 모로 이득이고, 패치 같은 것은 프로그램 내에 패치 업데이트용 프로그램을 내장시키는 추세라서 FTP에 대해 배우는 곳도 많지 않고, 사장되는 추세이다.사실상 웹기반 [파일전송 서비스](https://namu.wiki/w/파일전송 서비스)로 완전히 대체되었다.

- [리눅스](https://namu.wiki/w/리눅스) 배포판과 각종 리눅스의 중요 오픈소스 소프트웨어들은 FTP로 배포되는 경우가 많다. yum이나 apt와 같은 각종 리눅스 저장소도 FTP로 운영되고 있으며, 유명 배포판의 경우에는 전 세계에 저장소 미러링 FTP 서버를 운영하는 경우가 많다. 한국에서는 [카이스트](https://namu.wiki/w/카이스트), [Daum](https://namu.wiki/w/Daum), [네오위즈](https://namu.wiki/w/네오위즈)에서 운영하는 FTP 서버가 유명하다.

### linux에서 FTP로 디렉토리 전체 다운받는 방법

FTP를 이용해서 특정 디렉토리 및 그 하위 내용을 모두 받으려면 (recursively) 어떻게 해야 할까? 물론 FileZilla 같은 GUI FTP 클라이언트 프로그램을 사용하면 쉽게 받을 수 있다. 

하지만 GUI 프로그램을 사용할 수 없는 Shell 환경에서라면 wget 명령을 사용해서 받아오는 방법이 있다.

```bash
wget [OPTION]... [URL] ...
```

예를 들어, FTP 서버 IP가 1.1.1.1 이고 계정은 user1 암호는 password1 받고 싶은 디렉토리 경로가 /home/user1/download 라면 아래와 같이 입력하면 된다.

```bash
wget -r --ftp-user=user1 --ftp-password=password1 ftp://1.1.1.1//home/user1/download
```

-r 옵션이 recursive 하게 다운로드 받는 옵션이고 경로는 절대 경로를 입력하되 서버 주소와 경로명 사이에 / 가 2개임을 유의하자.

더 자세한 옵션에 대한 설명은 wget --help 라고 입력하면 볼 수 있다.

# **1. 임베디드 플랫폼이란?**

---

**1.1 임베디드 시스템의 특징**

임베디드 시스템의 정의

- 특정 목적을 수행하기 위해 최적화된 시스템
- 특정한 제품이나 솔루션에서 주어진 작업을 수행할 수 있도록 추가로 탑재되는 
  솔루션이나 시스템
- **핵심 키워드: 특정 목적, 최적화(Optimization), 시스템 확장(Upgrade) 불가능**
- **임베디드 시스템의 반대말이 범용 시스템(General Purpose System)**
- 최적화에 대한 기준은 비용(Cost)

**1.2 임베디드 플랫폼**

**임베디드 플랫폼: 비용 중심의 최적화된 하드웨어와 소프트웨어의 결합**

- 임베디드 개발의 첫 단추는 마이크로 프로세서, 즉 CPU 선택
- 요즘 CPU는 SoC(System on Chip) 형태 출시
- **임베디드 플랫폼 = 마이크로 프로세서(CPU) + 운영체제(OS) + 개발 환경(Tool)**
- 개발 환경(IDE Integrated Development Environment)
  SW 개발에 필요한 소스 코드 작성, 컴파일, 디버깅, 배포 등의 모든 작업을 하나의 프로그램 안에서
  처리하는 환경, ex) 공개형 IDE: 이클립스(Eclipse)

**임베디드 시스템의 구동하기 위한 소프트웨어**

- 운영체제 없이 동작 시키는 **펌웨어(Firmware)**
- 우선순위(Priority)를 중요시하는 **“RTOS(Real Time OS)”**
- 마이크로소프트의 윈도우 CE(Windows CE)와 같은 **“Non-RTOS”**



**임베디드 시스템용 소프트웨어 분류 기준**

- OS 사용
  - 같은 자원에 여러 개의 테스크가 동시에 접근해야 할 경우 (Non-RTOS)
  - 태스크 수는 그리 많지 않으나 태스크 간 우선순위 보장이 반드시 필요한 경우 (RTOS)

- OS 미사용
  - 태스크 수가 많지 않으며,동시에 접근하거나 우선순위 보장이 필요 없는 경우 (Firmware)

   *태스크(Task): 독립적으로 실행 가능한 SW 단위로서 프로세스(Process), 쓰레드(Thread) 이에 속함*

# **2. 마이크로 프로세서**

---

**2.1 MPU vs MCU**

마이크로프로세서(CPU)

> **CPU = CPU Core(CPU Architecture) + CPU Peripherals(Controllers)**

ARM9 프로세서 = ARM9 Core + USB,Ethernet MAC, UART, ADC, …

- CPU Core
  - CPU Core는 8, 16, 32비트 프로세서로 구분, ARM9 Core는 32비트 리눅스(Linux)구동 가능
  - CPU Core가 하는 일은 소프트웨어를 실행시킨다. 연산 처리 담당

- CPU Peripheral
  - 처리된 연산 결과를 CPU 주변 하드웨어를 제어하는 일



**CPU Core와 Controller 들은 서로 버스(System Bus) 구조로 연결**

![image-20201029112616133](https://user-images.githubusercontent.com/58545240/97543699-eee6d600-1a0b-11eb-8c8c-dc511c26dae8.png)

Bus 구조는 확장하기 쉽다.

하드웨어 관점에서 CPU를 선정할 때에는 개발하려는 제품의 하드웨어 사양(Spec.)에서 어떤 회로가 구성하기 어려운 지를 먼저 살펴보고 회로 구성이 어려운 부분들이 최대한 많이 Controller로 내장되어 있는 CPU를 선정하는 것이 좋다. 



**마이크로 프로세서와 마이크로 컨트롤러의 차이**

![image-20201029112657784](https://user-images.githubusercontent.com/58545240/97543719-f5754d80-1a0b-11eb-9e0c-3e3e62da51da.png)

- `MPU`: CPU Core가 CPU의 대부분을 차지할 정도로 소프트웨어 연산 처리 능력에 중점을 둔 CPU
- `MCU`: CPU 주변 장치(디바이스)들을 제어할 회로 구성을 간단하게 하기 위해 내부에 포함한 CPU

**2.2 소프트웨어로 하드웨어를 제어하는 방법**

소프트웨어 관점에서의 하드웨어 분류

 \> 하드웨어 내부에 메모리가 있다 / CPU, Ethernet MAC, … / 실행 주체: 능동 소자

 \> 하드웨어 내부에 메모리가 없다 / LED, Button, Switch, … / 실행 주체: 수동 소자

  *능동 소자: 자기 스스로 제어에 대한 판단 능력이 있는 부품



CPU, Ethernet MAC 같은 부품은 소프트웨어 개발자가 작성한 소프트웨어 실행 코드에 판단을 한다.

즉, **소프트웨어 실행 코드가 CPU Core에 의해 연산 되어 최종적으로는 제어하려는 해당 CPU Peripheral 내부에 있는 레지스터(Register)를 설정하게 됨으로써, 제어**하게 된다. 

![image-20201029112753944](https://user-images.githubusercontent.com/58545240/97543736-fc9c5b80-1a0b-11eb-9e8b-8ed5defa62ba.png)

수동 소자 들은 내부에 메모리가 없기 때문에, 능동 소자에 연결하여 간접적으로 제어할 수 있다.

메모리 구조는 TEXT,DATA,BSS,STACK 영역으로 나뉘어진다.

- TEXT: C 언어 로 작성한 함수 저장
- DATA: 전역 변수(global variable) 중 초기화되어 있는 전역 변수 저장
- BSS: 전역 변수 중 초기화되지 않은 전역 변수 저장
- STACK: 지역 변수(local variable)

메모리에 올라간 실행 코드들은 CPU로 읽혀지는데, 이 때 사용되는 레지스터가 PC(Program Counter)

이 PC가 현재 가리키고 있는 메모리 주소에 있는 실행 코드를 CPU는 CPU Core로 읽어오는데 이 과정이 **`Fetch`** 다. 

읽어온 실행 코드는 Latch라고 불리는 곳에 잠시 저장되어 있으면서 해석되는데 이렇게 해석하는 과정이 **`Decode`**

해석된 코드는 Latch 다음 단계에 있는 레지스터 뱅크(Register Bank)로 전달되었다가 최종적으로는 ALU에 의해 실행된다. 이 과정을 **`Execute`**



즉 CPU는 전원이 들어와서 나갈 때까지 **Fetch -> Decode -> Execute**를 무한 반복

CPU Core 내부에 있는 레지스터는 “범용 레지스터”(General Purpose Register) 라고 부른다.

***소프트웨어로 하드웨어를 제어하는 임베디드 소프트웨어란 CPU Peripheral 내부에 있는 특정 레지스터들의 값을 설정하는 실행 코드!***

# **3. 운영체제**

---

1. **`Non-RTOS`**

   > 같은 자원에 여러 개의 태스크가 동시에 접근해야 할 경우   사용자 응용 프로그램은 자원에 직접 접근할 수 없다.

   

   ![image-20201029113153713](https://user-images.githubusercontent.com/58545240/97543759-032ad300-1a0c-11eb-80db-8268c4c6a200.png)

   사용자 응용 프로그램이 OS를 통해 자원에 접근하는 과정

   ![image-20201029113209061](https://user-images.githubusercontent.com/58545240/97543778-08881d80-1a0c-11eb-954c-caa9f4ede819.png)

   - 1. 디바이스 드라이버(Device Driver) 등록: 실제 (하드웨어) 자원을 제어할 디바이스 드라이버가 미리 OS에 등록되어 있어야 한다.
     2. 사용자 응용 프로그램 자원 요청: 사용자 응용 프로그램은 OS에게 자원에 대한 접근 권한 요청
     3. 해당 디바이스 드라이버 검색: 요청을 받은 OS는 해당 자원을 실제로 제어할 디바이스 드라이버가 자신(OS)에게 등록되어 있는지 검색. 없으면 오류 메세지, 있으면 실행
     4. 디바이스 드라이버 자원 제어: 실제 하드웨어 지원을 제어하고 결과를 전달.

   

   **RTOS 이든 Non-RTOS이든 모든 운영체제에서 가장 중요한 개념은 여러 개의 테스크 를 어떻게 관리할 것인가 효율적으로 관리하는 방법을 “`스케줄링(Scheduling)`”**이라고 한다.

   

   

2. **`RTOS`**

   ![image-20201029130546546](https://user-images.githubusercontent.com/58545240/97543795-0f169500-1a0c-11eb-8f10-93f88e743566.png)

   USN은 주변 환경 정보를 수치적 으로 변환해주는 센서(Sensor)를 제어하는 부분과 센서로부터 받아들인 정보를 디지털로 변환하여 자신의 주변에 있는 이웃 센서 노드들에게 데이터를 전송하는 네트워크를 제어하는 부분으로 구성

   - 네트워크 제어 부분: 우선 순위 낮음, 주변에 이웃 센서 노드들이 몇 개나 살아 있는지 주기적으로 감지, 마이크로 프로세서에서 넘어 온 데이터를 전송
   - 센서 제어 부분: 우선 순위 높음, 센서로부터 전달된 데이터를 디지털로 변환하여 마이크로 프로세서에게 전달

   RTOS는 미 버클리 대학 개발 Tiny OS와 한국전자정보통신연구원(ETRI)에서 개발한 Nano Qplus

   우선 순위 제어가 반드시 필요한 경우 RTOS 사용

   ![image-20201029131250851](https://user-images.githubusercontent.com/58545240/97543816-15a50c80-1a0c-11eb-99b8-a9ec91a7be7f.png)

    32Bit 고 사양 CPU에서는 “**MMU(Memory Management Unit)**” 가 추가된다.

    “가상 메모리(Virtual Memory)” 라는 개념은 MMU에 의해 가능해진 것이다.

    **MMU는 가상 메모리 주소를 통해 실제 메모리 주소로 변환(mapping)** 한다.

3. **`RTOS`**와 **`Non-RTOS`**

   > RTOS는 우선순위가 필요한 제품에 사용 되고, Non-RTOS는 같은 자원에 접근하려는 태스크 수가 많은 제품 개발에 사용된다. 그러나, Non-RTOS에서도 우선 순위 제어가 필요하며, 기능이 있다.

   *Real-Time(실시간) = 원하는 시간 내에 원하는 결과를 얻을 수 있는*

   

   차이점은 즉 **RTOS란 태스크들이 원하는 시간 안에 원하는 결과를 얻도록** **보장(Guarantee)****해주는 운영체제(OS)이다.**

   **반대로 Non-RTOS는 최대한 결과를 얻도록 노력은 하나, 보장은 안 한다.**

   RTOS에게 보장을 주는 것은 “**우선순위(Priority)**”에 있다.  우선순위가 높은 태스크를 먼저 실행하는 것이 “**선점(Preemption)**”이라 한다.

   

   **RTOS = 우선순위 보장 = 원하는 시간에 원하는 결과 보장 = 원하는 시간에 CPU 제어권 획득 보장**

   ![image-20201029131400901](https://user-images.githubusercontent.com/58545240/97543833-1ccc1a80-1a0c-11eb-9b8b-97dbcbc4c30f.png)

    여기서 중요한 것은, **Non-RTOS는 각 태스크가 프로세스(Process)****로 되어 있고,** **RTOS는 쓰레드(Thread)****로 되어 있다는 점**이다. 

   

    **프로세스(Process)는 독립된 메모리 영역을 할당 받게 되지만**, **쓰레드(Thread)는** 독립된 메모리 영역을 할당 받지 않고 **메모리 일부를 서로 공유하기 때문에 모든 태스크가 동일한 CPU 동작 모드로 실행되어야 하기 때문이다.**

   

   - **CPU 동작 모드는 소프트웨어 종류에 따라 CPU가 동작하는 하드웨어 동작 방식도 달라진다**는 개념.
   - 즉, 사용자 응용 프로그램(User Application)을 실행시킬 때의 CPU 동작 방식과 OS 커널 내의 디바이스 드라이버 등을 실행시킬 때의 CPU 동작 방식이 하드웨어적으로 서로 다르다.

   - “`User`” 모드: 사용자 응용 프로그램(User Application)이 실행될 때
   - “`Supervisor`” 모드 : Linux 커널(Kernel)이 실행될 때

    RTOS는 모든 태스크가 동일하게 Supervisor 동작 모드로 실행, 

    RTOS의 모든 태스크를 합치면 하나의 프로세스

    main 함수 1개 = 실행 파일 1개 = 프로세스 1개

   Non-TROS(Linux, Windows)에서는 하나의 프로그램을 개발할 때 별도의 실행 파일이 1개씩 만들어진다. 왜냐하면 프로세스 기반으로 운영되는 OS 되기 때문이다.

   

   그러나 RTOS에서는 그렇지 않다. RTOS 역시 많은 수의 소스 코드 파일로 구성 되어 있으나, 전체 중에 main 함수는 1개 뿐이다. 당연히 실행 파일도 1개만 나온다.

# **4. 임베디드 시스템의 이해**

---

## - 임베디드 시스템 개요

**1. 임베디드 시스템의 의미**

임베디드 시스템은 특정 목적을 지닌 시스템이다. PC는 특정 목적이 아닌 범용 목적을 갖는 시스템이다. 

예를 들어 PC는 프로그램 개발뿐 아니라 그래픽 작업도 할 수 있고, 게임, 멀티미디어 기능 등 범용의 기능을 제공한다. 

하지만 임베디드 시스템인 핸드폰은 통신기능에 특화하여 개발되었고, 게임기도 게임기능에 특화하여 개발된 시스템이다. 임베디드 시스템의 구성은 정해진 기능에 필요한 하드웨어와 소프트웨어로 이루어진다.

**2. 임베디드 시스템의 예**

가전제품, 유비쿼터스 시스템, 휴대용 정보기기, 의료기기, 공장 자동화 시스템, 비행기, 우주선, 자동차내 정보기기

**3. 임베디드 시스템의 특징**

1. 기능이 제한적이다
   - 특정 기능에 특화된 시스템으로서 지정된 기능 외의 기능은 제공하지 않는다.
2. 크기에 제약이 있다.
   -  모바일 제품이 많기 때문에 크기가 작고 가벼워야 한다.
3. 저전력이어야 한다.
   - 배터리 용량의 한계로 전력 사용이 제한적임
4. 사용되는 프로세스나 운영체제가 다양하다.
   - 임베디드용으로 사용함, PC용 프로세서와 운영체제는 사용 불가
5. 실시간성을 제공해야 한다.
   - 의료기기, 공장 자동화 시스템, 군용에서는 한정된 시간 필수
6. 하드디스크(HDD)가 없다.
   - HDD 대신 ROM, RAM, Flash 메모리로 구성됨.

## - 임베디드 시스템 구성요소

**임베디드 시스템의 구성**

![image-20201029133348595](https://user-images.githubusercontent.com/58545240/97543850-248bbf00-1a0c-11eb-9b57-ff8a877ceb35.png)

**프로세서**

- `CPU` : 중앙 처리 장치(ALU + 레지스터)

  ![image-20201029133527787](https://user-images.githubusercontent.com/58545240/97543864-2b1a3680-1a0c-11eb-8e9e-5effa3ae71f7.png)

- `Micro Processor` : CPU에 최소한의 주변 장치(메모리, FPU 등)를 포함, 산술연산 위주

  ![image-20201029133536057](https://user-images.githubusercontent.com/58545240/97543875-30778100-1a0c-11eb-8708-bbe7ab2d4ddc.png)

- `DSP` : Micro Controller for Digital Signal Processing, 입출력 제어 사용

  ![image-20201029133552364](https://user-images.githubusercontent.com/58545240/97543935-438a5100-1a0c-11eb-8a14-73bfc79e34ba.png)

**특징**

1. 저전력
2. 가격에 민감
3. 작은 사이즈
4. 고성능
5. 개발의 용이성

**임베디드 프로세서의 종류**

1. 임베디드 프로세서 아키텍처

   *프로세서 아키텍처는 프로세서의 기본 구조를 말한다. 이에 따라서 명령어의 구성이나 레지스터의 구성 등 프로세서의 핵심적인 특징이 결정된다.*

   - ARM
   - MIPS
   - PowerPC 

2. 임베디드 프로세서 Soc(System on a Chip)

   *SoC는 프로세서 코어에 UART나 타이머, 메모리, LCD 제어기 등 필요한 주변기기를 칩에 내장시켜 하나의 칩으로 만드는 기술을 뜻한다.*

   - PXA255(인텔)
   - S3C2440(삼성)
   - Au1200(AMD)
   - MPC860(모토로라)

**임베디드 시스템 메모리**

1. `ROM` : 비휘발성 메모리로 읽기 가능, 쓰기 불가 / 실행 파일 및 운영체제 로드(Load)

   ![image-20201029133858751](https://user-images.githubusercontent.com/58545240/97543958-4ab15f00-1a0c-11eb-82bc-dee7b87f5f48.png)

2. `RAM` : 휘발성 메모리로 읽기, 쓰기 가능 / DRAM, SRAM

   ![image-20201029133906089](https://user-images.githubusercontent.com/58545240/97543977-51d86d00-1a0c-11eb-97e6-8cb03187341b.png)

3. `Flash Memory` : 블록 단위로 읽기, 쓰기 가능 / 임베디드 시스템에서는 하드디스크 대용으로 활용

   ![image-20201029133914080](https://user-images.githubusercontent.com/58545240/97544008-58ff7b00-1a0c-11eb-8f78-90ec1c7419f4.png)

**임베디드 시스템 메모리**

1. 멀티태스킹 지원요구
   - 임베디드 시스템도 다양한 멀티미디어 기능과 네트워크 기능을 제공하기 위해서 OS 필요
   - 대부분이 RTOS이지만 Windows CE, Embedded Linux 등 PC 환경 운영체제의 변형도 존재
2. **RTOS(Real Time Operating System)**
   - 실시간성을 제공하는 운영체제로 지정된 시간 내에 서비스 보장
   - GPOS에 비해 높은 신뢰성이 요구됨
   - 사이즈가 작고, 기능별 추가/제거가 용이함
   - 고성능
   - 종류 : `VxWorks`, `uC/OS`, `pSOS`, `NUcleus`, `REX`
   - **`RTOS`**의 구성 요소
     - 스케쥴러(Scheduler) : RTOS의 핵심으로 실시간성을 위해 태스크 관리에 따라 성능이 좌우됨
     - 인터럽트 처리(Interrupt Processing) : 프로세서 외부의 장치가 프로세서 사용을 요청하는 신호
     - 자원관리(Resource Management) : 리소스가 제한된 임베디드 시스템에서 자원 활용 방법
     - 태스크(Task) : 스케쥴러가 프로그램들을 실행시키기 위한 일의 작은 단위, 태스크들의 관리, 우선순위 책정, 스케쥴링 알고리즘 선정
3. **GPOS(General Purpose Operating System)**
   - 범용 목적의 운영체제
   - Windows, Linux와 같은 일반 PC 환경에서 사용
   - 응용프로그램으로부터 하드웨어 추상화
   - 종류 : `Windows CE`, `Embedded Linux`
   - **`GPOS`**의 특징
     - `Embedded Linux`
       - PC용 리눅스 커널을 변형하여 임베디드 시스템에 활용
       - Open source 형태이기 때문에 코드 수정이 자유로움
       - 다양한 디바이스 드라이버
       - 사용료에서 자유로움
       - 많은 분야에서 적용되고, 다양한 종류에 프로세서에 포팅(porting) 가능
     - `Windows CE`
       - 다양한 API 제공으로 개발 용이
       - 다양한 프로세서에 포팅 가능
       - 많은 종류의 멀티미디어 기능 제공
       - 통합 개발 환경(Visual Studio)을 제공

# **5. 임베디드 개발환경**

---

## Tool - Chain ?

![image-20201029140404027](https://user-images.githubusercontent.com/58545240/97544037-63ba1000-1a0c-11eb-9882-4000a3a9c036.png)

리눅스에는 “gcc” 라는 C 컴파일러가 있다. 리눅스에서 gcc 컴파일러로 컴파일할 때 별도의 출력 파일 이름을 지정하지 않으면 a.out이라는 이름으로 생성된다. 생성된 파일은 “실행 가능한 ELF 파일” 타입으로 되어 있다. **즉, UNIX나 Linux에서 gcc로 컴파일하면 무조건 ELF 파일이 생성된다.**

**`컴파일 과정(Compile)`**

- 텍스트로 되어 있는 소스 코드 파일을 이진 바이너리(Binary) 코드로 변환하는 과정.
- 가장 먼저 실제 컴파일을 진행하기 전에 소스 코드 상에 `"#"`(전처리기, Preprocessor)으로 처리되어 있는 부분들을 먼저 처리한다.
- 이후에 처리가 끝나면 C 문법 검사를 하게 된다. 오류가 없다면 이진 바이너리 코드로 변환을 하게 되고 이 때 생성되는 파일이 **`ELF`** 타입이다.
  - **`Relocatable ELF`** : 스스로 실행이 불가능한 바이너리 파일로 누군가 실행을 시켜줘야 되는( = 그래서 메모리에 올라가는(loading) 주소가 재배치(relocatable)되는) 파일.
  - **`Executable ELF`** : 자기 스스로 실행 가능한 파일.(ex. PC Windows 상에서의 "Hello.exe")

**`링킹 과정(Linking)`**

- 컴파일 과정을 통해 생성된 `Relocatable ELF` 파일로는 실행될 수 없으니, 실행되기 위해 필요한 정보들이 여기에 추가되어야 한다는 점. 이 추가 과정을 **링킹**이라 한다.

- **`링커(Linker)`**

  - 링킹 과정에서 자동적으로 정보를 제공
  - 프로그램이 실행되기 위해서 최소한으로 필요한 메모리 용량까지 알아서 계산해 해당 정보를 CPU 정보와 함게 "어딘가"에 저장 시켜준다.

- **`로더(Loader)`**

  - 프로그램이 실행될 때 OS에서 사용자 응용 프로그램을 실행시켜 주며, "어딘가"에서 CPU, 메모리 등의 정보를 읽어서 프로그램이 요구한 메모리 용량을 할당 받아 메모리 적재(Loading) 시켜준다.

  *`"어딘가"`는 `ELF Header`이다. **ELF = ELF Header + ELF Body***

## Firmware, RTOS, Non-RTOS?

Tool-chain 종류는 매우 다양하다.

Linux에서는 gcc, glibc, binutils (오픈 소스) / Windows에서는 Visual Studio (상용화된 제품)

임베디드 리눅스가 올라가는 CPU인 32비트 ARM 프로세서의 경우 ARM Core 로직(logic)을 개발한 ARM사에서 개발 및 판매하고 있는 RVDS(RealView Development Suite) 제품 사용(상용)

- Tool-Chain 중 어떤 기준으로 선택해야 하는가?
  1. 대기업이나 국가 연구소처럼 한 업체(혹은 기관)에서 다루어야 할 CPU 종류가 많을 때에는
     - 상용 Tool-Chain 제품을 선택하는 게 좋다. 다양한 Tool-Chain 만큼 알아야 할 것(헤더 파일,  함수 매크로)이 많아 생산성이 떨어진다.
  2. CPU 제조사에서 개발한 Tool-Chain 이 있다면 해당하는 Tool-Chain을 선택하는 게 좋다.
  3. 기술 지원이 반드시 필요한 경우에는 가급적 상용 Tool-Chain 을 사용하는 것이 좋다.
     - 공개용 Tool-Chain의 장점은 별도의 구매 비용이 발생하지 않는다. 그로 인해 별도의 기술 지원 역시 받을 수 없다.
  4. 특별한 기준이 없을 때는 가급적 사용자가 많이 선택한 Tool-Chain을 사용하라.

# **6. 임베디드 리눅스 구성요소(BSP)**

---

## - BSP란?

BSP(Board Support Package)란 말은 본래 RTOS에서 나온 용어로, "보드를 떠받치는(지원하는)" 소프트웨어 패키지란 뜻으로, "보드(하드웨어)를 동작 시키기 위해 필요한 (임베디드) 소프트웨어 묶음" 이다.

![image-20201030130709524](https://user-images.githubusercontent.com/58545240/97673384-0d61d580-1acf-11eb-9e47-50b60e743d5e.png)

위 그림은 Firmware와 RTOS로 구동되는 시스템과 Non-RTOS로 구동되는 시스템의 차이를 보여주고 있다.

WindRiver 사의 `VxWorks`와 같은 일부 상용 RTOS를 제외하고 대부분의 RTOS와 자체 Firmware에는 Non-RTOS와 같은 파일 시스템(File System)이 없다. 즉 소스들이 아무리 많다 하더라도 결국 컴파일이 끝나면 최종적으로 (CPU에 종속적인) 바이널 실행 코드 하나만 생성된다.

따라서 Firmware와 RTOS의 BSP는 **제품의 기능**이라 할 수 있는 코드(이를 "User Application"라고 표현했다)와 그러한 제품의 기능을 실제 구현하기 위해 **하드웨어를 직접적으로 제어**하는 코드("Firmware"라고 표현)가 하나의 파일로 묶여 **`BSP`**를 구성하고 있다.

그러나 Linux나 Windows CE와 같은 Non-RTOS들은 3가지 실행 코드들로 구성된다.

![image-20201030130946738](https://user-images.githubusercontent.com/58545240/97673390-12bf2000-1acf-11eb-8853-02ace7cbb94d.png)

![image-20201030130953897](https://user-images.githubusercontent.com/58545240/97673402-1783d400-1acf-11eb-93bd-22831baea739.png)

## - 임베디드 리눅스 BSP

Embedded Linx BSP에서 가장 중요한 부분이라면 당연히 OS 부분인 **Linux Kernel**이다.

Linux는 오픈 소스로 진행되는 공개 OS이므로, Linux란 OS의 부트 로더 인터페이스와 파일 시스템 인터페이스 규격만 알고 있다면, 부트 로더와 파일 시스템을 개발할 수도 있다는 뜻이다.

ARM 프로세서 기반의 Embedded LInux에서 사용 가능한 Boot Loader는 크게 세 가지 종류이다.

![image-20201030131111734](https://user-images.githubusercontent.com/58545240/97673424-1c488800-1acf-11eb-8d0e-a1e08e803b44.png)

**Embedded Linux File System 종류별 비교**

![image-20201030131133493](https://user-images.githubusercontent.com/58545240/97673444-210d3c00-1acf-11eb-8d67-ee4c73048685.png)



# **메모리**

---

1. RAM
   - 컴퓨터를 종료하면 데이터가 날아가는 휘발성 메모리
   - 하드 디스크나 CD와는 달리 속도가 매우 빠르다.(데이터에 랜덤하게 접근할 수 있음)
   - 컴퓨터는 대부분의 데이터들은 메모리에 보관해 놓고 작업을 한다. 틈틈이 하드디스크에 저장!
2. ROM
   - 컴퓨터를 종료해도 데이터가 날아가지 않는 비휘발성 메모리
   - ex) CD-ROM, DVD-ROM, 하드디스크 => (데이터에 순차적으로 접근한다)

컴퓨터의 한 개의 메모리 소자는 0 혹은 1의 값을 보관할 수 있다. 이 이진수 한 자리를 가리켜 비트(Bit)라고 한다. 따라서, 1개의 비트는 0 또는 1의 값을 보관할 수 있다. 8bit = 1byte

8bit(1byte)로 나타낼 수 있는 최대의 수는 0 ~ 0xFF. 0부터 255로 총 256개의 수를 나타내게 된다.

컴퓨터에서 연산을 담당하는 CPU에는 **레지스터(register)**라는 작은 메모리 공간이 있는데 이곳에다가 값을 불러다 놓고 연산을 수행하게 된다. 예를 들어 a+b를 하기 위해서는 a와 b의 값을 어디다 적어놓아야지, a+b를 할 수 있는 것처럼 CPU에서 연산을 수행하기 위해 잠시 써놓는 부분을 레지스터라고 한다.

이러한 레지스터의 크기는 컴퓨터 상에서 연산이 실행되는 최소 단위라고 볼 수 있고, 이 크기를 **워드**라고 부른다.

1워드는 64비트, 즉 8바이트가 된다.

# **프로세스(Process)**

---

## 1. 프로세스란?

- 프로세스(Process)란 실행중에 있는 프로그램(Program)을 말한다.
- 스케쥴링의 대상이 되는 작업(task)와 같은 의미로 쓰인다.
- 프로세스 내부에는 최소 하나의 스레드(thread)를 가지고 있는데, 실제로는 스레드단위로 스케쥴링을 한다.
- 하드디스크에 있는 프로그램을 실행하면, 실행을 위해서 **메모리할당**이 이루어지고, 할당된 메모리 공간으로 바이너리 코드가 올라가게 되는데 이 순간부터 프로세스라 불린다.
- 모든 프로세스는 각각 4G의 가상 주소공간(메모리공간X)을 부여받는다.
  - 운영체제 약 2G, 나머지 약 2G 응용프로그램의 고유 영역
  - 개발자는 이 가상주소공간 4G가 진짜 메모리인것 처럼 사용한다.
- 가상주소공간(virtual addres space) != 가상 메모리(virtual memory)

## 2. 가상주소공간

### 가상주소공간의 구조

![image-20200729135756106-1596589351106](https://user-images.githubusercontent.com/58545240/89979399-9d4f6a80-dcaa-11ea-91f0-7588ef3ea810.png)

- Code 영역 : 프로그램을 실행시키는 실행 파일 내의 명령어들이 올라간다.
- Data 영역 : 전역변수, static 변수의 할당
- Heap 영역 : 프로그래머의 **동적할당**을 위한 메모리 영역
  - C언어 => malloc & free
  - C++ => new & delete
  - JAVA => new & Garbage Collector
- Stack 영역 : 지역변수, 함수 호출시 전달되는 인자(파라미터)를 위한 메모리 영역
- page : 가상주소공간 4G를 4096byte(4K) 단위로 나눈 하나의 메모리 블록을 page라고 한다.
- 연산을 할 때는 값을 stack으로부터 레지스터로 가져오고 ALU로 넘겨서 연산을 수행한다. 연산 결과 값은 레지스터에 먼저 저장하고, stack영역에 재전달 한다.
- 레지스터의 스택포인터(SP)는 stack 프레임을 위해서 미리 공간을 확보한다.

### virtual machine

- register based machine(연산결과를 레지스터에 저장)
- virtual stack machine(연산결과를 stack에 저장하고 이를 다시 heap으로 반환)
- 연산결과를 임시로 젖아하는 공간을 operand stack이라고 부른다.
- 인터프린터 언어는 heap에 데이터를 저장하고 연산은 레지스터 ALU에서 실행 후 실행 결과를 stack에 저장. 해당값을 heap에 전달하려면 다시 레지스터를 거쳐야 한다.

### stack vs heap

- 가상주소공간 중 stack은 빠르고 heap은 상대적으로 느리다.
- stack은 그냥 데이터를 쌓지만 heap은 도중에 del등을 통해서 지울 수 있다. 빈공간이 생기면 그 곳에 새로운 데이터가 추가 된다.(spacial locality 보장이 어렵다)
- 또한, heap은 메타데이터 정보를 함께 저장한다. 따라서 더 많은 용량을 사용하며 할당시 매번 metadata에게 여분 공간이 있는지 묻기 때문에 상대적으로 느리다.
- **heap의 최대장점**
  - 할당시점과 지우는 시점을 마음대로 저장할 수 있다.
  - 프로세스 도중에 용량을 변경할 수 있다.(stack의 경우 프로세스 실행 전에만 변경 가능하다. 용랑이 넘치는 경우 stack overflow가 발생한다.)

## 3. 가상메모리

- 가상메모리 : 물리적인 RAM + 하드디스크
- page frame : 가상메모리(물리메모리 = RAM+페이징파일)를 4096byte(4K) 단위로 나눈 후, 그 한단위를 페이지 프레임이라 한다.
- 페이지 테이블 : 가상주소공간과 가상메모리를 매핑한다. 프로세스 별로 각각 하나씩 존재한다.
- RAM의 프레임이 모두 차있을 때, 추가 요청이 들어오면 RAM에서는 교체 알고리즘에 따라서 프레임 하나를 `페이징파일`로 내리고, 새롭게 요청된 페이지에 비워진 프레임을 할당한다.
- 가상메모리 운영방식 : LRU(least, recently, uses - 최근 최소 사용). 필요한것만 RAM으로 가져오고 안쓰는건 하드디스크에 내려놓는다.

## 4. 프로세스 스케쥴링

- CPU는 하나인데 동시에 실행되어야 할 프로세스가 여러개??

  => CPU가 고속으로 여러 프로세스를 일정한 기준으로 순서를 정해서 실행한다.

- **스케쥴링(Scheduling)**

  - CPU 할당 순서 및 방법을 결정하는 일.(어떤 프로세스를 running으로 보낼까?)
  - 일정한 기준 : 스케쥴링 알고리즘을 통해서.

*대부분의 OS에서는 **우선순위(Priority algorithm) 알고리즘**과 **라운드 로빈(Round Robin) 알고리즘**을 혼합해서 스케쥴링*

## 5. 프로세스 상태변화

![image-20200729141825350-1596589351107](https://user-images.githubusercontent.com/58545240/89979418-a6d8d280-dcaa-11ea-8fdd-d0485a702caa.png)

프로세스의 상태는 ready(준비), blocked(대기), running(실행) 상태가 있다.

- 생성(new) -> 준비(ready)

  => new 상태에서 프로세스가 생성되게 되면 OS 커널에 존재하는 Ready Queue에 올라가게 된다.

- 준비(ready) -> 실행(running)

  => Ready Queue에 있는 프로세스들을 OS가 위에서 말한 프로세스 스케쥴링 알고리즘에 의해서 Running 상태로 가야할 프로세스를 CPU로 할당하게 된다. 그러면 프로세스는 실행(Running)상태가 된다.

- 실행(running) -> 준비(ready)

  => 현재 running 상태에 있는 프로세스A보다 Ready Queue에서 대기하고 있는 프로세스 B 우선순위가 높으면, preemptive schedule(선점형)인 경우 프로세스A는 ready상태로 오게되고 프로세스B가 running상태로 가서 CPU를 할당받는다.

- 실행(running) -> 대기(blocked)

  => 현재 running 상태에 있는 프로세스A에서 입출력(I/O) 이벤트가 발생했을 때 프로세스A가 blocked상태로 가게된다.

- 대기(blocked) -> 준비(ready)

  => 입출력(I/O) 이벤트가 종료된 프로세스는 다시 Ready상태로 오게된다.

- 실행(running) -> terminate(종료)

  => 프로세스 종료

*ready, blocked 상태에는 여러 프로세스가 존재할 수 있다.*

*하지만, **싱글코어CPU**에서, running상태의 프로세스는 단 하나만 존재한다.*

# **워치독 타이머(WDT)**

> Watchdog Timer

## 1. 고신뢰성 시스템을 위한, 워치독 타이머

### 가. WDT의 개념

- 비정상, 무한루프 등에 빠진 경우 시스템 통제가 불가능한 상황에서 자동으로 시스템을 리셋하는 하드웨어 기능
- 타임아웃이 되기 전 S/W명령으로 그 값을 clear시켜주지 않으면 MCU를 reset시켜 시스템을 정상적으로 동작하고 있는지 감시하고 지속적인 오동작을 방지 신뢰성 향상 기술

### 나. WDT의 필요성

1. 제어 실패 방지 메커니즘 필요
   - 불필요한 반복 또는 제어 실패를 방지하는 메커니즘 필요
2. 예상치 못한 실패 안전모드 필요
   - 시스템 일부가 예상 못한 제어 실패 시 안전모드로 전환 필요

## 2. WDT 개념도 및 구성요소

### 가. WDT 구성도

![image-20200807170209219](https://user-images.githubusercontent.com/58545240/89979546-fddea780-dcaa-11ea-9812-ccdb3034ef7c.png)

### 나. WDT 구성요소

- `Clock` : HW 디바이스를 동작시키는 외부 Clock Source
- `Clear(Res-tart/Kick)` : HW 디바이스가 정상 동작함을 알려주는 주기적 Alive 신호
- `Timeout` : 타이머가 종료되었음을 알려주는 Output신호
- `Reset` : HW 디바이스를 초기화 할 수 있는 입력 시그널

### 다. WDT 동작방식

- Watchdog 타이머는 HW를 주기적으로 감시하며 시간을 쟤는 계수 회로. 디바이스로부터 일정 시간동안 입력값을 받지 못 하는 경우 시스템의 오동작 상황으로 간주하고 초기화 수행

## 3. WDT 유형 및 사례

### 가. WDT의 유형

![image-20200807170451892](https://user-images.githubusercontent.com/58545240/89979560-06cf7900-dcab-11ea-8cae-09f913ee24de.png)

- 외부 워치독 타이머는 고가이므로 높은 신뢰성 요구하는 시스템에 주로 사용

### 나. WDT 구현 방법

![image-20200807170528165](https://user-images.githubusercontent.com/58545240/89979575-0e8f1d80-dcab-11ea-9903-75f8c6ab0eba.png)

- 워치독 타이머는 고정 또는 프로그래밍 가능한 시간 간격 가능, 다단계 워치독의 각 타이머는 각 다른 시간 간격 가능

## 4. WDT 하드웨어 내부구조

![image-20200807170626944](https://user-images.githubusercontent.com/58545240/89979593-1ea6fd00-dcab-11ea-9d03-509967d06e73.png)

- `Watchdog Control Register (WDCR)`
  - 워치독을 컨트롤 하는 레지스터
  - 리셋 상태 설정, 사용여부, 로직 체크
- `Watchdog Counter Register (WDCNTR)`
  - 워치독 카운터의 상태 레지스터
  - 현재까지 카운팅 된 값 확인 가능
- `Watchdog Reset Key Register (WDKEY)`
  - 워치독 카운터를 Clear 하는 역할
- `System Control and Status Register(SCSR)`
  - 워치독 카운터 출력 신호 결과를 리셋 / 인터럽트에 이용 여부 결정

## 5. WDT 소프트웨어

### 가. WDT SW 동작 방식

![image-20200807170817579](https://user-images.githubusercontent.com/58545240/89979602-2666a180-dcab-11ea-8d22-095cf6e2ac56.png)



- 워치독 소프트웨어는 타이머 만료 시 작업 정의 및 하드웨어 타이머 시작 후 주기적 타이머 초기화 수행

### 나. WDT SW 사례

![image-20200807171644205](https://user-images.githubusercontent.com/58545240/89979616-2cf51900-dcab-11ea-838a-edf314b19a38.png)



# **MUTEX를 이용한 쓰레드 동기화**

---

## 1. 공유자원에 대한 접근 제어

다수의 객체가 공유 자원에 접근하려고 하면, (공유 자원의 종류에 따라서) 접근 시점을 동기화 시켜줄 필요가 생긴다. 여기에서 동기화란 시간과 공간을 맞추어 준다는 의미로, 즉 공유 자원 영역(공간)에 접근하는 객체들의 진입 시간을 제어할 수 있어야 함을 의미한다.

`Multi Thread(멀티 쓰레드)` 프로그램 역시 공유 자원에 여러 개의 쓰레드가 접근할 수 있으므로 **공유 자원 영역**에 대한 동기화가 필요하다.

카운팅 프로그램을 예로 들어보자. 카운트 변수는 전역변수(:12)로 A,B 두개의 쓰레드가 공유하면서, 1씩 증가하는 카운팅 정보를 유지하기 위해 사용된다. 공유자원 영역 즉 **"count 값을 읽어 오고, 연산을 해서 저장하는"** 영역에 대한 쓰레드간 동기화가 이루어지지 않는다면 아래와 같은 일이 발생할 수 있따.

1. global int count = 0;
2. A 쓰레드가 count값 0을 읽는다.
3. B 쓰레드가 count값 0을 읽는다.
   - A 쓰레드가 카운팅 연산을 하기 전에 B 쓰레드가 접근해 버린 상황이다.
4. A 쓰레드가 count+1 연산을 하고 값을 쓴다. count = 1
5. B 쓰레드가 count+1 연산을 하고 값을 쓴다. count = 1

A와 B 쓰레드가 한번씩 카운팅 연산을 했으므로 count값은 2가 되어야 하겠지만 실제로는 1이 저장되어 버렸다.

이러한 문제의 해결을 위해 쓰레드를 동기화 시켜줄 필요가 있다!!

## 2. 동기화 달성의 방법

일반적으로 동기화는 "공간과 시간"을 제어하는 방식으로 이루어진다. 즉 **"접근 제어가 피요한 공간"을 지정하고 지정한 "공간에 진입 할 수 있는 시간"을 제어하는 방식**이다.

여기에서 "접근 제어가 필요한 공간"에는 **보호해야할 공유자원**이 놓인다. 보호 해야할 공유 자원이 있는 공간을 **임계 영역**이라고 한다. 

시간제어는 해당 **임계 영역**에 동 시간에 단지 하나의 쓰레드만 접근하도록 제한 하는 방식으로 이루어진다.

임계영역에 들어가기 위한 **하난의 키**를 가지고 경쟁하는 것으로 이해하면 된다. 임계영역에 들어가기 위한 키는 단지 하나 밖에 없으므로 어떤 쓰레드가 키를 얻어서 임계영역에 진입하면, 다른 쓰레드는 키를 얻을 때 까지 ( 앞서 임계영역에 진입한 프로세스가 키를 되돌려 줄 때까지 ) 기다려야 한다.

![image-20200819170012492](https://user-images.githubusercontent.com/58545240/90612300-cf307600-e242-11ea-9868-c547b8baf1bd.png)

위의 카운팅 프로그램을 예로 들어 보자. **임계 영역**은

1. count값을 읽어와서
2. 카운팅 연산을 하고
3. 연산 결과글 저장하는 

코드영역으로 지정할 수 있을 것이다.

**이 임계영역에는 오직 하나의 쓰레드만이 진입할 수 있다.** 즉 **쓰레드A**가 임계영역에 진입해서 코드를 수행 중에 있다면 **쓰레드 B**는 임계 영역 밖에서 기다려야 한다. 이렇게 쓰레드를 동기화 시킴으로써, 아래와 같이 제대로된 카운팅 연산을 보장할 수 있게 된다.

1. global int count = 0;
2. A쓰레드가 임계 영역에 진입
3. B쓰레드가 임계 영역 진입을 시도하지만, A쓰레드가 진입해 있으므로 임계영역 밖에서 대기한다.
4. A쓰레드가 count값을 일고 
5. 카운팅 연산을해서
6. 값을 저장한다. count = 1
7. A쓰레드가 임계영역에서 빠져나온다
8. 비로소 B쓰레드가 임계영역에 진입해서
9. count값 읽어서 카운팅 연산을 하고 저장한다. count = 2

## 3. MUTEX

뮤텍스는 `pthread`에서 제공하는 동기화 매커니즘으로 **공유 자원 공간**에 대한 접근 시간 제어로 동기화를 달성한다. 기본적인 메커니즘은 `세마포어(:12)`와 비슷하다. 

특히 **POSIX(:12) 세마포어**와 비슷하며, 동기화 매커니즘으로 뮤텍스 대신 세마포어를 사용할 수도 있다. 동기화 매커니즘의 핵심은 **상호 배제**로 다음과 같이 달성한다.

```C
global int v = 1;
lock(){
    while(1){
        if(v==1) break;
    }
    v = 0;
    return 1;
}

unlock(){
    v = 1;
    break;
}
```

어디까지나 매커니즘 상으로 그렇다는 얘기고, 세마포어와 마찬가지로 `busy wait` 상태에 놓이지 않음을 보장한다.

**상호 배제**는 잠금 형식으로 이루어진다. 쓰레드는 **잠금 v**를 얻어야 임계 영역에 진입할 수 있다. 임계 영역을 빠져나오면 잠금을 되돌려 줘서 다른 쓰레드가 잠금을 얻을 수 있도록 한다.

뮤텍스 메커니즘의 특징을 정리했다.

- **Atomicity** : mutex 잠금(lock)은 최소 단위 연적(atomic operation)으로 작동한다. 하나의 쓰레드가 `mutex`를 이용해서 잠금을 시도하는 도중에 다른 쓰레드가 `mutex` 잠금을 할 수 없도록 해준다는 뜻이다. 한번에 하나의 `mutex` 잠금을 하도록 보장해준다.
- **Singularity** : 만약 쓰레드가 mutex 잠금을 했다면, 잠금을 한 쓰레드(:12)가 mutex 잠금을 해제 하기 전까지 다른 어떠한 쓰레드도 mutex 잠금을 할 수 없도록 보장해준다.
- **Non-Busy Wait** : 바쁜대기 상태에 놓이지 않는다는 뜻으로, 하나의 쓰레드가 mutex 잠금을 시도하는 데 이미 다른 쓰레드가 mutex 잠금을 사용하고 있다면, 이 쎄르드는 다른 쓰레드가 락을 해제하기 전까지 해당 지점에 머물러 있으며 이 동안 어떠한 CPU 자원도 소비하지 않는다.(이를테면 `sleep`)

## 4. MUTEX 만들기

뮤텍스를 생성하기 위해서 우리는 먼저, 뮤텍스 정보를 저장하기 위한 타입인 **`pthread_mutex_t`**를 선언해주고 이것을 초기화 해주어야 한다.

선언과 초기화의 가장 간단한 방법은 `PTHREAD_MUTEX_INITIALIZER` 상수를 할당하는 것으로 아래와 같이 사용할 수 있다.

```c
pthread_mutex_t a_mutex = PHTREAD_MUTEX_INITIALIZER;
```

혹은 `phread_mutex_init(3)`함수로 뮤텍스를 생성할 수도 있다.

```C
#include <pthread.h>

int pthread_mutex_init(phtread_mutex_t *mutex, const phtread_mutex_attr *attr);
```

## 5. MUTEX 잠금, 잠금해제, 제거

뮤텍스 잠금을 위한 함수로는 `phtread_mutex_lock()`함수를 제공한다. 이 함수는 해당 뮤텍스에 대해서 잠금을 시도하는데, 만약 잠그려는 뮤텍스가 다른 쓰레드에 의해서 이미 잠겨있다면, 잠금을 얻을 수 있을때까지( 이미 잠근 다른 쓰레드가 뮤텍스의 잠금을 해제할 때까지 ) 봉쇄( block )되게 된다.

다음은 이러한 뮤텍스 잠금을 얻기 위한 지원함수들이다.

```C
int pthread_mutex_lock(phtread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);
int pthread_mutex_destroy(pthread_mutex_t *mutex);
```

`pthread_mutex_trylock()`을 사용하면 잠금을 얻을 수 없을 경우 해당 코드에서 `블럭`되지 않고 바로 에러코드를 돌려준다. 즉, `pthread_mutex_lock`의 비봉쇄 버전이라고 생각하면 된다.

뮤텍스 잠금을 얻은 후 해당 영역에서의 작업을 마친 후 잠금을 해제하기 위해서 사용된다. 사용되는 함수는 `phtread_mutex_unlock(3)`이며 함수 원형은 다음과 같다.

```C
int phtread_mutex_unlock(pthread_mutex_t *mutex);
```

다음은 쓰레드간 공유되는 자원을 위해서 잠금을 어떻게 사용하는지를 보여주는 간단한 예제다.

```c
#include <stdio.h>
#include <unistd.h>
#include <pthread.h>

int ncount;		// 쓰레드간 공유되는 자원
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;		// 쓰레드 초기화

void* do_loop(void *data){
    int i;
    for(i=0; i<10; i++){
        pthread_mutex_lock(&mutex);			// 잠금을 생성한다.
        printf("loop1 : %d\n", ncount);
        ncount ++;
        if(i == 10) return;
        pthread_mutex_unlock(&mutex);		// 잠금을 해제한다.
        sleep(1);
	}
}

void* do_loop2(void *data){
    int i;
    
    // 잠금을 얻으려고 하지만 do_loop에서 이미 잠금을 얻었음으로 잠금이 해제될때까지 기다린다.
    for(i=0; i<10; i++){
        pthread_mutex_lock(&mutex);			// 잠금을 생성한다.
        printf("loop2 : %d\n", ncount);
        ncount++;
        pthread_mutex_unlock(&mutex);		// 잠금을 해제한다.
        sleep(2);
    }
}

int main(){
    int	thr_id;
    pthread_t p_thread[2];
    int status;
    int a = 1;
    
    ncount = 0;
    thr_id = pthread_create(&p_thread[0], NULL, do_loop, (void *)&a);
    sleep(1);
    thr_id = pthread_create(&p_thread[1], NULL, do_loop2, (void *)&a);
    
    pthread_join(p_thread[0], (void *)&status);
    pthread_join(p_thread[1], (void *)&status);
    
    status = pthread_mutex_destroy(&mutex);
    printf("code = %d\n", status);
    printf("programming is end");
    return 0;
}
```

위의 코드를 우선 mutex 잠금을 하지 않은 채 컴파일 후 실행 해보자. 간단하게 `pthread_mutex_lock`과 `pthread_mutex_unlock`부분만 주석처리하면 된다.

그러면 `do_loop2`과 `do_loop`이 일정 간격을 두고 ncount 자원에 접근하는 것을 볼 수 있을것이다. 그러나 우리는 `do_loop`가 ncount자원을 접근하고 있는 동안 다른 쓰레드가 접근하지 않기를 원할 때가 있을 것이다. 이럴 때 뮤텍스잠금을 사용하면 된다.

위의 코드에서 잠금 부분의 주석을 다시 풀고 컴파일 후 실행해보면 `do_loop`쓰레드가 ncount 증가 작업을 모두 마칠 때까지 `do_loop2`쓰레드는 해당영역에서 `block`됨을 알 수 있다. 이런 식으로 **하나의 쓰레드가 특정자원에 접근할 때 다른 쓰레드가 접근하지 못하도록(한번에 하나의 쓰레드만 해당 자원에 접근할 수 있도록) 제어**할 수 있다.

컴파일 방법은 `gcc -o mutex_lock mutex_lock.c -lpthread`이다.

더이상 뮤텍스를 사용할 일이 없다면 `pthread_mutex_destroy`를 이용해서 뮤텍스 자원을 제거(free)하도록 한다. 만일 뮤텍스 자원을 사용하는 쓰레드가 하나라도 존재한다면 에러코드(`EBUSY`)를 리턴한다. 그러므로 **모든 쓰레드의 뮤텍스에 대해서 `pthread_mutex_unlock`을 이용해서 잠겨져야만 뮤텍스 제거가 성공할 수 있다. 성공할 경우 `0`을 넘겨준다.**



++21/02/17

뮤텍스는 우선순위 상속 메커니즘을 포함하는 **이진 세마포어**이다. 이진 세마포어가 동기화를 구현하는 데 더 나은 선택(작업 간, 또는 작업과 인터럽트 간) 인 반면, MUTEX는 단순한 상호배제( `MUT`ual `EX`clusion ) 을 구현하는데 더 나은 선택이다.

상호배제에 사용될 때 뮤텍스는 리소스를 보보하는 데 사용되는 `토큰`처럼 사용된다. 작업이 리소스에 액세스하려면 먼저 토큰을 가져와야 하고(**`TAKE`**), 리소스의 사용이 완료되면 토큰을 다시 주어야 한다.(**`GIVE`**). 다른 작업이 동일한 리소스에 액세스 할 수 있는 기회를 허용해야 한다.

뮤텍스는 동일한 세마포어 액세스 API 함수를 사용하므로 블록시간도 지정할 수 있다. 차단 시간은 뮤텍스를 즉시 사용할 수 없는 경우 뮤텍스를 취하기(TAKE) 시도할 때 TASK가 차단됨 상태로 들어가야 하는 최대 `틱`수를 나타낸다. 그러나 바이너리 세마포어와 달리 뮤텍스는 **우선순위 상속**을 사용한다.

즉, 현재 우선순위가 낮은 태스크가 보유한 뮤텍스(토큰)을 얻으려고 시도하는 동안 우선순위가 높은 태스크가 차단되면 토큰을 보유한 태스크의 우선순위가 일시적으로 차단 태스크의 우선 순위로 올라간다. 이 메커니즘은 우선순위가 높은 작업이 가능한 가장 짧은 시간 동안 차단 된 상태로 유지하도록 설계되어 이미 발생한 **우선 순위 반전**을 최소화 한다.

우선 순위 상속은 우선 순위 반전을 치료하지 않는다. 일부 상황에서는 그 효과를 최소화 할뿐이다. 하드 실시간 애플리케이션은 우선 순위 반전이 발생하지 않도록 설계되어야한다.

다음과 같은 이유로 인터럽트에서 뮤텍스를 사용해서는 안된다.

- 여기에는 인터럽트가 아닌 작업에서 뮤텍스가 주어지고 가져 오는 경우에만 의미가 있는 우선 순위 상속 메커니즘이 포함된다.
- 인터럽트는 뮤텍스에 의해 보호되는 리소스가 사용 가능해질 때까지 대기하도록 차단할 수 없다.

# **Semaphore**

---

> 프로세스 간 메시지를 전송하거나, 공유메모리를 통해 특정 데이터를 공유하게 되는 경우 문제가 발생할 수 있다. 
>
> 즉, 공유된 자원에 여러 개의 프로세스가 동시에 접근하면서 문제가 발생하는 것으로써 공유된 자원 속 하나의 데이터는 한 번에 하나의 프로세스만 접근할 수 있도록 제한해 두어야 하는데 이를 위하여 고안된 것이 바로 **Semaphore(세마포어)**이다.

## Critical Section이란?

OS에서 `Critical Section`은 아주 중요한 부분이다.

다중 프로그래밍 운영체제에서 여러 프로세스가 데이터를 공유하면서 수행될 때 **각 프로세스에서 공유 데이터를 액세스하는 프로그램 코드 부분**을 가리키는 말이다.

공유 데이터를 여러 프로세스가 동시에 액세스하면 시간적인 차이 때문에 잘못된 결과를 만들어 낼 수 있기 때문에 한 프로세스가 위험 부분을 수행하고 있을 때, 즉 공유 데이터를 액세스하고 있을 때는 다른 프로세스들은 절대로 그 데이터를 액세스하지 못하도록 해야 한다.

### - 예제

컴퓨터가 여러 프로그램을 동시에 수행하는 다중 프로그래밍 시스템에서는 프로세스들간의 상호배제와 동기화를 위한 기본적인 연산이 필요하게 되고 세마포어는 여러 프로세스들에 의해 공유되는 변수로 정의됩니다.

그런데 이 변수는 보통의 방법으로는 액세스할 수 없고 오직 P와 V라는 연산으로만 다룰 수 있습니다.

P와 V연산의 정의는 아래와 같습니다.

```bash
# P
procedure P(S)            --> 최초 S값은 1

while S=0 do wait        --> S가 0이면 1이 될 때까지 wait

S := S-1                     --> S를 0로 만들어 다른 프로세스가 들어 오지 못하도록 함

end P
```

```bash
# V
procedure V(S)          --> 현재상태는 S가 0

S := S+1                  --> S를 1로 원위치시켜 해제하는 과정

end V                     -->이제는 다른 프로세스가 들어 올수 있음
```

즉 한 프로세스가 P나 V를 수행하고 있는 동안에는 프로세스가 인터럽트를 당하지 않게 됩니다. 이제 P와 V를 사용하면 다음과 같이 위험지역(cirtical section)에 대한 상호배제를 구현할 수 있게 됩니다.

```bash
P(S);

------------------------

위 험 지 역(Critical Section) = 임계영역

------------------------

V(S);
```

최초에 S의 값은 1이고, 위와 같은 위험지역을 포함하는 두개의 프로세스 A와 B가 있다고 할 때,

A와 B는 서로 독립적으로 수행되지만, 두 프로세스가 동시에 위험 지역으로 들어가서는 안된다.

위와 같이 세마포어를 사용하면 P(S)를 먼저 수행하는 프로세스가 S를 0으로 해놓고 위험지역에 들어가므로 나중에 도착하는 프로세스는 P에서 더이상 진행되지 못하고 기다리게 된다. 먼저 들어갔던 프로세스가 V(S)를 해주어야 비로서 P(S)에서 기다리던 프로세스가 위험지역에 들어갈 수 있고 따라서 상호배제가 실현된다. 

## 세마포어와 뮤텍스의 차이

### 세마포어란?

> - 세마포어(Semaphore) : 공유된 자원의 데이터를 여러 **프로세스**가 접근하는 것을 막는 것
> - 뮤텍스(Mutex) : 공유된 자원의 데이터를 여러 **쓰레드**가 접근하는 것을 막는 것

세마포어는 리소스의 상태를 나타내는 간단한 카운터로 생각할 수 있다. 일반적으로 비교적 긴 시간을 확보하는 리소스에 대해 이용하게 되며, 유닉스 시스템의 프로그래밍에서 세마포어는 운영체제의 리소스를 경쟁적으로 사용하는 다중 프로세스에서 행동을 조정하거나 또는 동기화 시키는 기술이다.

세마포어는 운영체제 또는 커널의 한 지정된 저장장치 내 값으로서, 각 프로세스는 이를 확인하고 변경할 수 있습니다. 확인되는 세마포어의 값에 따라, 그 프로세스가 즉시 자원을 사용할 수 있거나, 또는 이미 다른 프로세스에 의해 사용 중이라는 사실을 알게 되면 재시도하기 전에 일정 시간을 기다려야만 합니다. 세마포어는 이진수 (0 또는 1)를 사용하거나, 또는 추가적인 값을 가질 수도 있습니다. 세마포어를 사용하는 프로세스는 그 값을 확인하고, 자원을 사용하는 동안에는 그 값을 변경함으로써 다른 세마포어 사용자들이 기다리도록 해야합니다.

### 뮤텍스란?

Mutual Exclusion 으로 상호배제라고도 한다. Critical Section을 가진 쓰레드들의 Runnig Time이 서로 겹치지 않게 각각 단독으로 실행되게 하는 기술입니다. 다중 프로세스들의 공유 리소스에 대한 접근을 조율하기 위해 locking과 unlocking을 사용합니다. 

즉, 쉽게 말하면 뮤텍스 객체를 두 쓰레드가 동시에 사용할 수 없다는 의미입니다.



### Semaphore vs Mutex

1. Semaphore는 Mutex가 될 수 있지만 Mutex는 Semaphore가 될 수 없다.	

   (Mutex는 상태가 0, 1 두 개 뿐인 binary Semaphore)

2. Semaphore는 소유할 수 없는 반면, Mutex는 소유가 가능하며 소유주가 이에 대한 책임을 진다.

   (Mutex의 경우 상태가 두 개 뿐인 lock이므로 lock을 가질 수 있다.)

3. Mutex의 경우 Mutex를 소유하고 있는 쓰레드가 이 Mutex를 해제할 수 있다. 하지만 Semaphore의 경우 이러한 Semaphore를 소유하지 않는 쓰레드가 Semaphore를 해제할 수 있다.

4. Semaphore는 시스템 범위에 걸쳐져 있고 파일시스템상의 파일 형태로 존재한다. 반면 Mutex는 프로세스 범위를 가지며 프로세스가 종료될 때 자동으로 `clean up`된다.



**가장 큰 차이점은 관리하는 동기화 대상의 갯수이다. Mutex는 동기화 대상이 오직 하나 뿐일 때, Semaphore는 동기화 대상이 하나 이상일 때 사용한다.**

# **Loopback**

---

> **루프백(Loopback, loop-back)이란 전기신호의 라우팅, 디지털 미디어 스트림, 또는 품목의 흐름이 의도적인 가공이나 수정 없이 원래의 장치나 장비로 돌아가는 것**
>
> 주로 전송이나 수송 기반 시설을 테스트하는 수단으로 사용
>
> - 하나의 종단점(endpoint)만 가지는 커뮤니케잉션 채널, 이러한 채널에서 전송된 메시지는 어떤 것이라도 같은 채널로부터만 즉시 수신됨.
> - Serving switching center로부터 온 액세스 라인의 전송 테스트 수행시 served terminal에서 인력을 필요로 하지 않음
> - 두 라인이 사용되는 스테이션(반드시 인접할 필요는 없음)의 연결 테스트. 한 스테이션에서 그리고 멀리 떨어진 스테이션에서 상호 연결된 두 라인에서 이루어지는 테스트를 동반함. 일반적으로 상호연결된 회로가 다이얼링에 의해서 액세스 될 때 루프 어라운드(loop around)라고 불림
> - 루프-백(loop-back) 테스트를 용이하게 하는 패치 케이블

## 가상 루프백 인터페이스(TCP/IP)

[인터넷 프로토콜 스위트](https://ko.wikipedia.org/wiki/인터넷_프로토콜_스위트)(Internet Protocol Suite)의 구현은 가상 네트워크 인터페이스를 포함한다. 같은 기기에서 작동하는 네트워크 응용 프로그램 클라이언트와 서버는 이 인터페이스를 통해 통신할 수 있다. 이 인터페이스는 운영 체제의 네트워킹 소프트웨어 내에서 완전히 구현되며 네트워크 인터페이스 컨트롤러에 패킷을 보내지 않는다. 컴퓨터 프로그램이 루프백 IP 주소로 보낼 수 있는 어떠한 트래픽도 다른 장치로부터 수신한 것처럼 간단하고 빠르게 네트워크 소프트웨어 스택으로 다시 보내진다.

유닉스 계열 시스템에서는 보통 이것을 루프백 인터페이스 lo 또는 lo0라고 명명한다.

다양한 IETF 기준은 IPv4 주소 블록 127/8 (127.0.0.1가 가장 일반적으로 사용됨), the IPv6 주소 ::1, 그리고 이 목적을 위한 localhost 이름을 보유한다..

## 네트워크 장비

일부 네트워크 장비들은 관리 목적으로 사용되는 가상 인터페이스에 대해 루프백이라는 용어를 사용한다. 정상적인 의미의 루프백 인터페이스와 달리, 이 루프백 장치는 장치 스스로의 전송 및 수신을 하기 위해 사용되지는 않는다.

그러한 인터페이스는 네트워크 상의 관리 장비로부터 액세스 될 수 있는 주소에 할당되지만, 장치의 실제 인터페이스에는 할당되지 않는다. 이 루프백 주소는 알람과 같이 장비에서 유래한 관리 데이터그램에도 사용된다. 이 가상 인터페이스의 특별한 점은 이 인터페이스를 이용하는 응용 프로그램들이 트래픽이 통과하는 물리적 인터페이스 주소가 아닌 가상 인터페이스에 할당된 주소를 이용해서 트래픽을 전송하거나 수신한다는 것이다.

## 시리얼 인터페이스

시리얼 커뮤니케이션 송수신기(transceiver)는 기능을 테스트하기 위해 루프백을 이용할 수 있다. 예를 들어 장치의 수신 핀(receive pin)으로 연결되는 전송 핀(transmit pin)은 핀이 전송하는 것을 장치가 정확히 수신하도록 할 것이다. 이 루프 연결을 케이블의 remote end로 이동시킨 후 해당 케이블을 이 테스트에 추가한다. 그 연결을 모뎀 링크의 더 먼 지점으로 옮기면 테스트의 범위가 더욱 확장된다. 이것은 흔히 사용되는 문제 해결 기술이며, 특정한 패턴을 전송하고 반송되는 에러를 감지하는 특정 테스트 기기와 결합 되기도 한다 (비트 오류율 테스트-Bit Error Rate Test- 참조). 몇몇 기기들은 루프백이 가능한 장치를 내장하고 있다.

페이퍼클립 테스트(paperclip test)라고 불리는 간단한 시리얼 인터페이스 루프백 테스트는 때로 컴퓨터의 시리얼 포트를 알아내고 실행을 검증하기 위해 사용된다. 이 테스트는 터미널 에뮬레이터(terminal emulator) 응용 프로그램을 활용하여, 문자를 플로우 컨트롤 세트(flow control set)와 함께 시리얼 포트에 전송하고 같은 내용을 다시 수신한다. 이러한 목적을 위해 페이퍼클립은 D-서브 미니어처 DE-9 또는 DB-25 커넥터를 사용하는 표준 RS-232 인터페이스에서 핀 3(수신 핀과 전송 핀)에 대한 짧은 핀 2(short pin 2)로 사용된다.

## 통신

[통신](https://ko.wikipedia.org/wiki/통신)에서 루프백(짧게 루프라고 씀)이란 수신된 신호나 데이터를 전송자에게 피드(feed)하는 하드웨어나 소프트웨어 방법이다. 루프백은 물리적 연결 문제의 디버깅을 돕기 위해서 사용된다. 테스트로서 많은 데이터 커뮤니케이션 장치들이 인터페이스에서 특정 패턴(all ones와 같은)을 전송하기 위해 설정 될 수 있으며 같은 포트에서 이 신호들의 수신을 감지할 수 있다. 이것은 루프백 테스트라고 불리며 모뎀이나 송수신기내에서 아웃풋을 인풋과 연결시킴으로써 수행될 수 있다. 테스트 신호를 한 장소의 회로에 적용하고 다른 장소에 있는 네트워크 장치가 회로를 통해 신호를 되보내게 하여, 서로 다른 두 지점 사이의 회로를 테스트 할 수 있다. 만약 이 장치가 신호를 그대로 되돌려 받는다면 그 회로가 잘 작동하고 있다는 뜻이 된다.

하드웨어 루프는 수신 채널을 전송 채널에 물리적으로 연결하는 간단한 장치이다. X.21과 같은 네트워크 터미네이션 커넥터(network termination connector)의 경우, 간단히 커넥터의 핀들을 연결하는 것이 전형적이다. 분리된 전송과 수신 커넥터를 가지는 광섬유나 동축 케이블(coaxial cable) 같은 매개체들은 적절한 매개체들의 단선(single strand)으로 간단하게 루프될 수 있다.

모뎀은 원격 모뎀이나 로컬 터미널(local terminal)로부터 들어오는 신호를 루프하도록 설정될 수 있다. 이것은 루프백 또는 소프트웨어 루프라고 일컬어진다.

## 다른 응용 프로그램

명명된 파이프(named pipe) 또한 파일 시스템 단계에서 루프백으로 간주할 수 있다. 유닉스 도메인 소켓(Unix domain socket)과 네트워크 소켓이 프로세스간 커뮤니케이션을 위해 두 연결된 파일을 사용하는 동안, 명명된 파이프는 오로지 하나의 파일로 구성된다.

오디오 시스템인 OSS, **ALSA**, 그리고 PulseAudio 또한 응용 프로그램과 테스팅 목적의 음성 아웃풋을 녹음하기 위한 루프백 모듈을 가지고 있다. 물리적 루프백과 달리 이중 아날로그/디지털 변환이나 하드웨어 오작동으로 인한 중단이 없다.

# **HAL**

> **Hadrware Abstraction Layer (하드웨어 추상화 계층)**

하드웨어 추상화 계층이란 컴퓨터 본체와 같은 물리적 하드웨어와 `OS` 같은 컴퓨터에서 실행되는 소프트웨어 사이의 추상화 계층이다.

이게 무슨말인가?

과거에는 운영체제의 커널이 하드웨어를 조작하기 위한 추상적 인터페이스를 제공하였다. **`System Call`**이라는 인터페이스가 있어서 하드웨어 `I/O`를 디바이스 노드에 실행하였다. 하드웨어 종류가 많지 않던 과거에는 이 방법이 나쁘지 않았다.

하지만 하드웨어 종류는 시간이 갈수록 늘어만 갔고 커널은 새로운 장치들을 인식하거나 변화된 상태를 인식하는데 많은 어려움이 따랐다. 그래서 하드웨어 차이에 상관이 없는 하드웨어 인식 방법을 개발하고자 하는 취지로 **HAL**은 연구되었다.

개발된 `HAL`의 작동원리는 이렇다. 어플리케이션들은 **D-Bus IPC** 라는 작동방식으로 하드웨어를 조작한다. 각각의 하드웨어는 각각 **D-Bus**  객체라고 저으이되어 고유의 주소를 식별자로 사용한다. `HAL`은 카메라가 연결되거나 DVD가 돌아가거나 노트북 덮개가 덥히는 등 하드웨어의 변화를 시그널로 감지하여 어플리케이션들이 그에 따라 반응할 수 있도록 한다. 

HAL의 큰 장점은 하드웨어가 변겨오디더라도 소프트웨어가 작동할 수 있는 플랫폼을 제공한다는 것이다. 예를 들어, 워드에서 문서를 출력하고자 하는데 프린터가 바뀌었다고 하자. HAL이 없었으면 바뀐 프린터 드라이버에 대한 정보가 워드 프로그램에 다시 반영되어야 하므로 프린터 드라이버에 있는 내용을 다시 워드 프로그램에 또한 적용시켜야 했다.

마이크로소프트사에서는 Windows NT가 HAL에 기반하고 있다. HAL이 NT에 주는 장점은 NT의 휴대성을 높여주는 데 있다. 하드에어마다 HAL은 각각 다르게 작성되어야 한다.

하지만 하드웨어가 달라지더라도 HAL만 다시 작성하면 다른 부분의 운영체제는 특별히 다시 작성될 필요 없이 다시 컴파일만 하면 된다. 그래서 예전처럼 NT가 다른 CPU 구조에 인식되어야 할 때 용이했다.

현재 HAL에서 한 걸음 더 나아가 API가 사용된다. 소프트웨어는 이미 구성되어 있는 API르르 가지고 하드웨어를 작동시키면 된다.

API는 직접 또는 HAL을 통해 하드웨어를 컨트롤 한다. 예를 들어 GPS라는 API는 어플리케이션이 직접 하드웨어에 명령하지 않아도 하드웨어 정보를 얻을 수 있도록 도와준다.

**=> 결국 같은 종류의 부품으로 다양하게 많은 종류의 하드웨어를 설계할 수 있어 직접 하드웨어에 접근하는 형태는 다소 복잡하다. 이 점을 해결하고 복잡한 내부를 감추고 일관성 있는 인터페이스를 제공하기위해, 같은 종류의 하드웨어에 대한 공통 명령어 집합으로 묶어두는 것을 `하드웨어 추상화`라고 하고 프로그래머가 여러 장비에서 개바랗는 것을 도와준다. 하드웨어 추상화 계층은 장비 제조사의 장비 규격에 대한 특정한 명령어를 제공하는 소프트웨어 드라이버에 의존하게 된다.**

**=> 소프트웨어가 수 많은 종류의 하드웨어 상에서 별 차이 없도록 동작할 수 있도록 하는 역할을 하며 OS의 커널 또는 장치 드라이버에서 호출된다.**

**=> 소프트웨어와 하드웨어 사이에서 소프트웨어가 PC의 시스템 메모리, CPU, 또는 기타 하드웨어 장치에 직접적으로 접근하는 것을 막아주며, 소프트웨어는 HAL을 통해 하드웨어의 종류에 관계없이 컴퓨터 자원을 사용하여 일관된 작업을 수행할 수 있게 된다.**

```BASH
# 안드로드에서 HAL이 중요한 이유
안드로이드에서 HAL은 자바 API 프레임워크에 대해 기기 하드웨어 기능을 사용할 수 있도록 표준 인터페이스를 제공한다. 여러 모듈 형태로 이루어져 있으며, 카메라 모듈, 블루투스 모듈 같은 유형으로 하드웨어 구성 요소의 인터페이스를 구현한다. 프레임워크 API가 하드웨어에 접근하기 위해 호출명령을 수행하면, 안드로이드 시스템에서 해당 하드웨어 구성요소에 대한 라이브러리 모듈을 불러온다. => *트레블의 기초가 된다.*
```

# **Quota**

**`쿼터`**란 파일시스템마다 사용자나 그룹이 생성할 수 있는 파일의 용량과 개수를 제한하는 것.

리눅스는 여러명의 사용자가 동시에 접속해서 사용할 수 있는데 만약 A라는 사욪아가 시스템을 사용할 때, 루트(`/`) 파일 시스템에 큰 파일을 계속 생성해서 하드디스크가 꽉차면 시스템 전체가 가동되지 않게 된다. 이런 상황을 대비하기 위해 각 사용자별로 사용할 수 있는 용량을 제한해야하는데 이것이 바로 **`쿼터`**이다.

**ex) 사용자 두명을 생성하고, 그 사용자들에게 각각 사용할 수 있는 공간을 할당해서 제안하기**

1. 하드디스크를 하나 장착하고 파티션을 나눈 후, 파일시스템을 `ext3`로 포맷하고, 마운트까지 하기. 

   1. 먼저 파티션을 나누어야 한다.

   2. 그다음 `ext3`으로 포맷을 한다.

   3. 마운트를 시킨다.
   4. 부팅이되면 그때마다 자동으로 인식되도록 `/etc/fatab`의 내용을 바꿔보자.

2. 쿼터를 사용할 하드디스크를 만들었으니 이번에는 사용자를 만들어보자.

   1. 아이디는 john, bann으로 하였고, 비밀번호는 각각 아이디로 사용한다.

3. 그후에, `/etc/fstab`을 다시 편집한다.

   1. defaults부분을 defaults, usrquota로 변경한다. usrquota로 사용하겠따는 의미이다.

4. 재부팅을 한다.

5. 쿼터를 사용하기 전에 쿼터 DB를 만들어줘야한다.

   1. 쿼터 DB를 만들어보자.
   2. 빈 파일 생성 후, 보안을 위해 `aquota.user`d의 권한을 바꾼다.
   3. `quotacheck -a -u -m`은 사용자에 대해서 쿼터를 실행하는 명령이다.

6. 모든 준비가 끝났다. 이제 사용자별로 공간을 할당해주면 끝이다.

7. 이로써 사용자 john에게 공간 할당이 끝났다.