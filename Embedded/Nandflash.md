# Nandflash

>  Nandflash datsheet와 Nandflash driver source code를 기반으로 낸드플래시를 이해해보자

본격적으로 낸드플래시를 설명하기 전에 **DRAM과 플레시메모리(Flash Memory)의 차이에** 관해 설명하겠다.

저장방식에 있어서 DRAM은 **캐패시터**에 저장하는 반면 플레시메모리는 **플로팅게이트(Floating Gate:FG)**라는 곳에 데이터를 저장한다.

따라서 DRAM은 **휘발성**, 플래시메모리는 **비휘발성**의 특징을 가지게 된다.

# 낸드 플래시 메모리

---

> NAND Flash Memory
>
> 반도체의 셀이 직렬로 배열되어 있는 **플래시 메모리**의 한 종류

- 플래시 메모리(Flash Memory)는 반도체 칩 내부의 전자회로 형태에 따라 직렬로 연결된 **낸드 플래시**와 병렬로 연결된 **노어플래시**로 구분된다. 
- 낸드플래시는 용량을 늘리기 쉽고 쓰기 속도가 빠른반면 노어플래시는 읽기속도가 빠른 장점을 갖고 있다.(NOR가 쓰기가 수천배 느리다 -> 치명적 단점)
- 낸드 플래시는 저장단위인 셀을 수직으로 배열하는 구조이기 때문에 좁은 면적에 많은 셀을 만들 수 있어 **대용량화**가 가능하다.
- 또한 데이터를 순차적으로 찾아가 읽기 때문에 노어플래시보다 읽기 속도는 느리지만 별도로 **셀의 주소를 기억할 필요가 없어 쓰기속도는 훨씬 빠르다.**
- 제조단가가 노어플레시보다 싸다. 이론적으로 한 셀당 면적이 NOR형의 40% 수준이다. 수많은 셀을 집적해서 대용량을 구현하는 플래시 메모리에 있어서 작은 면적은 엄청난 장점이다. ( **면적=단가** )

=> 이처럼 낸드플래시는 소형화, 대용량화가 가능하기 때문에 다양한 모바일 기기 및 전자제품의 저장장치로 사용되고 있다!

![image-20200814135540833](https://user-images.githubusercontent.com/58545240/90222170-7fb70800-de46-11ea-9def-3269f98e7830.png)



## 낸드플래시 작동 원리

![image-20200814135952749](https://user-images.githubusercontent.com/58545240/90222177-847bbc00-de46-11ea-85be-1674beef49cd.png)

> 기본적인 모스펫 구조에 플로팅 게이트(부유 게이트)가 추가된 형테이다.
>
> 저 플로팅 게이트에 전자를 저장함으로써 데이터를 저장하는 것이다.
>
> - 플로팅 게이트에 전자가 있으면(많으면) **0**으로 인식 ( programmed )
> - 플로팅 게이트에 전자가 없으면(적으면) **1**로 인식( erased, unprogrammed )
>
> 기본 구조는 이렇지만 현재는 플로팅게이트가 아닌 산화막에 전자를 저장하고 플로팅게이트를 생략해버리는 식(삼성, CTF) 등의 발전된 방식이 많이 존재한다.

**`Control Gate`에 전압을 인가하면** `Source`에서 `Drain`으로 이동하던 전자가 **`tunneling`으로 `Floating Gate`로 들어가게 된다.**

```bash
# Note
Tunneling이란 낮은 에너지를 갖는 입자가 에너지가 높으나 공간폭이 작은 포텐셜 장벽을 횡단하는것을 의미.
```

`Floating Gate`는 산화막에 의해 `Isolation`이 되어 전원이 끊겨도 데이터가 `Floating Gate`에 그대로 남아있게 되는 방식이다.

### - Write

![image-20200814140336680](https://user-images.githubusercontent.com/58545240/90222186-8a719d00-de46-11ea-88d4-4d2aaed52098.png)

`Control Gate`와 `Drain`에 `Positive Voltage`를 인가하여 `Channel`에서 이동하는 전자들을 `Floating Gate`로 끌어당김으로써 낸드플래시 상에 Write할 수 있다.

```bash
# Note
1. 중간에 절연층(산화막)이 버티고 있는데 산화막은 기본적으로 전자가 통과할 수 없다.
2. 그래서 12~24V의 고전압을 거러웆고 드레인 측에서도 그정도로 높은 전압을 걸어준다.
3. 이정도의 강력한 전계가 형성되면 전자가 충분한 에너지를 얻어서 산화막을 통과한다.
4. 통과한 전자는 플로팅게이트에 저장되어 전계가 사라져도 산화막에 의해 외부로 유출되지 않는다.
```



### - Read

![image-20200814135918305](https://user-images.githubusercontent.com/58545240/90222192-8f365100-de46-11ea-8284-17b91a72d5e1.png)

하나의 Bit Line에 다수의 셀이 직렬로 연결되어 있다. 따라서 Bit Line에 전압을 인가하면 직렬로 연결된 모든 셀에 전압이 인가가 되고 `Control Gate`에 전압을 인가한 셀에서만 `Channel`이 형성된다.

이 때, `Floating Gate`상에 전자가 있는 셀은 `Control Gate`와 `Floating Gate`간 **Electric Field 간섭으로 인해** `Channel`에 전자가 잘 흐르지 못해 **Threshold Voltage가 상대적으로 높아지게** 된다.( Vth > 0 )

반면에 `Floating Gate`에 전자가 없는 셀은 **Electric Field 간섭이 일어나지 않으므로** **Threshold Voltage가 낮다.**( Vth < 0)

따라서 읽고자 하는 셀에는 0V의 전압을 인가하고 나머지 셀에는 6 ~ 6.5V 전압을 인가한다.

만약 `Floating Gate`상에 전자가 있다면 0V 전압을 인가하였으므로 나머지 셀은 `Channel`이 형성되는 반면, 읽고자 하는 셀에서는 `Open` 상태가 된다. 그러므로 전류가 잘 흐르지 않게 되고 이를 `'0'`이라는 데이터로 인식하게 된다.

반대로 `Floating Gate`상에 전자가 없다면 0V의 전압을 인가하더라도 `Channel`이 형성되어 전류가 잘 흐르게 되어 이를 `'1'`이라는 데이터로 인식하게 된다.

### - Erase

`Floating Gate`에 있는 전자를 밝으로 방출하기 위해 `Body`와 `Source`에 `Positive Voltage`를 역으로 인가하는 방식이다.

- 플래시메모리에 데이터를 저장하기 위해서는 플로팅게이트를 비울 필요가 있다.

- 저장될 데이터가 `0`(전자저장필요)인지 `1`(전자저장불필요)인지 알 수 없는 상황에서 `Floating Gate`에 전자가 남아있다면 제대로 데이터를 기록할 수 없다.

  => 따라서 `Floating Gate`를 완전히 비워야한다.

- **방법은 쓰기의 반대이다.**

- 바디쪽에 12~24V의 강력한 전압을 걸어 쓰기때와 반대방향의 전계를 형성해서 `Floating Gate`내의 전자를 바디쪽으로 끌어낸다.

- 소스측에도 `Positive Voltage`를 걸어 쓰기 때와 반대 현상이 일어나도록 유도한다.

***SSD의 경우 이렇게 각 셀의 데이터를 지우는 작업을 쓰기작업이 발생하기 전에 미리 진행해 놓는데 이를 `Trim`이라고 한다. 이는 쓰기 속도향상에 필수적인 과정이다.***



## 낸드플래시의 수명

낸드플래시의 읽기, 쓰기, 지우기 과정을 보면 왜 낸드플래시에 수명이 존재하는지 알 수 있다.

`Floating Gate` 내의 전자가 외부로 유출되지 않고 외부전자가 `Floating Gate`로 유입되지 않도록 막는 것이 산화막의 역할임을 생각했을 때, **산화막의 수명이 곧 플래시메모리셀의 수명**이다.

읽기, 쓰기 과정에서 전자는 산화막을 통과하는 데 앞서 말했듯이 산화막은 본래 전자가 통과할 수 없는 장벽이다. 이를 억지로 통과했으니 통과할 때마다 산화막에 손상이 발생하는 것이다.

그리고 읽기/쓰기 횟수가 늘어날 수록 전자의 통과횟수는 증가할 것이고 산화막의 손상도 누적될 것이다.

그러다가 손상이 어느 수준을 넘어서면 더이상 산화막은 제역할을 못하고 읽기/쓰기 횟수가 제한 되는 것이다. => 수명이 있는것이다..

```bash
# Note
- 읽기 과정을 보면 전자가 산화막을 통과하지 않는다.
- 읽기 과정에서 전자가 유출될 수 있고, 셀의 열화가 진행된 상태에서 읽기만으로 데이터가 유실되면 그걸 복구하기위한 재기록 과정에서 열화가 가중되고, 그 과정에서 전압의 영향을 일부지만 다른 셀도 받기 때문에 읽기와 수명이 완전히 연관이 없다고 볼 수는 없지만, 과정이 수명 감소에 끼치는 영향이 쓰기/지우기에 비해 적은건 사실이다.
```

# MLC와 TLC

---

앞서 설명한 플래시메모리는 한 셀에 1비트만 저장이 가능했다. 0아니면 1이었으니까.

이런 셀을 무수히 많이 집적해서 플래시 메모리를 만드는데 셀이 10억개 집적되어 있으면 `1Gb(128MB)`의 용량을 갖는식으로.

플래시메모리는 저장매체이니 더 많은 저장용량을 원하는건 당연한 요구이다. 그래서 머리를 굴리는 것이 **"한 셀에 2비트씩 저장해보자!!"**

한셀에 저장되는 용량이 2배면 셀의 개수(메모리 다이의 크기)를 늘리지 않아도 저장용량이 단숨에 2배로 늘어난다.



?? 그럼 이것을 어떻게 구현할 것인가?

`전자있다(0)`, `전자없다(1)` 의 단순한 구분을 뛰어넘어서

`전자없다(11)`, `전자적다(10)`, `전자많다(01)`, `전자아주많다(00)`로 구분을 세분화 한것이다.

이를 기록하기 위해서 쓰기 과정에서 각 신호별 `Control Gate` 전압이 세분화된다.

`Control Gate`의 전압에 따라 저장되는 전자의 양이 결정되고 전자의 양으로 신호를 구분하게 된다. 

![image-20200814143821558](https://user-images.githubusercontent.com/58545240/90222202-94939b80-de46-11ea-89d8-770d3efdd245.png)

이렇게 한 셀에 2비티를 저장하게 된 제품을 **MLC(Multi Level Cell)**라고 한다.

여기서 더 나아간 것이 **TLC(Triple Level Cell)**이다. 한 셀에 3비트를 저장하는 것이다.

구분해야할 신호가 8개로 늘었꼬 신호별 `Control Gate` 전압은 더욱 촘촘해졌다.

![image-20200814143925178](https://user-images.githubusercontent.com/58545240/90222214-98bfb900-de46-11ea-97d3-34b92e0691bd.png)

## 왜 MLC, TLC로 갈 수록 쓰기 속도가 느린가?

쓰기를 위한 `Control Gate` 전압이 한방에 구현되지 ㅇ낳기 때문이다.

![image-20200814144028230](https://user-images.githubusercontent.com/58545240/90222226-9d846d00-de46-11ea-8a84-5c7657f3a32e.png)

TLC에서 요구하는 8가지 상태를 기록하기 위해서는 7개의 전압이 필요한데 (전자가 없는 상태는 CG전압이 필요없으니 하나가 빠져서 7개 )

이 7가지 단계가 한번에 기록되는 것이 아니다.

위 단계를 보면 3단계에서 걸쳐서 이루어지는데

1. erased상태를 벗어나고
2. 7개의 상태로 대략적으로 조정하고
3. 다른 신호와 겹치지 않게 더 정밀하게 조정한다.

**SLC(Single Level Cell)**에 비해 기록단계를 더 거치기 때문에 쓰기에 더 긴 시간이 걸리고 쓰기 속도가 느려지는 것이다.

읽기 속도에서 `SLC`, `MLC`, `TLC` 모두 큰 차이가 없는 것은 읽기원리를 보면 답이 나온다. 그 과정은 비슷하기 때문에!



## 왜 MLC, TLC로 갈 수록 수명이 급격히 줄어드는가?

상황을 가정해보겠다. 산화막의 손상이 발생했다.

- SLC에서 **`0`**을 기록하기 위해 전압을 걸지 않았다. 산화막 손상때문에 약간 전자가 들어왔지만 어차피 신호는 전자가 많고 적은 상태만 구분하면 되기 때문에 읽기 과정에서 문제없이 **`0`**으로 인식되었다.
- MLC에서 **`01`**을 기록하기 위한 전압을 걸었다. 산화막 손상때문에 예상보다 많은 전자가 들어오긴했지만 **`10`**상태의 전자량보다 적다. 읽기과정에서 정상적으로 **`01`**이라고 인식되었다.
- TLC에서 **`001`**이라는 내용을 기록하기 위한 전압을 걸었다. 그런데 산화막이 손상되어 예상보다 많은 전자가 `Floating Gate`에 저장되었다. 늘어난 전자량 때문에 읽기과정에서 **`001`**이 아닌 **`010`**으로 인식되었다. 이러면서 오류가 생긴다. 특별한 조치가 없는 한 이셀은 수명을 다한것이다.

=> `SLC`, `MLC`, `TLC`로 갈수록 각 신호의 구분은 더 촘촘해지고, 더 정밀하게 전자의 수가 조절되어야 한다. 산화막의 손상으로 인해 전자의 수가 컨트롤되지 않았을 때 가장 민감하게 반응하는것이 **`TLC`**일 수 밖에 없다. 이 때문에 `MLC, TLC`로 갈수록 수명이 기하급수 이상으로 빠르게 감소하는 것이다.

# 공정미세화가 진행될 수록 수명이 줄어드는 이유

---

다이 크기를 줄이기 위해서 공정미세화는 필수 불가결한 요소이지만 문제는 그에 따라 수명이 감소한다는 것이다. 

제조 공정이 발전할 수록 셀의 크기는 줄어들고 한 셀에 저장할 수 있는 전자의 수도 줄어든다. 더욱 더 미세하게 각 신호별 전자수를 조절해야 한다.

누설로 인한 전자 수의 변화에 더욱 민감해질 수 밖에 없다.



# 생명연장의 꿈

> 그렇다고 손놓고 있을 엔지니어들이 아니다. **대용량**이라는 절대 무적의 메리트를 쉽게 포기할 수는 없다. 갖가지 수명연장 대책이 나오지만 여기서는 그 일부만 소개하겠다.

## 웨어레벨링

> Wear-Leveling

각 셀의 산화막의 수명은 대부분 비슷하다. 이런 상황에서 특정 셀만 집중적으로 사용하면 그 셀의 산화막만 집중적으로 손상받게 되고, 그 셀만 먼저 수명을 다할것이다.

이러면 전체용량이 감소되는 것이기 때문에 달갑지 않다. 이런 사태를 예방하는 것이 **웨어레벨링**이다.

쉽게말하면, **각 셀을 골고루 사용해서 전체 셀의 수명을 일정하게 관리**해주는 것이다. 전체적인 수명을 최대로 사용할 수 있는 것!

## ECC

> Error Check and Correct : 에러 수정 기능

`Controller`의 에러 수정 기능을 강화한다.

공정이 작거나 `TLC`인 경우 같이 수명이 짧을 수록 더 높은 정밀도의 `ECC`가 필요해진다.

현재는 `16~24bit ECC`를 사용하는 것으로 알려져있다.

![image-20200814150032343](https://user-images.githubusercontent.com/58545240/90222235-a37a4e00-de46-11ea-836d-f6d2c2b6b685.png)

![image-20200814150042337](https://user-images.githubusercontent.com/58545240/90222242-a8d79880-de46-11ea-90dc-26b09e01ed66.png)

## 디지털신호처리

> DSP

기록전압에 따라 전자저장량이 달라지는 걸 감지해서 각 신호별 기록전압을 셀 상태에 맞춰 변화시켜주는 것이다.

산화막 손상으로 이전보다 전자가 더 많이 저장되면 기록전압을 낮춰서 저장되는 전자수를 줄여서 원래 수준으로 맞추는 식으로 쓰기/지우기 전압을 변화시킨다.

![image-20200814150144608](https://user-images.githubusercontent.com/58545240/90222264-b2f99700-de46-11ea-991b-9d5f60fc3f00.png)

## 오버 프로비저닝

> Over Provisioning

이 방법은 셀의 수명연장이라기보다 **제품의 수명연장**이라고 할 수 있다.

위의 방식들을 사용한다 해도 결국 메모리셀의 사망을 피할 수는 없다.

**`Over Provisioning`은 여분의 메모리셀을 확보해놓고 사망하는 셀을 대체**하는 기술이다.

예비용량을 확보해뒀다가 수명이 다해서 `Bad-Block`이 발생한 셀이 나타나면 예비 셀로 대체해서 전체 용량을 일정하게 유지하는 것이다.





# AMBA_NAND

## > Amba_NAND_Def.h

## > AmbaNAND_F59L2G81A.c