# **VoIP**

---

> **Voice over Internet Protocol**
>
> **IP네트워크를 활용하여 음성을 데이터 패킷으로 변환해서 통화를 가능하게 하는 통신 서비스 기술**

**VoIP**는 IP를 사용하여 음성전보를 전달하는 일련의 설비들을 위한 IP 전화기술을 지칭하는 용어이다. 일반적으로, 이것은 공중교환전화망인 PSTN 처럼 회선에 근거한 전통적인 프로토콜들이 아니라, 불연속적인 패킷들 내에 디지털 형태로 음성정보를 보낸다는 것을 의미한다.

**VoIP**와 인터넷 전화기술의 주요장점은 기존 IP네트웍을 그대로 활용해 전화서비스를 통합 구현함으로써 전화 사용자들이 시내전화 요금만으로 인터넷, 인트라넷 환경에서 시외 및 국제전화 서비스를 받을 수 있게 된다는 점이다.

**VoIP**는 공중 인터넷 또는 기업 내부의 인트라넷 상에서 IP를 이용해 음성(소리)와 비디오를 전송하기 위한 표준인 ITU-T H.323의 사용을 장려하기 위해, **VoIP**포럼을 통해 시스코, 보컬텍, 3Com, 넷스피크 등 주요 장비제작회사들이 노력함으로써 이루어졌다. **VoIP**포럼은 또한 디렉토리 서비스 표준을 장려함으로써, 사용자들이 다른 사용자들의 위치를 찾아낼 수 있고, 자동 전화분배와 음성메일을 위한 터치폰 신호의 사용을 가능하게 하였다.

**VoIP**는 원래의 IP기능에 더하여, 패킷들이 적시에 도착하도록 지원하기 위해 **RTP**를 사용한다. 공중 네트웍을 사용하려면, 현재 서비스 품질(QoS)을 보장하기에 어렵다. 

독자적인 기업이나, 인터넷 전화서비스 공급자(ITSP)에 의해 관리되는 사설 네트웍을 사용하면 더 나은 서비스가 가능하다. 빠른 패킷 전달을 보장하기 위해 넷스피크라는 장비제작자에 의해 사용되는 기술은, 상태편과 `TCP` 소켓접속을 확립하기 전에 공중 네트웍에 접속되어 있는 모든 네트웍 게이트웨이에 핑을 해서, 그 결과를 토대로 가장 빠른 경로를 선택하는 것이다.

## :black_nib: ​VoIP 특징

- 패킷망 사용으로 이용요금이 저렴하다.
- 멀티미디어를 통합함으로 영상통화, 메시징 등 다양한 기술 구현이 가능하다.
- 통합망을 구성함으로써 회신 교환망보다 효율적인 망 관리가 가능하다.
- 기존에 구축된 인터넷 장비(Router, Switch) 등을 활용함으로써 구축비용이 상대적으로 저렴하다.
- 신규 서비스 개발과 수요 창출에 따른 새로운 수익 창출이 가능하다.

저렴한 요금이나 다양한 서비스로 유선통신을 주도할 `All IP`, `BcN`, `NGN`, `NGcN` 등에서 활용될 것이다.

실제로 070 전화와 같은 인터넷 전화로의 활용은 시장에서 자리를 잡았다.

아직 PC 기반이나 스마트폰과 같은 모바일 기반의 **VoIP**시장의 확산은 좀 기다려 봐야겠지만, FMC 등의 등장으로 기대해볼만 하다.

## :black_nib: ​VoIP 구현 기술

`VoIP`를 구현하기 위한 기본 기술들을 살펴보자.

- **`H.323`** : ITU-T에서 제정한 음성, 데이터, 비디오 통신 규약으로 음성 위주로 지원을 하고 있다. SIP의 등장과 함께 현재는 성장세가 둔화되고 있다.
- **`SIP`** : IETF에서 제정한 멀티미디어 통신규약으로 멀티미디어 장점을 보유하고 있고 현재 급속히 성장하고 있다. 통화와 같은 실시간 통신을 위해서 내부적으로 `RTP`라는 프로토콜을 사용한다.
- **`MGCP(Media Gateway Control Protocol)`** : 중계를 위한 게이트웨이 기술로 일부 통신 사업자들이 사용중이다. 실제 통화를 중계하는 프로토콜
- **`megaco(MEdia GAteway COntrol)`** : MGCP와 같은 중계를 위한 게이트 웨이 기술로 ITU-T/IETF의 공통 표준화 작업으로 만들었다.

## :black_nib: ​Mobile VoIP

인터넷 전화와 같은 서비스는 유선환경에서 연결하는 **`VoIP`**라 할 수 있다.

**`VoIP`**의 단말이나 네트워크의 발전을 살펴보면 결국에는 모바일 환경으로 이동할 것이라고 많은 전문가들이 예측하고 있다.

- **`VoIP `** 지원 단말 : PC > 전용 IP폰 > 일반전화 > 휴대폰/휴대용기기
- **`VoIP`** 네트워크 : PSTN > IP Network > 이동통신망

그렇다면 모바일 **`VoIP`**는 기존의 유선(Fixed) **`VoIP`**와 어떤 차이가 있을까?



유선 **`VoIP`**는 초고속 인터넷망을 기반 인프라로 활용하는데 반해, 

모바일 **`VoIP`**는 모바일 브로드밴드망인 무선랜(Wi-fi 등), WiBRO(WiMAX), 이동통신의 3G망이 사용된다는 것이다.



모바일 **`VoIP`**의 구성형태는 다음과 같다.

- **반이중 방식 `VoIP`(Half-duplex VoIP)**

  - PTT(Push To Talk)가 대표적이다.

  - Half Duplex이므로 한 쪽 방향으로만 전송이 가능하도록 구현된 통신기술이다.

- **이동전화 망연동 `VoIP`(Cellular bypass VoIP)**

  - 뉴스에 많이 나오는 FMC를 생각하면 된다.
  - 홈존 VoIP와 핫스팟 VoIP로 나뉜다
  - *홈존 VoIP*
    - 홈존(Home Zone) 내에서는 패킷망을 통해 유선전화 수준의 요금을 제공하고, 밖에서는 일반적인 이동통신 서비스를 제공하는 일종의 FMC(Fixed Mobile Convergaence) 서비스
  - *핫스팟 VoIP*
    - 핫스팟(Hot Spot) 지역에서는 무선랜 망을 이용하여 VoIP서비스를 제공하고, 핫스팟을 벗어나면 이동전화망을 이용해서 서비스를 제공

  => 둘의 차이는 패킷망을 통한 **`VoIP`**서비스를 어느 지역에서만 허용할 것인지에 따라 다르다.

  - *셀룰러망 이용 VoIP*
    - WCDMA, HSDPA, EVDO와 같은 3G 이통망 또는 WiMAX와 같은 데이터전용 브로드밴드망을 활용해서 음성통화를 구현하는 것으로 최근 이슈화되고 있다. IMT-Advanced 등 4G 통신망으로 업그레이드 되고 `All IP`가 구현되어 음성과 데이터의 융합, 통신과 방송의 융합, 유선과 무선의 융합이 가속화 될 경우 이런 형태의 서비스가 **`VoIP`**의 구현과 확산에 기여할 것으로 예상된다.

# **SIP ver.1**

---

> **Session Initiation Protocol**
>
> **멀티미디어 통신에 있어 세션이나 호(Call)을 관리하는 프로토콜**

멀티미디어 데이터 전송 자체보다는 Signaling을 통한 멀티미디어 통신 관리에 중점을 두고 있다.

다시 말해, 멀티미디어 데이터 전송은 실시간 전송을 기반으로 하는 **`RTP`**가 담당하고 **`SIP`**는 어플리케이션 레벨의 프로토콜

다음은 실제 **`SIP`**의 프로토콜 스택이다.

![image-20200902165853155](https://user-images.githubusercontent.com/58545240/91962888-1bea7580-ed48-11ea-8e14-9d5db40b6e76.png)

- `SIP` (RFC 3261) : SIP 기본 내용 정의
- `SDP` (Session Description Protocol, RFC 4566/3264) : 멀티미디어 세션 파라미터 설정
- `Audio Codec` (G.711A, G.723.1, G.729A) : 음성 코딩 담당, 다양한 시스템과 호환을 위해 여러 규격 존재
- `Video Codec` (H.263, MPEG-4, H.264) : 비디오 코딩, H.263이 공통으로 사용되며 H.264는 최신 버전
- `RTP/RTCP` (Realtime Transport (Control) Protocol, RFC 3550/3551) : 실시간 통신

## :black_nib: ​SIP 특징

- **`SIP`**는 패킷 교환망에서 회선교환망 방식의 제어가 가능하도록 세션을 제어한다.
- 패킷망의 인터넷 상에서 멀티미디어 어플리케이션이 가능하게 한다.
- URL 및 E-Mail형식의 텍스트 기반 어드레싱 방법을 사용하므로 메시지 파싱이나 확장이 용이하다.

일반적으로 SIP는 기존의 비슷한 기능을 제공했던 `H.323`와 많이 비교하고 있다. 살펴보도록 하자.

![image-20200902170400049](https://user-images.githubusercontent.com/58545240/91962905-20169300-ed48-11ea-8b69-73ebeba8f1ad.png)

초기 `H.323`에서 현재는 **`SIP`**기반의 단말이 많이 늘어나고 있는 추세이다.

## :black_nib: ​SIP 구성요소

**`SIP`**시스템의 구성요소는 SIP 클라이언트와 SIP 서버로 나누어 볼 수 있다.

- SIP 클라이언트

  - UAC(User Agent Client) :  세션 종단에위치하며 호를 생성하고 설정을 요청한다.
  - UAS(User Agent Server) : UAC로부터 호를 수락하거나 거절 또는 Redirect한다.

- SIP 서버

  *UA간 직접 호출이 가능하지만 SIP 서버를 둠으로 확장성을 제공한다.*

  - Proxy Server : UAC로부터 SIP콜을 받아 자신이 콜을 대신 만들어 주는 역할을 한다.
  - Register Server : 사용자의 에이전트로부터 레지스터 요청을 수신하여 사용자의 위치 정보를 유지한다.
  - Redirect Server : 사용자가 직접 요청할 수 있는 상대방의 URL을 알려준다.
  - Location Server : Proxy Server나 Redirect Server로부터 SIP 콜의 목적지 노드의 주소가 요청되면 이를 Resolution 해주는 역할을 한다.

  이들 간의 상호관계는 다음 그림과 같다

![image-20200902171256322](https://user-images.githubusercontent.com/58545240/91962918-23aa1a00-ed48-11ea-9508-9e464a3a17a6.png)

## :black_nib: ​SIP 메시지

실제 SIP의 요청 메시지를 보면 다음과 같은 형태로 되어 있다.

![image-20200902171354114](https://user-images.githubusercontent.com/58545240/91962934-286ece00-ed48-11ea-9145-6aba1dde00e4.png)

**INVITE** 메시지가 전송되는 것을 알 수 있다.

**INVITE**나 **From**에 보면  이메일 형태의 어드레스가 사용됨을 알 수 있다.

또한 **Content-type**을 보면 `application/sdp`로 되어 있어 SIP의 body에는 SDP(Session Description Protocol)이 사용된다는 것을 알 수 있다.

SDP가 적용된 body를 보면 `RTP/AVP`와 같은 미디어의 형태를 표현하고 있다.

Proxy나 Redirect가 없는 가장 기본적인 형태의 흐름은 다음과 같다.

![image-20200902171603704](https://user-images.githubusercontent.com/58545240/91962946-2c025500-ed48-11ea-99c8-f07ee7774336.png)

# **SIP ver.2**

---

> **`VoIP` 또는 멀티미디어 통신용 신호 프로토콜**
>
> **1 이상의 양방향 멀티미디어 세션/호를 설정, 변경, 해제**



## :black_nib: 세션

> 1. 네트워크 상에서 양 종단간 일회용 논리적 연결
>
>    ex) SVC 가상회선, TCP 세션 등
>
> 2. 컴퓨터(멀티 사용자 시스템) 상에서, 하니 사용자가 로그인 후부터 로그아웃할 때 까지의 경과
>
>    -> 이 경우 사용 이력 기록을 로그(Log)라고 함

- **세션 계층(Session Layer)**

  -  OSI 7계층 모델의 5계층에 해당
    - 종단 호스트 프로세스 간에 세션을 생성, 유지, 종료하는데  필요한 여러 기능을 제공

- **세션 설정 프로토콜**

  - 세션의 설정, 변경, 해제와 관련된 프로토콜

    ex) SIP, SDP 등

- **세션 키(Session Key)**

  - 하나의 논리적 연결 세션 동안 만 유효한 암호 키



### > 세션계층의 주요 기능

- **접속 설정 및 해제**
  - 세션을 설정 및 해제하는 기능
- **다중화**
  - 여러 세션들이 효율을 높이기 위해 1개의 같은 **전송계층** 접속을 사용할 수 있음
    - 단대로 1개 세션이 속도 등을 위해 다수의 전송계층 접속들을 사용할 수도 있음
  - 따라서 전송 계층에서와 같이 세션 계층에서도 상향, 하향 다중화가 가능
- **데이터 교환**
  - OSI는 데이터를 4가지 범주로 구분한 바 있음
    - 정보 데이터, 급송 데이터, 제어데이터, 세션 파라미터 협상에 사용되는 데이터
- **대화 관리**
  - 세션계층은, **토큰**을 사용함으로써 대화(dialogue)를 관리
  - 성립된 세션을 통한 상호 대화 관리를 하는 양단간 응용 개체를 위해 **토큰**개념이 정의
    - 누가 언제 통신하였는지를 결정하며 **토큰**을 교환함으로써 구현
    - 프로세스는 토큰을 가졌을 때 전송할 수 있음
  - **토큰**은 어떤 서비스의 실행을 기동하는 권리를 표현하는 것
- **에러 복구**
  - 세션계층은 전송시 동기점을 삽입함으로써 메세지를 대화 단위로 그룹화 함
    - 에러 발생하면 중단된 대화 단위의 처음부터 전송을 다시 시작



## :black_nib: 호(Call)

> **전화교환망에서 개개의 통신이 통신설비를 일시적으로 점유하는 것**
>
> ​	=> 사용자가 통화를 목적으로 통신회선 또는 설비를 점유하는 사상



## :black_nib: 라우팅(Routing)

> **네트워크 상에서 주소를 이용, 목적지까지 경로를 체계적으로 결정하는 경로선택 과정**
>
> ​	=> 네트워크를 효율적으로 이용하여 양종단 노드 간에 경로 찾기

**1. 라우팅 방식의 일반적 구분**

- **라우팅 방식의 주요 구분**
  - 고정 라우팅(Fixed Routing) / 정적 라우팅(Static Routing)
    - 미리 정해진 루트를 따라 경로 선택 (수동 경로 설정)
  - 동적 라우팅(Dynamic Routing) / 적등적 라우팅(Adaptive Routing)
    - 망의 상테에 따라 경로 선택 (자동 경로 설정)
- **네트워크 정보를 이용하지 않는 라우팅 방식**
  - 홍수 라우팅(Fllod Routing) / 플러딩(Flooding)
    - 수신 경로 이외의 모든 경로로 전파하는 매우 간단한 경로선택 방식
  - 랜덤 라우팅(Random Routing)
    - 무작위로 경로 선택 방식
- **기타 구분**
  - 소스 라우팅(Source Routing)
    - 경로를 모두 리스트로 만들어 패킷의 헤더에 넣어 보내는 경로선택 방식
  - 계층적 라우팅(Heararchical Routing)
    - 큰 그룹에서 점차 작은 그룹으로 계층적 경로선택 방식



**2. [패킷교환망(인터넷)] 라우팅**

- **데이터통신망에서 라우팅**

  - 패킷 내 목적지 주소를 이용, 목적지까지 메세지(패킷 등)을 체계적으로 전달하는 경로선택 과정

    (이 과정을 능동적으로 수행하는 장치 -> *Router(라우터)*)

- **라우팅 정보 (라우팅 결정에 이용하는 주요 정보)**

  - 목적지주소
    - 토폴로지
    - 트래픽 부하
    - 링크 비용(라우팅 메트릭) : 홉수, 비용, 지연, 처리율 등

- **라우팅 알고리즘**

  - 거리벡터 알고리즘 (속도나 거리 지연등을 고려하지 않아 최적의 경로 산정에 비효율적)
  - 링크상태 알고리즘 (최소비용 기준 알고리즘)

- **라우팅 프로토콜**

  - 자치시스템 내부에서의 라우팅 : *`RIP, OSPF, IGRP` 등*
  - 자치시스템 외부(상호) 간의 라우팅 : *`EGP, BGP` 등*

- **라우팅(경로결정) 우선순위**

  - 동일 목적지로 가능 경로가 단일이 아니고 다수개로 계산되었을 때,
    - 동일 라우팅 프로토콜에서는 **라우팅 메트릭**이 가장 낮은 것을 우선으로 함
    - 다른 라우팅 프로토콜 간에는 **관리거리** 값이 낮은 것을 우선으로 함.



**3. [회선교환망(PSTN)] 라우팅(중계방식)**

- **회선 교환망**에서의 경로 배정(루팅)
  - 전화번호에 따라 발신국에서 착신국까지 호가 연결되는 경로선택 방식
    - 이 과정에 참여하는 주된 장치 : *교환기(Switching System)*
    - 교환기 간에 연결된 회선군 : *교환선군(Route)*
- **루팅 구분**
  - 직접루팅
  - 우회루팅

**PSTN(Public Swtiched Telephone Network)**이란 KT(한국 통신)가 설치한 전화 통신망을 말한다. 즉, 시내전화/시외전화/국제전화 등을 할 수 있도록 전화케이블을 전국에 설치한 망을 말한다.

**PSTN**은 실시간 음성 통신을 위해 최적화 되어 있다. 누군가가 전화를 걸면 스위치가 닫히게 되고, 다른 대상에 회로가 설정된다.

**PSTN**은 전화를 끊을 때까지 회선을 호출해 전용시킴으로써 QoS(서비스 품질)를 보장한다. 사용자나 상대방이 말을 하거나 가많이 있거나 관계없이 전화를 끊을 때까지 같은 회로를 계속 사용하게 된다.

이렇게 전용하는 방식을 사용하기 때문에, 한 지역에 전화가 많이 몰리면 통화중이라는 현상이 발생하게 된다. 즉, 그쪽 지역으로 전화를 걸 수 없는 상황이 발생!



이와는 달리 인터넷망은 **패킷망**이다.

**패킷망**은 회선을 전용하는 게 아니라, 그때 그때 필요한 사람끼리 나눠쓰는 구조이다. 여러명이 접속할 수 있지만, 점점 느려지는 현상이 발생한다.

그래서 동영상을 실시간으로 볼 때는 동영상 플레이어가 이런현상을 가미해서, 버퍼링이라는 것을 해두는 것이다. 미리미리 수십초앞의 데이터를 받아두고 플레이를 시켜두는 것! => 그래야 혹시 네트웍이 불안하거나 다른 트래픽이 몰리더라도 동영상 플레이가 끊기지 않게 되기 때문이다!

+

*공중전화망은 거의 대부분 고정적(정적) 또는 계층적 라우팅 방식*

​	=> 본래 공중전화망은 교환기 간에 연결된 직통회선에 여유회선이 없을 때 이미 점유된 경로와는 또다른 경로로 우회하며, 호 연결을 시키는 `고정 경로제어 방식`을 사용하여 왔다. (종단간에 이어진 회선의 원활한 연결접속에 주안점을 둠)



## :black_nib: 홉(Hop)

> **홉이란 영어 뜻 자체로는 건너뛰는 모습을 의미**
>
> **데이터통신망에서 각 패킷이 매 노드(또는 라우터)를 건너가는 양상을 비유적으로 표현**
>
> ​	=> 이러한 체계를 `hop-by-hop` 체제라고 한다.

1. **다음 홉(Next Hop)**

   - 목적지 네트워크까지 가기위한 바로 다음의 라우터를 말함
   - 각 노드(라우터)는
     - 수신된 패킷의 헤더부분에 있는 주소를 조사하여,
     - 라우팅 테이블에 있는 최적 경로 상에 있는 다음 홉 라우터 인터페이스를 찾아내어
     - 수신 패킷을 당므으로 `Hop`할 라우터를 향하는 그 인터페이스에게 넘겨 전달함

2. **홉 수 (Hop Count)**

   - 거치게 되는 라우터 수
   - `RIP` 라우팅 프로토콜의 경우 최대 홉 수 : *15개* (16은 무한대를 의미)

3. **홉 한계/제한 (Hop Limit 또는 `TTL`)**

   - `IP` 헤더 내에서 `8비트`로 그 값을 나타냄

     - 헤더 내 필드 명칭 : `TTL(IPv4)` 또는 `Hop Limit(IPv6)`
     - 최대 홉 값 = 2<sup>8</sup> - 1 = *255*
     - 권장 기본값 = *64*

   - 멀티캐스트 패킷의 경우

     - RIPv2, OSPF에서 이웃라우터를 넘어서 멀티캐스트 패킷을 전달되지 못하도록 함

       => 즉, `TTL(IPv4)` 또는 `Hop Limit(IPv6)` = 1

   - 한편, `IPv6`에서 `Hop Limit = 255`(가장 큰 수)는 특별한 의미를 갖는다

     - 보안성 강화를 위해, 라우터가 이 값의 패킷을 아예 라우팅 처리하지 않음. 즉, 무시함

       => 즉, Local Link 영역 내에서만 통용됨

     - ICMPv6 NDP 메시지(5 종류)에 이 값(255)이 쓰여짐

       => 이 값으로 쓰여지지 않는 NDP 메시지들은 무시되어짐

     - RCP 5082



## :black_nib: SIP의 특징

- **VoIP 표준**
  - ITU-T H.323과 대응되는 IETF의 신호 프로토콜
    - `H.323`이 과거 인터넷폰에 대한 사실상의 표준이었으나, 지금은 `SIP`가 우세함
    - ITU-T가 IETF SIP 표준화 작업에 참여함으로써, 사실상 `SIP`로 단일화 됨
- **H.323에 비하면 매우 단순하여, 호 설정이 간단**
  - `파싱(parsing)` 및 `컴파일(Compile)`이 쉬워 확장 및 구현이 용이
- **호의 설정, 변경, 종료를 위한 일종의 시그널링 기술**
  - 호의 경로 배정을 목적으로 `Redirect` 및 `Proxy Server`에 의해 중계도 가능
  - 세션의 관리보다는 세션의 설정/변경/종료를 위한 프로토콜임
- **텍스트 기반(text-based)의 응용계층 프로토콜**
  - `HTTP` 및 `SMTP` 프로토콜에 바탕을 둔 요청-응답 텍스트 메시지
    - `HTTP` 클라이언트/서버 통신방법 및 `URL` 주소방식 등을 이용하여 구현 용이
  - `SMTP`의 텍스트 인코딩 방식 및 헤더 형태를 그대로 이용
- **클라이언트/서버 기반의 요청과 응답 구조로 동작**
  - 클라이언트(UAC)에서 서버(UAS)로의 호 설정 요청시 메소드를 이용
    - 메세지 구조가 헤더와 바디(본체)로 구성 (HTTP와 유사)
  - 서버(UAS)에서 클라이언트(UAC)로의 응답은 **숫자에 의한 상태코드**를 전달하게 됨
- **주소방식은 URL방식을 응용**
  - `E-Mail`과 유사한 형태의 주소를 이용해 사용자 식별
- **사용자 간에 실제 통화 내용을 전달하는(주고받는) 프로토콜로는,**
  - 호 설정 이후에, 실제 데이터 전달은 `RTP` 활용
  - 단, `SIP`자체를 활용하여 단순 테스트 전달도 가능
- **사용자 이동성(Personal Mobility) 제공**
  - `3GPP`의 `IMT-2000 VoIP` 규격으로 기확정



## :black_nib: SIP 프로토콜 계층

![image-20200903110314540](https://user-images.githubusercontent.com/58545240/92191914-d80a8400-ee9f-11ea-893b-bd1131f9476d.png)

- `SIP` 호 신호의 전달 프로토콜로는,
  - 전송계층 프로토콜 중에, `UDP`를 기본으로 사용하나, `TCP, SCTP, TLS` 등도 가능함
- 포트번호는 `UDP` 포트 **5060**을 기본으로 사용



## :black_nib: ​SIP 참고사항

### > SIP 구성요소

- **SIP 터미널**

  => 통화 세션 양단간 단말 소프트웨어/하드웨어 (호출 UAC <-> 피호출 UAS)

- **SIP 서버**

  => 세션 관리를 위한 일종의 중계 장치

### > SIP 에이전트

> **통상의 클라이언트/서버 구조와는 달리 SIP 단말은 세션 설정 역할에 따라, 클라이언트가 되기도 서버가 되기도 함.**

- **SIP UA**(User Agent, 유저에이전트)

  - IP 클라이언트(터미널, 단말)로써, 종단에 위치함

    - PC, 전화기, 사용자단말, 이종망 게이트웨이, 소프트스위치, IP-PBX 등 인터넷 호스트

      (인터넷호스트 : 표준 RFC 1121/1122에 부합하는 장치)

- **SIP UA 역할**

  - 다른 UA와 직접 단대단 연결을 설정하거나
  - SIP 서버(프록시/리다이렉트 서버)의 도움으로 다른 UA와의 연결 설정하는 등에의해,
  - 주로, 단말(UA)측에서 세션 상태를 저장 및 관리 하게 됨

- **SIP UA 간에 발신 및 수신 (클라이언트/서버 모델)** : (호출 UAC <-> 피호출 UAS)

  - 호출자/발신자 => `UAC` (User Agent Client)
    - 호를 생성, 호의 설정 요청을 함
  - 피호출/수신자 => `UAS`(User Agent Server)
    - 호를 수락 또는 거절 또는 `Redirect`

*`H.323` 터미널은 `TE`라고 하고, `SIP`터미널은 `UA`라고 칭한다.*

### > SIP 서버(중계장치)

- **SIP 서버들은 일종의 중계장치**

  - `UA`간에는 직접 호출/응답이 가능 하나, `SIP` 서버들은 오직 **시그널링**만을 전달
  - `UA`가 기능확장을 원한다면 `SIP` 서버들이 필요하다

- **서버 구분**

  - **Register Server** : *사용자 등록 기능*

    - 사용자 현재 위치의 등록, 수정, 삭제 및 현재 리스트를 보여주는 기능 수행
    - `SIP` 등록 요쳥을 받아, 해당 `UA` 정보를 등록/변경함

  - **Proxy Server** :  *호 접속 및 교환 중개(교환기와 유사)*

    - 호 요청을 받고 좀 더 자세한 사용자 위치정보 및 다양한 기능. 서버로 호를 넘겨줌.
    - 가상적인 `UAC/UAS` 역할 가능
      - `UA`를 대신해 요청을 만들고 접속을 수립하는 등
      - 수신 Proxy, 발신 Proxy, 영역 담당 Proxy 등으로 동작 가능

  - **Redirect Server**

    - 자체적으로는 접속을 만들어내지 못하나, 원래 요청을 재시도할 곳에 대한 정보로써 방향을 바꾸는 응답(redirection response 3xx)을 해줌

      (다른 영역으로 이동한 사용자의 현재 위치를 알려주는 등)

![image-20200903111556796](https://user-images.githubusercontent.com/58545240/92191923-dccf3800-ee9f-11ea-866f-83e04eed3295.png)

### > SIP 메세지

- **호 또는 세션의 제어(설정/변경/종료) 처리**를 위해

  - 크게 **요청(Request) 메세지** 및 **응답(Response) 메시지** 형태로 구성

- `SIP/TCP/IP`, `SIP/UDP/IP`, `SIP/SCTP/IP` 등과 같은 프로토콜 스택 상에서 전달됨

- **메시지구성**

  1. **시작 줄(start line)**

     - 요청 메시지 : `Method`, `Request URI`, `SIP Version`

       ex) `INVITE sip : userid@ktword.co.kr SIP/2.0`

     - 응답 메시지 : `SIP Version`, `응답상태코드`

       ex) `SIP/2.0 200 ok`

  2. **메시지 헤더(Message Header)**

     - 세션의 서비스, 주소, 프로토콜 등의 정보(To, from, Conatct, Cseq, Call-ID 등)

       ex) `Via: SIP/2.0/UDP 221.146.2.5:5060; branch=z93ksh52`

     - 여기서, 한 세션을 구분하는 단위로써, **세션 Dialog**라고 불리움

       - 한 세션 동안 무 변화하므로 갑작스런 단말 고장시에도 상대 단말이 이 정보를 유지함으로써 재 설정 가능

  3. **빈 줄(blank line)**

  4. **메시지 본체(Message body)**

     - `SDP`(Session Description Protocol)을 통해 세션정보를 기술하게 됨

- **메시지 구분**

  1. **Client -> Server 요청 메시지** : *메소드 이름으로 요청*

     - SIP Request는 기본 6가지의 **`메소드(Method)`**로 나뉨(`RFC 3261`)
       - `INVITE` : 세션 설정
       - `ACK` : 응답 확인 (`INVITE` 요청에 대한 최종응답 확인)
       - `BYE` : 세션 종료
       - `CANCEL` : 요청 취소 (세션 취소)
       - `REGISTER` : 서버에 등록 (사용자 URI 등록)
       - `OPTIONS` : 수신자 능력 질의
     - 확장 **`메소드(Method)`** => `INFO, PRACK, UPDATE, SUBSCRIBE, PUBLISH, REFER, NOTIFY` 등

  2. **Server -> Client 응답 메시지** : *1xx-6xx의 상태코드로 구분하여 응답*

     - SIP Response(응답 상태 코드)는 **숫자**로 표시됨 (일부는 `HTTP` 코드와 유사)

       - `1xx` : 정모메시지 (처리중)

         (`100 trying, 180 ringin, 181 call is being forwarded`)

       - `2xx` : 성공적인 호 응답 (완료)

       - `3xx` : Redirection 응답 (요청 대체)

       - `4xx` : Request Fail 응답 (클라이언트 오류)

       - `5xx` : Server Fail 응답 (서버 오류)

       - `6xx` : Global Fail 응답 (처리 실패)

### > SIP 호 처리절차

- **단말 간 직접 연결**

![image-20200903113132411](https://user-images.githubusercontent.com/58545240/92191931-e22c8280-ee9f-11ea-8bcb-a95b2e8711bf.png)

- **`SIP` 서버 경유 호처리**

![image-20200903113144406](https://user-images.githubusercontent.com/58545240/92191945-e8226380-ee9f-11ea-88d0-63c2143e0fe1.png)

## :black_nib: SIP 표준

- `RFC 2543` : *SIP(1999)*
  - IETF의 MMUSIC Working Group에서 작성
  - 이후 별도 `SIP WG`들이 구성되어 추가 표준 작업들이 진행
- `RFC 3261` : RFC 2543을 대체함

# **G.711**

> - **64 kbps PCM을 위한 '음성부호화' 표준**
>
>   => 음성부호화 중 음성파형부호화에 전형적임
>
> - **`G.711`은 `PSTN망(전화망)`에 적용되는 가장 기초적인 방식**
>
>   => 그냥 PCM(Pulse Code Modulation, 펄스부호변조) 방식이라고도 한다.



## :black_nib: G.711의 기술적 주요 특징

- **대역폭** : 300Hz ~ 3400Hz 대역의 음성 대역 신호

- **표본화 주파수** : 8kHz (125 us)

- **양자화 비트수** : 각 표본을 8비트로 부호화

- **양자화 방식** : 비선형 양자화 (Companding 방식)

  => `mu-Law(u-Law)` 또는 `A-Law` 모두 사용 가능

- **전송 비트율** : 8000 [표본/초] x 8 [비트] = **`64kbps`**

- **통화품질** : MOS(Mean Opinion Score)



## :black_nib: 다른 G 코덱과의 비교

| **코덱 종류** | **알고리즘(압축방식)** | **속도 Bit rate(BW)** | **encoding time** | **MOS**  | **설명**                           |
| ------------- | ---------------------- | --------------------- | ----------------- | -------- | ---------------------------------- |
| G.711         | PCM                    | 64 Kbps               | 10 ms             | 4.1      | PSTN 통화 품질                     |
| G.726         | ADPCM                  | 16K, 24K, 32K         | 10 ms             | 3.85     | BW 크면 품질 좋음                  |
| G.722         | SB-ADPCM               | 64 Kbps               |                   |          | 멀티미디어 음성 회의. AM 방송 품질 |
| G.723         | MLQ                    | 6.3 Kbps 5.3 Kbps     | 30 ms             | 3.9      | MS 넷미팅 기본 코덱                |
| G.723.1       | MPC-MLQ ACELP          | 6.3 Kbps 5.3 Kbps     | 37.5 ms           | 3.9 3.61 | 이동통신                           |
| G.728         | LD-CELP                | 16 Kbps               | 15 ms             | 3.61     | 디지털 이동 통신                   |
| G.729         | CS-ACELP               | 8 Kbps                | 10 ms             | 3.9      | VoIP 에서 가장 보편적인 코덱       |



#  **PCM**

---

> **Pulse Code Modulation, 펄스 부호 변조**
>
> - **최초로 실용화된 '음성의 디지털 부호화' 및 '다중화 전송' 방식**
>
>   => 일반적으로, 최초 입력단에 `ADC`, 최종 출력단에 `DAC`를 갖는다

## :black_nib: PCM 방식 주요 특징

1. **아날로그 음성신호의 디지털화**
   - PCM 방식의 이론적 근거 : 기본적으로 **샘플링 이론(Sampling Theroy)**에 근거
   - 아날로그에서 디지털로 변환 -> A/D 컨버터 참조
2. **음성 부호화**
   - 최초의 국제 표준 음성 부호화 방식(G.711) 구현
3. **시분할다중화(TDM Multiplexing)**
   - 다중화 방식 표준 : T1방식(북미 표준) 및 E1방식(유럽 표준)



## :black_nib: PCM 디지털화 과정

> **표본화(Sampling) > 양자화(Quantizing) > 부호화(Coding)**
>
> - 음성신호에 대해 초당 8천번을(125`us`마다) 표본화
> - 이러한 속도는 `4kHz` 대역폭을 갖는 채널로도 충분히 재생 가능함
> - 초당 8천개 표본을 **8비트 양자화**하면 `64kbps`임

![image-20200904100318954](https://user-images.githubusercontent.com/58545240/92191964-f1133500-ee9f-11ea-8119-9787add26cd0.png)



## :black_nib: PCM 방식에 의한 음성 부호화

- **PCM은 사상 처음으로 널리 사용되기 시작한 국제 표준 음성 부호화기**

  - 1972년 표준화 ( 64 kbps PCM ) -> `G.711`
  - 이 방식은 지금까지도 많은 디지털 시스템에 사용되고 있으며 특히 우리가 사용하고 있는 일반전화에서 바로 이 방식이 이용되고 있음

- 한편, 1984년에는 `32kbps` `ADPCM`이 국제 규격으로 채택

  - 이는 `64kbps` `PCM`에 비해 전송률을 반으로 낮춘 부호화기로 저전성률 음질부호화기의 음질평가의 기준으로 많이 사용됨

    (장거리 국제전화에 가장 보편적으로 사용되는 표준 코딩 방식)



## :black_nib: PCM 다중화

- 시분할다중화의 최초 구현
- PCM 다중화 단계별 표준

![image-20200904100523334](https://user-images.githubusercontent.com/58545240/92191975-f7a1ac80-ee9f-11ea-9c74-be075ffe23cc.png)



## :black_nib: 샘플링 이론

> **Sampling Theory**

1. **표본화 정리**

   - 원 신호가 대역제한되어 있다고 가정하면,

     - 원 신호 대역폭의 2배 이상으로 표본화하면 원 신호를 완전히 재생할 수 있다는 정리

       (원래 정보의 2배 잉상의 속도로 표본화하면, 그 표본치들 만으로도 원래 정보가 충분히 재생 가능)

   *=> A/D변환시 또는 `PCM`화때 가장 중요한 정리/이론*

2. **'신호의 표본화' 및 '원 신호의 재구성'**

   - 시간표본화에 따른 주파수 스펙트럼

     => 신호를 샘플링하면, 신호 스펙트럼이 샘플링 주파수 간격으로 반복되어 나타남

   ![image-20200904104510822](https://user-images.githubusercontent.com/58545240/92191983-fcfef700-ee9f-11ea-936d-20e3a54856c9.png)

   - 재생가능하려면
     - 원 신호의 최대 주파수(`fm`)의 2배 이상으로 표본화(`fs`)하여 송신하면, 수신측에서는 표본추출된 신호로부터 원신호를 정확하게 재생가능
     - 즉, `fs >= 2fm` ( `fs` : Nyquist 표본화 주파수)
   - 결국, 원 신호의 재구성은
     - 어떤 신호가 신호원의 최고 주파수 보다 두 배 이상의 속도의 균일한 시간 간격으로 얻어진 데이터는 원래의 신호가 모든 정보를 포함하며,
     - 이렇게 얻어진 데이터는 **저역통과필터(Low Pass Filter)**를 사용하여 재구성 가능

3. **표본화 정리의 실제 환경 하 고려할 사항**

   - 원래 신호가 대역제한 되었다는 가정
     - 표본화 정리는 원래의 아날로그 신호가 대역제한 되어 있다고 가정하나,
     - 실제의 신호는 시간 제한적이며, 대역 제한되지 않은 신호이다 (유한 대역폭 조건)
     - 따라서, 실제 신호를 표본화하면 신호 스펙트럼이 중첩된다.
   - 표본화 신호의 복원시 이상적인 **저역통과필터** 사용을 가정
     - 원래의 신호를 복원할 때에 사용하는 필터가 이상적인 저역통과필터여야하나, 이를 실제로 구현할 수 없음

   *=> 결국, 현실적으로 에일리어싱 발생*



## :black_nib: TDM

> **Time Division Multiplexing, 시분할 다중화**
>
> **시간분할된 여러 사용자 타임슬롯을 하나로 결합시키는 다중화 방식**

![image-20200904105236976](https://user-images.githubusercontent.com/58545240/92191992-038d6e80-eea0-11ea-942d-4830d94bc974.png)

**> TDM 방식 구분**

- **프레임 내 사용자 채널 할당 방식에 따른 구분**

  - **`STDM`(동기식 시분할다중화)** 또는 **비 통계적 시분할 다중화**

    - 각 사용자 채널(타임슬롯)에서 데이터가 있건 없건 간에 프레임 내 해당 사용자 채널이 항상 점유됨

    ![image-20200904105649547](https://user-images.githubusercontent.com/58545240/92192018-1142f400-eea0-11ea-9d7f-8e9148e283f5.png)

    - 프레임 동기 필요
    - 순서에 따라 목적지 구분이 용이

  - **`ATDM`(비동기식 시분할다중화)** 또는 **통계적 시분할다중화**

    - 각 사용자 채널에서 데이터가 있을때만 프레임에 삽입되어짐

    ![image-20200904105803822](https://user-images.githubusercontent.com/58545240/92192025-14d67b00-eea0-11ea-93aa-3ba763f34275.png)

    - 프레임 동기 불필요
    - 각 타임슬롯에는 반드시 목적지 구분을 위한 주소가 필요함

- **동기 클럭 관점에 따른 구분**

  - **비동기식 다중화**(Plesichronous Multiplexing)

    - 개별 자체 클럭원에 의해 하위 계위신호들을 상위 계위신호로 다중화

      => 비트스터핑에 의한 비트 간의 동기를 일치시키며 다중화 처리함

  - **동기식 다중화**(Synchronous Multiplexing)

    - 하나의 기준된 단일 동기 클럭원에 의해 하위 계위신호가 상위 계위신호로 다중화



**> FDM(주파수축), TDM(시간축), WDM(파장별) 비교**

- **FDM(주파수분할다중화)** : 주파수축에서 다중화

- **TDM(시간분할다중화)** : 시간축에서 다중화

  => PDH(T1, E1 등) / SDH / SONET 등은 `TDM`방식에 기반을 둔 전송기술

- **WDM(파장분할다중화)** : FDM 방식의 일종

![image-20200904110204982](https://user-images.githubusercontent.com/58545240/92192036-1acc5c00-eea0-11ea-952a-d75da611c61b.png)



# **IP PBX**

---

## :black_nib: PBX란?

> Private Branch Exchange

PBX, EPABX는 사설 전화 교환기 인데, 기업용 서비스에 특화가 되어 있는 장비이다.

PBX는 기업에 필요한 다양한 기능들을 가지고 있어, 기업에서 전화를 이용해 빠르고 편하게 통신을 할 수 있께 해주는 장비이다.

*하지만 예전부터 PBX가 지금의 것처럼 좋았던 것은 아닙니다. 
예전에는 전화국의 교환원이 전화코드를 통화를 원하는 사람끼리 연결 해주던 시절이 있었습니다. 
전화를 걸고자 하는 사람은 전화기에 달려있는 발전기를 돌려서 신호를 보내면 전화국의 교환원이 받게됩니다. 
전화를 받은 교환원은 전화받을 사람을 물어보고 수동으로 연결해 주는 방식이었습니다. 
이런 방식은 아직 우리군의 야전용으로 많이 사용되고 있습니다.*

![image-20200915135743419](https://user-images.githubusercontent.com/58545240/93182670-efd1ea00-f774-11ea-814f-2139511665b0.png)

하지만 **PABX** 즉, 전자식 전화교환기는 이런 교환원들의 일자리를 싹 빼았아 버렸다. 전화번호 설정만 미리 해놓으면 사람들이 누르는 전화번호를 입력받아서 자동으로 연결해주는 전자식 전화 교환기가 탄생!

PABX는 TDM(Time-division multiplexing)방식의 자동 전화 교환기 이다. **PBX**는 TDM 백플레인을 가지고 있으며, 각 카드는 백플레인에 연결 되어서 호처리, 가입자 수용, 부가기능 수행, 음성 사서함, Ringback tone 등의 다양한 기능을 수행한다. 

**PBX**에 연결된 전화기들은 ISDN규격에 따라 신호를 주고 받으며, 송신측과 수신측이 서로 다른 주파수 대역을 사용하여 통화하게 된다.

PBX가 놓여져 있는 곳에는 MDF(Main Distributing Frame)라고 불리는, 선이 어지럽게 연결되 있는 일명 "짬빠" 작업을 하는 곳이 있다. PBX에 연결된 Telco Cable을 가입자의 전화 포트 아울렛으로 분배해주는 곳이다. 이렇게 작업이 된 케이블들은 PABX로부터 출발해 사무실의 각 자리로 들어가게 되고 사람들은 2가닥의 전화선을 `RJ-11`이라는 투명한 잭으로 만들어져 전화와 연결하게 된다. 즉 각 전화기들은 모두 **PBX**에 직접 연결되어 통화를 하게 된다.

## :black_nib: IP PBX

> Internet Protocol Private Branch Exchange
>
> **An IP (Internet Protocol) PBX (Private branch exchange) is a business telephone system designed to deliver voice or video over a data network and interoperate with the normal Public Switched Telephone Network (PSTN)**
>
> ​	=> IP PBX는 비지니스 전화시스템이다. 데이타 네트워크를 통해 보이스와 비디오를 전달하도록 설계되어 있다. 그리고 PSTN과 연동도 되도록 설계돼어있다.

즉, **PBX**와 **IP PBX**는 같은 기능을 하는 전화교환기 이다. 다만 "짬빠"를 통해서 전화기가 연결되는 것이 아니라, IP Network 즉 여러분들이 인터넷을 사용하는 회선과 스위치에 **RJ-45**커넥터를 이용해서 전화가 연결된다. 또한 **Voice Gateway**를 통해서 **PSTN**과도 연결이 되어 집전화, 휴대폰으로도 전화가 가능하다.



**IP PBX**는 아래 그림과 같이 하드웨어는 서버이다. 일반적으로 사용되는 X86서버에 IP PBX소프트웨어를 설치해서 PBX로 동작하게 만든다. IP PBX도 마찬가지로 **RJ-45**커넥터를 통해서 스위치에 연결되고, 호처리, 가입자 수용, 부가서비스 등 PBX와 똑같은 역할을 한다. 

하지만 PBX와 같이 PSTN을 연결하는 기능흔 **Voice Gateway**에 일임을 하고 음성사서함과 같이 리소스가 많이 필요한 부가서비스도 별도의 서버로 독립시켜버렸다.

![image-20200915141238976](https://user-images.githubusercontent.com/58545240/93182688-f3657100-f774-11ea-864e-8ccef9a76147.png)

## :black_nib: IP PBX와 함께 IP TelePhony를 구성하는 요소

**IP TelePhony**는 기존의 PBX에서 카드형태로 제공되던 것을 분리시켜, 각각 역할을 수행하는 장비들이 모여 하나의 PBX처럼 동작을 합니다. 이는 각각의 장비가 한 곳에 모여 있을 필요가 없이 용도에 따라, 목적에 따라 별도의 장소에서 동작할 수도 있습니다.

### > Voice Gateway

Voice Gateway는 Trunk Gateway, Analog Gateway 등 규모와 용도에 따라서 다른 이름으로 불려지기도 하며, 통틀어서 Media Gateway라고도 불려집니다. **Media Gateway**라고 불려지는 이유는 서로 다른 Media 즉, PSTN과 IP Network를 중간에서 관문역할을 하기 때문이다. 즉, 전화국과 연결되는 E1/T1(ISDN Trunk), FSX/FXO(일반 전화선과 전화기 연결)과 IP TelePhony와 연결이 된다.

이 Voice Gateway를 통해서 IP Phone에서 IP Phone 뿐 아니라, 기존에 사용하던 집전화, 휴대폰 등으로 전화를 할 수 있도록 설계가 되었습니다.



하지만 아래의 Voice Gateway가 IP TelePhony를 처음 접하는 사람이어도 익숙한 분들이 계실겁니다. Voice Gateway는 Router에 Voice Module을 설치해서 Voice Gateway역할을 한다. 또한 이 Voice Gateway를 통해서 작은 규모 사무실에 적합한 소규모 PBX와 음성 사서함 모듈을 통한 소규모 음성사서함, 그리고 IP PBX와 연결되는 WAN의 장애 발생시에 비상 복구모드인 SRST(Suvival Remote Site Telephony)의 용도로도 사용이 가능하도록 설계가 되어 있다.

또한, 이 Voice Gateway는 기업용 SBC(Session Border Controller)인 CUBE(Cisco Unified Border Element)로도 사용이 가능하다.

![image-20200915155706882](https://user-images.githubusercontent.com/58545240/93182698-f6f8f800-f774-11ea-935e-e762a2d88122.png)<Cisco Integrated Services Router = Voice Gateway>

### > IP Phone

PBX를 **IP PBX**로 바꾸게 되면 당연히 전화기도 IP Phone으로 바꿔야 한다. 물론 IP PBX를 사용하더라도 Analog Gateway를 통해서 일반 전화기도 사용할 수 있습니다만. 일번전화도 Analog Gate를 통하게 되면 IP Phone과 같은 방식으로 동작하게 된다.

IP Phone은 아래 그림과 같이 일반적인 전화와 똑같이 생겼지만 IP Network에 연결이 되고, IP TelePhony를 위한 VoIP 프로토콜(H.323, SIP, Skinny 등)을 이용하여 IP PBX를 통해 Call Processing을 하게 되고, 통화로가 열리게 된다. IP Phone에서 음성 전달은 코텍(G.711, G.729, G.723 ....)을 이용하여 전달되게 되는데 이는 Legacy PBX에서 주파수를 이용하여 전달하는 것이라 생각 하시면 된다.

**IP Phone**은 일반적으로 2개의 Swtich포트를 제공하여 한 포트는 Switch에 다른 한 포트는 사용자의 PC에 연결이 되며, 큰 화면을 통해서 XML 브라우저를 통한 정보전달, 소프트키를 통한 부가서비스 등 다양한 기능을 수행한다.

![image-20200915163933132](https://user-images.githubusercontent.com/58545240/93182725-fe200600-f774-11ea-86cc-e7d15b1d2e7e.png)<Cisco IP Phone>

### > PoE Switch

> Power over Ethernet Swtich

**IP PBX, Voice Gateway, IP Phone**과 같은 직접 텔레포니의 기능을 수행하는 장비들이 있다면, 이들을 연결하는 장비도 필요하다. 이 시대 사는 대부분의 사람들에게 익순한 Switch라는 장비가 IP TelePhony에서는 또 하나의 중요한 요소이다.

하지만, 제목에서 그렇듯이 그냥 Switch가 아니다. ~~PoE스위치!!~~

Inline Power Switch라고도 불리는 장비는 회선을 통해서 전화기에 전원을 공급한다.

잠시, 아날로그 전화기로 화제를 바꿔 보자면, 일반적인 전화기는 전원을 위한 어댑터를 사용하지 않고도 전화가 가능하다. 즉, 집에 정전이 되어도 전화는 사용이 가능한 것이다. 이러한 이유는 PBX는 전화선을 통해 전원을 보내게 되어 있기 때문이다. 이렇듯 IP TelePhony에서도 전화기에 전원을 위한 어댑터를 사용하지 않아도 스위치를 통해 전원을 공급하게 된다.

![image-20200915164224397](https://user-images.githubusercontent.com/58545240/93182736-02e4ba00-f775-11ea-8181-4632e1220b36.png)<Cisco Catalyst Switch>

### > IP TelePhony의 기본구성

위의 각 컴포넌트들을 합쳐 놓으면 **IP TelePhony**의 기본구조가 완성이 된다. IP PBX는 전화기의 등록, 호처리, 부가서비스를 담당하고, 스위치는 전화기에 전원 공급 및 패킷 스위칭을 하고, Voice Gateway는 ethernet과 PSTN을 연결하여 IPT와 PSTN의 관문 역할을 담당하게 된다.

이러한 IPT환경을 기반으로 Unified Communication의 어플리케이션이 동작을 하게되고 사용자는 전화 뿐 아니라, 메세징, 협업, 텔레프레즌스 등의 서비스를 사용할 수 있게 된다.

즉, IPT의 처음 도입은 중요하다! 어떠한 프로토콜을 사용하느냐, 어떠한 기능이 지원되느냐를 기본으로 어떠한 서비스를 편리하고 조화롭게 업무에 사용할 수 있느냐에 대한 고려도 많이 되어야 한다.

![image-20200915164431796](https://user-images.githubusercontent.com/58545240/93182750-0710d780-f775-11ea-9ddc-58054548f933.png)<IP TelePhony의 기본구성>

## :black_nib: IP PBX의 주요 기능

**IP PBX**의 가장 기본이면서, 가장 중요한 것은 **호처리(Call Processing)**이다. 전화를 걸고 받는데에는 **시그널(Signal)과 미디어(Media)** 두 가지 형태의 패킷이 만들어 진다.

- **Signal**은 발신자 전화번호(Caller ID, Calling Party), 수신자 전화번호(Called Party), 코덱, IP Address 등 음성 이외의 모든 전화를 위한 정보를 담고 있다.

  => `SIP, H.323, MGCP, SCCP` 등 다양한 종류가 있으며 각 Signaliong Protocol은 각각 용도나 환경에 맞게끔 사용되게 된다.

- **Media**는 정해진 코덱으로 인코딩된 음성을 **`RTP(Real Time Protocol)`**로 전송하게 된다.

아래 그림의 Phone A가 Phone B에게 전화를 하려고 하는 상황이다.

Phone A와 Phone B는 각각 Switch에 UTP케이블로 연결이 되어 있고 PBX도 마찬가지로 Switch에 연결이 되어있다. 그럼 전화를 거는 과정을 살펴보자

1. Phone A의 수화기를 들면, Phone A는 다이얼 톤을 울리게 된다.

2. Phone  A에서 Phone B의 전화번호를 누르면 전화번호 정보를 담은 Signal이 IP PBX에게 전달된다.

3. IP PBX는 IP Phone B에게 Phone A가 전화가 왔다는 것을 알려주면 Phone B는 벨이 울리고, IP PBX는 Phone B의 벨이 울리고 있다는 것을 **Ring Back**을 통해 Phone A에게 알려준다.

4. Phone B가 전화를 받게되면 Media가 PBX를 거치지 않고 Phone A와 Phone B간에 흐르게 된다.

이와 같은 수순으로 Phone A와 Phone B 가 통화를 할 수 있게 된다.

![image-20200915165028214](https://user-images.githubusercontent.com/58545240/93182769-0d9f4f00-f775-11ea-86b9-09903997de43.png)



## :black_nib: 관리자 인터페이스

일반적으로 IP PBX는 Web을 통해서 Config를 한다. 예전에 CLI를 지원하는 PBS의 관리보다 조금 불편한 점도 있다고 하지만, 직관적인 인터페이스로는 웹과 CLI를 비교할 수가 없다.

![image-20200915165123357](https://user-images.githubusercontent.com/58545240/93182784-11cb6c80-f775-11ea-8e9b-5ee44e733fd9.png)

## :black_nib: IP PBX의 장점

1. **거리의 제약이 없다.**
   - IP PBX는 IP Network의 위에서 사용되기 때문에 거리에 제약이 없다. 글로벌 회사들에서는 아시아의 여러나라에 있는 지사를 홍콩, 싱가폴 등 한 위치에 IP PBX를 놓고 다양한 아시아의 나라가 전화를 사용한다. 즉 몇백명 정도 있는 지사에 궂이 PBX를 설치할 필요없이 전화의 사용이 가능한 것
   - 또한 그렇게 함으로써 **중앙 집중식 관리**가 가능하여, 본사의 정책을 지사에도 공통적으로 적용할 수 있고, 음성사서함, Visual Caller ID등의 부가기능도 본사와 지사가 하나의 서버를 사용할 수 있어서 중복투자 발생을 방지하고, 관리를 쉽게 할 수 있다.
2. **다양하고 사용하기 쉬운 부가 서비스**
   - 부가서비스는 Legacy PBX에도 다양하게 존재 했다. 하지만 그 특성상 사용자들이 편하게 사용할 수 없게끔 되어 있다. PBX의 그 다양한 기능을 제대로 사용하는 사람이 별로 없다.
   - 가장 큰 이유는 직관적이지 못한 액세스 코드를 이용한 부가서비스를 제공함으로써 일반 유저들이 매일같이 사용하지 않으면 잊어버려서 더이상 존재하지 않는 부가서비스가 되는 것이다.
   - 하지만 IP PBX는 IP Phone에 부가서비스에 대한 소프트키, 혹은 XML을 통한 그림버튼제공 등으로 직관적이고 User Friendly한 인터페이스를 제공하여 편하게 사용할 수 있도록 하는 것이 장점이다.
3. **UC? FMC? Collaboration?**
   - IP TelePhony는 전화기와 PBX만을 바꾸기 위해 도입하는 경우는 점점 줄어들고 있다. 일반적으로 **VoIP**를 사용하여 전화요금의 축소를 위한 것이 큰 목적인 회사의 경우 IPT도입만으로도 큰 도움이 되겠습니다만, 지금 도입을 생각하고 있는 대부분의 기업은 협업, 기업용 메신저, 스마트폰 도입, 그룹웨어와의 연동 등 IPT를 기반으로 좀 더 편리하고 좋은 기업환경과 Business Process의 개선을 위한 도입이 많아진다.
   - 이러한 UC, FMC, Collaboration은 IPTelePhony를 기반으로 Integration을 하면 더 많고 편리하게 사용이 가능해지며 생산성 향상에 도움이 된다.

## :black_nib: 마지막으로

1800년대 후반 전화기가 발명된 후 PBX의 발전이 음성과 음성을 보조하는 기술에 꾸준한 발전이 이루어졌다면, 최근 15년간은 음성과, 영상, 메신저, 협업, 소셜네트워킹과 같은 분야에 커다란 발전이 있었습니다. 그 발전의 기반은 IP Network와 PC의 보급 그리고 인터넷 문화의 확산에 따른 것이고, 이러한 문화에 익숙한 사람들이 일하는 세상은 점점 더 그들의 문화에 맞게 변해갈 것입니다. 

*IP PBX는 단순한 PBX 대용이 아니다. 새로운 통신의 기반이고, 플랫폼이다!*



# :point_up: Ubuntu환경에서 SIP Server 실행하기

~~sudo apt install yum~~

~~sudo apt install yum-utils~~

~~`yum-config-manager`로 yum 정상작동 확인~~

위 명령어는 CentOS전용이라 필요없고.. Ubuntu는

1. sudo apt-get install libssl-dev ( =*openssl 관련* )

2. `ksipserver.sh`파일에 root_dir=/home/work/voip/cppsipstack/KSipServer

3. make ( = *컴파일* )

4. chmod +x ksipserver.sh (실행권한부여)

5. UserXml > 1002.xml파일의 User 내부에 `<DND>ture</DND>`  추가하기

   *(DND : Do Not Distrub의 약자로 전화 수신을 하지 않고 싶을 때 사용하는 옵션. true가 되어 있으면 해당 사용자에게 호출한 전화는 KSipServer에서 자동으로 종료시킨다.)*

6. UserXml > 1003.xml파일의 User 내부에 `<CallForward>1001</CallForward>` 추가하기

   *(착신전환 기능을 on 시킨 사용자 정보를 포함한 XML파일이다. CallForward에 착신전환할 전화번호를 넣어주면 된다.)*

7. SipServer.Xml파일 수정하기(경로수정)

8. ./ksipserver.sh start



서버 start 시켰으면 SIP 통화 해보자

**SIP 클라이언트 프로그램 개발 가이드**

**1. SipClient 폴더의 소스 코드 읽기**

 \- SipClient 프로젝트는 C++ SIP stack 의 User Agent 의 기능을 SIP 클라이언트 입장에서 테스트하는 용도로 개발된 소스 코드입니다.

 \- SipClient 에는 3개의 소스 파일이 포함되어 있고 각각에 대한 설명은 다음과 같습니다.

  \* SipClient.cpp : SIP UserAgent callback 처리 클래스 정의

  \* SipClient.h : SIP UserAgent callback 처리 클래스 선언

  \* SipClientMain.cpp : SIP UserAgent 를 시작하고 기능 테스트



**2. SipClientMFC 폴더의 소스 코드 읽기**

 \- SipClientMFC 프로젝트는 MFC 기반 SIP 클라이언트 개발 예제 소스 코드입니다.

 \- SipClientMFC 프로젝트에서는 SipUserAgent 와 SipUserAgentMFC 라이브러리를 이용하여서 개발하였습니다.

 \- SipUserAgentMFC 라이브러리는 MFC 기반 윈도우 프로그램에서 효율적으로 callback 처리를 할 수 있는 기능이 개발되어 있습니다.





## C++ SIP stack 구조

![image-20200914103617338](https://user-images.githubusercontent.com/58545240/93182797-16902080-f775-11ea-98a8-019699edb5f4.png)

- **SipPlatform**
  - C++ SIP stack 에서 사용되는 OS 독립적인 유틸리티 라이브러리
  - 네트워크, 로그 등의 기능을 수행하는 라이브러리입니다.

- **SipParser**
  - SIP 메시지 파서/생성 라이브러리

- **SdpParser**
  - SDP 메시지 파서/생성 라이브러리

- **SipStack**
  - SIP stack 라이브러리
  - SIP 메시지 수신 / SIP 메시지 파싱 및 callback, stack 관리 기능을 수행합니다. 

- **SipUserAgent**
  - SIP 로그인 / 통화 관리 라이브러리
  - SIP Dialog 관리 기능
  - 응용 프로그램에서 SIP 프로토콜에 대한 지식이 없어서 편리하게 통화 요청 / 수락 / 거절 / 통화 종료할 수 있습니다.

- **XmlParser**
  - XML 문자열을 파서/생성 라이브러리
  - SIP body 에 포함된 XML 파싱 및 설정 파일 XML 파싱을 위한 기능



## 문서 보는 순서

1. [[오픈소스] C++ SIP stack 으로 IP-PBX 에 로그인하는 방법](http://blog.naver.com/websearch/220071177716)
2. [[오픈소스] C++ SIP stack 으로 통화 호출하는 방법](https://blog.naver.com/websearch/220071411915)



다익, 패턴, dfs, DP, 문자열 검색(트라이, KMP), 슬라이딩 윈도우, Hashmap,