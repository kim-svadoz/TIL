



# Tree :fist_oncoming:

# **> 트리와 이진트리 기본**

---

## 트리(Tree)

- 계층적인 구조를 표현하기 위해 사용하는 자료구조
  - 조직도
  - 디렉토리와 서브디렉토리 구조
  - 가계도

## 용어

- 루트(Root)
  - 트리는 노드(node)들과 노드들을 연결하는 링크(link)들로 구성된다.
  - 맨 위의 노드를 루트라고 한다.
- 부모-자식(parent-child) 관계
  - 각 노드들의 상하 관계를 부모-자식(parent-child)관계로 나타낸다.
- 형제 관계(sibling)
  - 루트노드를 제외한 트리의 모든 노드들은 유일한 부모노드를 가진다.
  - 부모가 동일한 노드들을 형제관계라고 부른다.
- 리프(leaf) 노드
  - 자식이 없는 노드들을 leaf 노드라고 부른다.
  - 리프노드가 아닌 노드들을 내부(internal)노드라고 부른다.
- 조상-자손(ancestor - descendant) 관계
  - 부모-자식관계를 확장한 것이 조상-자손 관계이다.
- subtree
  - 트리의 특성상 한 노드의 자손노드들의 집합도 트리이다.
  - 트리에서 어떤 한 노드와 그 노드의 자손들로 이루어진 트리를 subtree라고 한다.
- 레벨(level)
  - root 노드는 level 1
  - root 노드의 자식노드들은 level 2
  - ...
- 높이
  - 서로다른 레벨의 수이다.

## 트리의 기본적인 성질

- 노드가 N개인 트리는 항상 N-1개의 링크(link)를 가진다.
- 트리의 루트에서 어떤 노드로 가는 경로는 유일하다. 또한 임의의 두 노드간의 경로도 유일하다.(같은 노드를 두 번 이상 방문하지 않는다는 조건하에)

## 이진트리(binary tree)

- 이진 트리에서 각 노드는 최대 2개의 자식을 가진다.
- 각각의 자식 노드는 자신이 부모의 왼쪽자식인지 오른쪽 자식인지가 지정된다.(자식이 한명인 경우에도)

### 응용 예 - Expression Tree

- 수식을 트리로 구성하여 해석한다.
- 연산자들이 이진연산자라면 이진 트리의 형태로 표현할 수 있다.

![image-20200828134120186](https://user-images.githubusercontent.com/58545240/91522941-62019c80-e936-11ea-9f67-21ffc1ee920c.png)

### 응용 예 - Huffman Code

- 파일압축과 관련된 유명한 알고리즘 중 하나인 허프만 코딩을 할 때, 각 문자를 `encoding`하는데 허프만 tree를 구성한다.
- 추후에 자세히!

![image-20200828134257871](https://user-images.githubusercontent.com/58545240/91522965-6f1e8b80-e936-11ea-967a-a05f46dfb03c.png)

### Full and Complete Binary Trees

- 꽉찬 이진트리와 완전 이진트리
- 높이가 h인 full binary tree는 2^h-1개의 노드를 가진다.
- 노드가 N개인 full 혹은 complete binary 트리의 높이는 O(logN)이다. (노드가 N개인 이진트리의 높이는 최악의 경우 N이 될 수도 있다.)

## 이진트리의 표현

- 힙을 표현했을 때는, 완전 이진 트리의 형태 였기 때문에 부모와 자식간의 관계가 배열로 표현하기에 충분했다. 하지만, 완전 이진트리가 아닌 형태라면 아래와 같은 구조의 표현이 필요하다.

- 연결구조(Linked Structure)

  - 각 노드에 하나의 데이터 필드와 왼쪽자식(left), 오른쪽 자식(right), 그리고 부모노드(p)의 주소를 저장(부모노드의 주소는 반드시 필요한 경우가 아니면 보통 생략함)

  ![image-20200828140842141](https://user-images.githubusercontent.com/58545240/91523715-6929aa00-e938-11ea-82cb-33acdf530f2f.png)

  - 예시
    - 트리상의 노드를 객체로 표현하여 이진트리를 Linked Structure로 표현할 수 있다.

  ![image-20200828140856659](https://user-images.githubusercontent.com/58545240/91523723-6fb82180-e938-11ea-89e6-7aa8d1b83f2e.png)

    

## 이진트리의 순회(traversal)

- 순회 
  - 이진 트리의 모든 노드를 방문하는 일
- 중위(inorder) 순회
- 전위(preorder) 순회
- 후위(postorder)순회
- 레벨오더(level-order) 순회

### inorder-중위 순회

- 순회는 본질적으로 recursive한 알고리즘이다.
- 이진트리를 루트노드, left Tree, right Tree로 나누어 생각한다.
- 먼저 left Tree를 inorder로 순회하고,
- root를 순회하고,
- right Tree를 inorder로 순회한다.
- **pseudo code**
  - x를 루트로 하는 트리를 inorder 순회
  - 시간복잡도 O(n)

```java
INORDER-TREE-WALK(x)
  if x != NULL
    then INORDER-TREE-WALK(left[x])
         print key[x]
         INORDER-TREE-WALK(right[x])
```

### postorder와 preorder순회

- inorder 순회와 다른점은 노드를 방문하는 순서뿐이다. 나머지의 개념은 동일하다.

- 트리를 방문하는 순서만 바뀐다.

- preorder-전위 순회

  - root를 순회하고,
  - 먼저 left Tree를 inorder로 순회하고,
  - right Tree를 inorder로 순회한다.

  ```java
  PREORDER-TREE-WALK(x)
    if x != NULL
      then print key[x]
           PREORDER-TREE-WALK(left[x])
           PREORDER-TREE-WALK(right[x])
  ```

- postorder-후위 순회

  - 먼저 left Tree를 inorder로 순회하고,
  - right Tree를 inorder로 순회하고,
  - root를 순회한다.

  ```java
  POSTORDER-TREE-WALK(x)
    if x != NULL
      then POSTORDER-TREE-WALK(left[x])
           POSTORDER-TREE-WALK(right[x])
           print key[x]
  ```

### Expression Trees

![image-20200828140911666](https://user-images.githubusercontent.com/58545240/91523736-75ae0280-e938-11ea-9dd4-292568bdf801.png)

- Expression 트리를 inorder-중위 순회하면 다음과 같이 출력됨
  - x + y * a + b / c
- 각 부트리를 순회할 때 시작과 종료시에 괄호를 추가하면 다음과 같이 올바른 수식이 출력됨
  - (x + y) * ((a + b) /c)
- postorder-후위 순회하면 후위표기식이 출력됨
  - x y + a b + c / *

### lever-order 순회

![image-20200828140923359](https://user-images.githubusercontent.com/58545240/91523743-7ba3e380-e938-11ea-98d6-4d152b3dfec4.png)

- 레벌 순으로 방문, 동일 레벨에서는 왼쪽에서 오른쪽 순서로 방문
- 큐(queue)를 이용하여 구현
  - 맨 처음 큐에 루트 노드 3을 넣는다.
  - 큐를 꺼내고, 3을 출력한 뒤,
  - 3의 왼쪽자식 1과, 오른쪽자식 5를 큐에 넣는다.
  - 1을 꺼내고 출력한 뒤, 1의 자식인 0과 2를 큐에 넣는다.
  - 다음 순서로 5를 꺼내고 출력한 뒤, 5의 왼쪽 자식인 4와 오른쪽 자식인 6을 큐에 넣는다.
- pseudo code

```java
LEVEL-ORDER-TREE-TRAVERSAL()
  visit the root;
  Q <- root       //Q is a queue
  while Q is not empty do
    v <- dequeue(Q);
    visit children of v;
    enqueue children of v into Q;
  end.
end.
```

# **> 이진탐색트리(BST)**

## Dynamic Set

집합이다. 여러개의 데이터의 집합인데, 그것들의 내용이 고정되지 않고, 생성과 삭제를 반복하면서 유동적인 집합이다. 아래와 같은 특징을 가진다. Dynamic Set, Dictionary 또는 Search Structure라고 불린다.

- 여러 개의 키(key)를 저장
- 다음과 같은 연산들을 지원하는 자료구조
  - INSERT - 새로운 키의 삽입
  - SEARCH - 키 탐색
  - DELETE - 키의 삭제
- 예: 심볼 테이블
- 일반적으로 구현할 때 배열 or 연결리스트를 사용한다.
  - 각 동작에 있어서 다음과 같은 시간복잡도를 가진다.
  - 정렬된 배열의 이진탐색 - O(logn)
  - 정렬된 배열에서 원소를 insert, delete하면 나머지 원소들을 한칸식 shift - O(n)
  - 정렬된 연결리스트의 경우는 이진탐색 불가 - O(n)을 피할 수 없음.
  - 정렬된 연결리스트에서 insert할 자리를 찾는 시간 - O(n)

| 종류       | 정렬 | search  | insert | delete                          |
| :--------- | :--- | :------ | :----- | :------------------------------ |
| 배열       | O    | O(logn) | O(n)   | O(n)(삭제 후 shift)             |
|            | X    | O(n)    | O(1)   | O(1)(찾았다고 가정하고, 삭제만) |
| 연결리스트 | O    | O(n)    | O(n)   | O(1)(찾았다고 가정하고, 삭제만) |
|            | X    | O(n)    | O(1)   | O(1)(찾았다고 가정하고, 삭제만) |

- 정렬된 혹은 정렬되지 않은 배열, 연결 리스트를 사용할 경우 INSERT, SEARCH, DELETE 중 적어도 하나는 O(n)의 시간복잡도를 가짐.
- 3가지 연산 모두 O(n)의 시간을 갖지 않는 효율적인 알고리즘은 없는가?
  - 이진탐색트리(Binary Search Tree), 레드-블랙 트리, AVL- 트리등의 트리에 기반한 구조들
  - Direct Address Table, **해시** 테이블 등

## 검색트리

- Dynamic set을 트리의 형태로 구현
- 일반적으로 SEARCH, INSERT, DELETE 연산이 트리의 높이(height)에 비례하는 시간복잡도를 가진다.
- 이진검색트리, 레드-블랙트리, B-트리 등  

## 이진검색트리(BST)

- 이진 트리이면서
- 각 노드에 하나의 키를 저장
- 각 노드 v에 대해서 그 노드의 왼쪽 서브트리에 있는 키들은 key[v]보다 작거나 같고, 오른쪽 부트리에 있는 값은 크거나 같다.

### SEARCH

![image-20200828140947553](https://user-images.githubusercontent.com/58545240/91523751-8199c480-e938-11ea-9442-5b721470f197.png)

- pesedo code

  - 키 값에 따라서 왼쪽 서브트리 또는 오른쪽 서브트리를 recursive하게 탐색한다.
  - 시간복잡도: O(h), 여기서 h는 트리의 높이 이다.
  - Recursive Version

  ```java
  TREE-SEARCH(x, k)
    if x = NULL or k = key[x]
      then return x
    if k < key[x]
      then return TREE-SEARCH(left[x], k)
      else return TREE-SEARCH(right[x], k)
  ```

  - Iterative Version

  ```java
  TREE-SEARCH(x, k)
    while x!=NULL and k!=key[x]
      do if k < key[x]
        then x <- left[x]
        else x <- right[x]
    return x
  ```

#### 최소값 찾기

- 최소값은 항상 가장 왼쪽 노드에 존재
- 시간복잡도: O(h)
- 최대 값은 반대로 가장 오른쪽 노드를 찾아가는 방법으로 찾는다.

```java
TREE-MINIMUM(x)
  while left[x] != null
    do x <- left[x]
  return x
```

#### Successor 찾기

- 노드 x의 successor란 key[x]보다 크면서 가장 작은 키를 가진 노드
- 모든 키들이 서로 다르다고 가정한다.
- successor의 3가지 경우
  - 노드 x의 오른쪽 서브트리가 존재할 경우, 오른쪽 서브트리의 최소값
  - 오른쪽 서브트리가 없는 경우, 어떤 노드 y의 왼쪽 서브트리의 최대값이 x가 되는 그런 노드 y가 x의 successor
    - 부모를 따라 루트까지 올라가면서 처음으로 왼쪽 링크를 타고 올라간 해당 노드가 y
    - 여기서는 4(x)의 successor를 구할 때, 루트까지 올라가면서 처음으로 왼쪽 링크를 타고 위로 올라간 노드 6(y).
  - 그런 노드 y가 존재하지 않을 경우 successor가 존재하지 않음(즉, x가 최대값)

![image-20200828140959411](https://user-images.githubusercontent.com/58545240/91523758-878fa580-e938-11ea-8346-c573d800fc99.png)

- peudo code
  - 1,2 : 오른쪽 서브트리가 존재할 경우, 오른쪽 트리의 최소 값을 찾는다.
  - 3 : y는 x의 부모노드
  - 4, 5, 6 : 부모노드가 null이 아니고, x가 부모의 오른쪽 자식일 경우에만 계속해서 부모를 찾아 올라간다.
  - 7 : 부모를 찾아 올라가다가 y가 null이거나, 누군가의 왼쪽 자식이 되는 경우 null 또는 y값을return 한다.
  - 시간복잡도 : O(h)

```java
TREE-SUCCESSOR(x)
1  if right[x] != NULL
2    then return TREE-MINIMUM(right[x])
3  y <- p[x]
4  while y != NULL and x = right[y]
5    do x <- y
6       y <- p[y]
7  return y  
```

#### Predecessor

- 노드 x의 predecessor란 key[x]보다 작으면서 가장 큰 키를 가진 노드
- Successor와 반대

 

### INSERT

- 14의 삽입 위치를 찾으러 13의 오른쪽으로 내려갔는데, x의 위치가 null이 되므로 항상 x의 부모 노드 y를 관리해 준다.

![image-20200828141010611](https://user-images.githubusercontent.com/58545240/91523768-8d858680-e938-11ea-9d06-afd77ab0ed90.png)

- pseudo code
  - T는 Tree, z는 insert할 노드
  - 1,2 : y = null, x = root노드 에서 출발
  - 3 : x가 null이 아닐때 까지 
  - 4 : y에 x를 저장해놓고,
  - 5,6,7 : z와 x의 키값을 비교해서 z의 키값이 x의 키값보다 작으면 왼쪽 노드로, z의 키값이 더 크면 오른쪽 노드로 내려간다. 내려간 뒤, 다시 y에 x를 저장, 반복
  - 8 : 새로운 노드 z의 부모는 y가 된다.
  - 9,10 : y가 NULL이라면, Tree가 NULL이라는 의미이고 z는 root가 된다.
  - 11,12 : z의 키 값이 y보다 작다면 왼쪽 자식이 되고,
  - 13,14 : z의 키 값이 y보다 크다면 오른쪽 자식이 된다.
- 시간복잡도는 : O(h)
  - 트리의 높이보다 더 많은 시간을 필요로 하진 않는다.

```java
TREE-INSERT(T, z)
01  y <- NULL
02  x <- root[T]
03  while x!= NULL
04    do y <- x
05      if key[z] < key[x]
06        then x <- left[x]
07      else x <- right[x]
08  p[z] <- y
09  if y = NULL
10    then root[T] <- z
11  else if key[z] < key[y]
12    then left[y] <- z
13  else
14    then right[y] <- z  
```

### DELETE

- Case 1 : 자식노드가 없는 경우
  - 리프노드인경우 그냥 삭제한다.

![image-20200828141022597](https://user-images.githubusercontent.com/58545240/91523782-937b6780-e938-11ea-9d70-8424cc4d795f.png)

- Case 2 : 자식노드가 1개인 경우
  - 자신의 자식 노드를 원래 자신의 위치가 될 수 있도록 연결한다.

![image-20200828141037478](https://user-images.githubusercontent.com/58545240/91523799-9bd3a280-e938-11ea-9377-b4e80685f256.png)

- Case 3 : 자식노드가 2개인 경우
  - 가장 복잡한 경우이다. 자식 노드가 2개인 노드를 삭제하는 경우 트리의 구조가 깨지기 때문에 다시 조건을 만족하는 트리를 만들어주는 작업이 필요하다.
  - 13을 삭제하는 경우, 13의 노드에 있는 데이터만 삭제하고,
  - 삭제하려는 노드의 Successor의 데이터만 copy해서 가져온다.
  - 그리고 Successor를 삭제한다.
  - **자식노드가 2개인 노드의 Successor는 왼쪽 자식이 없다는 것이 보장되어 있다.** 하지만, 오른쪽 자식은 있을 수도 있고 없을 수도 있다. 즉, 자식노드가 0개 또는 1개이다.
  - 이 경우, Case 1 또는 2에 해당하므로, 방법에 맞게 삭제한다.

![image-20200828141048342](https://user-images.githubusercontent.com/58545240/91523811-a4c47400-e938-11ea-9b84-2a4da86031a1.png)

![image-20200828141100931](https://user-images.githubusercontent.com/58545240/91523822-ac841880-e938-11ea-8b46-9bf613298c7d.png)

- Case별 예시

![image-20200828141119116](https://user-images.githubusercontent.com/58545240/91523833-b279f980-e938-11ea-933e-38d556eb936f.png)

- pseudo code
  - T는 트리 z는 삭제할 노드, 삭제할 노드를 search하는 작업은 이루어 졌다고 가정하고, 삭제하는 로직
  - 1,2,3 : 실제로 트리에서 삭제할 노드 y를 정한다. 자식노드가 0개 또는 1개일 경우 실제로 해당 노드를 삭제할 것이기 때문에 y에 z를 대입한다. 자식노드가 2개일 경우 삭제할 노드 y는 z의 successor를 대입하여 삭제한다.
  - 따라서, 4 - 13라인은 실제 노드 y를 삭제하는 경우이고, 14 - 17라인은 노드 z의 Successor를 삭제하는 case 3인 경우이다.
  - 4, 5, 6 : y의 자식은 0개 또는 1개인 상태이다. y의 왼쪽 자식이 존재한다면, x는 y의 왼쪽 자식이고, 그렇지 않다면 x는 y의 오른쪽 자식이다.
  - 7, 8 : 그리고 x가 NULL이 아니라면, 현재 y의 부모를 x의 부모로 설정한다.
  - 9,10 : y의 부모가 없다면, 즉 y가 루트노드라면, x를 루트로 설정한다.
  - 11,12 : 그렇지 않고 y가 자신의 부모의 왼쪽 자식이었다면, 삭제될 노드 y의 부모의 왼쪽 자식을 x로 설정하고
  - 13 : 그렇지 않고 y가 자신의 부모의 오른쪽 자식이었다면, 삭제될 노드 y의 부모의  오른쪽 자식으로 x를 설정한다. 이렇게 해서 실제 y를 삭제하는 일이 끝났다.
  - 14, 15, 16 : 삭제하려는 노드 z와 실제 트리에서 삭제될 노드 z가 다르다는 것은 case 3에 해당한다는 이야기 이므로, y에 보관되어 있는 데이터를 z의 자리로 옮기고(y의 키값만이 아닌 satellite data들 까지 모두), 실제 삭제된 노드의 데이터 y를 리턴한다.
  - 시간복잡도 O(h)

```java
TREE-DELETE(T, z)
01  if left[z] = NULL or right[z] = null
02    then y <- z
03  else y <- TREE-SUCCESSOR(z)
04  if left[y] != NULL
05    then x <- left[y]
06  else x <- right[y]
07  if x != NULL
08    then p[x] <- p[y]
09  if p[y] = NULL
10    then root[T] <- x
11  else if y = left[p[y]]
12    then left[p[y]] <- x
13  else right[p[y]] <- x
14  if y != z
15    then key[z] <- key[y]
16      copy y's satellite data into z
17  return y
```

## BST 정리

- 각종 연산의 시간복잡도는 O(h)이다.
- 최악의 경우 트리의 높이 h는 O(n)이다.
  - 실제 위에서 학습한 BST의 Search, Insert, Delete 모두 최악의 경우 시간복잡도는 O(n)이다.
  - 그러나, 이것은 실제 최악의 경우에 해당한다. BST에 데이터들이 random하게 구성된다고 가정했을때, 평균 트리의 높이는 O(logn)이 된다. 이는 Search, Insert, Delete 연산의 시간복잡도가 O(logn)이 된다는 이야기이다.
- 최악의 경우에도 O(logn)을 넘지 않도록 하는 균형잡힌 트리
  - 레드-블랙 트리 등
  - 키의 삽입이나 삭제시 추가로 트리의 균형을 잡아줌으로써 높이를 O(logn)으로 유지한다.

# **> 부록 - 이진트리**

---

## 1. 후위 순회(postorder)

이진 트리(binary tree)의 후위 순회 알고리즘이 사용될 수 있는 대표적인 예는 **특정 디렉토리(directory)의 용량 계산**이다. 단, 이진 트리이기 때문에 특정 디렉토리(=폴더)의 서브 디렉토리의 개수는 2개 이하로만 존재해야 한다. 삼진 트리(ternary tree)였다면 서브 디렉토리는 총 3개까지 존재할 수 있다.

### 1.1 디렉토리의 용량 계산

디렉토리의 용량 계산을 위해서는 **어떤 알고리즘이 사용되야하는가**를 먼저 고민해보자. 생각을 할 때 구체적인 상황을 두고 예시를 들어보면 이해가 빠르다. 현재 사용하는 컴퓨터에 `datastructure` 라는 디렉토리가 있다고 가정해보자. 이 `datastructure` 디렉토리 내부에는 `stack`, `queue` 라는 서브 디렉토리가 존재한다.

- `datastructure/stack`
- `datastructure/queue` 이 때 `datastructure` 디렉토리의 크기를 구하려면 어떻게 해야할까?

서브 디렉토리인 `stack` 디렉토리와 `queue` 디렉토리의 크기를 각 계산하여 합하면 `datastructure` 폴더의 크기를 계산할 수 있다. **서브 디렉토리의 크기를 더해 현재 디렉토리의 크기를 계산한다**는 아이디어를 생각해보면 서브 디렉토리의 크기를 먼저 계산하는데, 바로 이러한 특징 때문에 후위 순회 알고리즘을 사용해야 한다.

### 1.2 코드

> *후위 순회: 트리를 탐색할 때 왼쪽 서브트리, 오른쪽 서브트리, 루트 순으로 방문하는 순회 알고리즘을 일컫는 말이다. 후위 순회 알고리즘은 아래와 같다.*

```C
// 후위 순회 알고리즘
void postorder(TreeNode *root){
    if(root){
        postorder(root->left);		// 왼쪽 서브 트리를 가장 먼저 순회
        postorder(root->right);		// 다음으로 오른쪽 서브 트리를 순회
        printf("%d", root->data);	// 마지막으로 루트의 노드를 방문
    }
}
```

위와 같은 후위 순회를 사용하여 디렉토리 크기를 계산하는 코드를 작성해보도록 한다. 순환 호출되는 함수가 용량을 반환하도록 만들어줘야 한다.

```C
// 디렉토리 용량 계산 프로그램
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>

typedef struct TreeNode{
    int data;
    struct TreeNode *left, *right;
} TreeNode;

int calc_dir_size(TreeNode *root);

// 아래와 같은 트리 구조를 생성한다.
//				n1
//			n3		n2
//		n4		n5
int main(){
    TreeNode n4 = { 500, NULL, NULL };
    TreeNode n5 = { 200, NULL, NULL };
    TreeNode n3 = { 100, &n4, &n5 };
    TreeNode n2 = { 50, NULL, NULL };
    TreeNode n1 = { 0, &n2, & n3 };
    
    printf("디렉토리의 크기 = %d\n", calc_dir_size(&n1));
}

int calc_dir_size(TreeNode *root){
    if(!root) return 0;		// 존재하지 않는 노드일 경우
    else{
        int left = calc_dir_size(root->left);		// 왼쪽 서브트리를 먼저 순회한다
        int right = calc_dir_size(root->right);		// 오른쪽 서브트리를 그 다음으로 순회한다.
        return left + right + root->data;			// 순회한 노드에 해당하는 데이터를 계속해서 더해간다.
    }
    return 0;
}
```

## 2. 이진트리의 높이 구하기

트리의 높이를 구할 때의 핵심 개념은 왼쪽 서브트리의 높이와 오른쪽 서브트리의 높이를 비교하여 **더 큰 쪽을 택한다**는 것이다. 그렇다면 우리에게 필요한 건 서브트리의 높이와 오른쪽 서브트리의 높이다. 높이는 어떻게 구할 수 있을까?

### 2.1 코드

```C
typedef struct TreeNode{
    int data;
    struct TreeNode *left, *right;
} TreeNode;
int get_height(TreeNode *root);
// 아래와 같은 트리 구조를 생성한다.
//      n1
//    n3    n2
//  n4    n5
void main(){
    TreeNode n4 = { 500, NULL, NULL };
    TreeNode n5 = { 200, NULL, NULL };
    TreeNode n3 = { 100, &n4, &n5 };
    TreeNode n2 = { 50, NULL, NULL };
    TreeNode n1 = { 0, &n2, &n3 };
    
    printf("디렉토리의 크기 = %d\n", calc_dir_size(&n1));
}

int get_height(TreeNode *root){		// 트리의 높이를 구한다
    if(!root) return 0;
    else{
        int left_h = get_height(root->left);		// 왼쪽 서브트리의 높이를 순환호출을 통해 얻는다.
        int right_h = get_height(root->right);		// 같은 방법으로 오른쪽 서브트리의 높이를 얻는다.
        return 1 = (left_h > right_h ? left_h : right_h);		// 둘 중 큰 값에 1을 더해 반환한다.
    }
}
```

위 코드를 이해해보자. 순환 알고리즘이 적용된 코드를 작성하거나 읽을 때는 탈출 조건 보다는 **순환호출 되는 부분을 먼저 살펴봐야 한다.** 호출되는 부분은 `int left_h = get_height(root->left)`, `int right_h = get_height(root->right)` 이 두 부분이다.

위 순환 호출되는 코드로 왼쪽 서브트리의 높이 `left_h`와 오른쪽 서브트리의 높이 `right_h`를 구하기 위해 순환 함수로 각 서브트리의 끝(단말 노드)까지 방문할 수 있다. 방문 순서는 `get_height(root->left`가 먼저 호출되었으므로 먼저 왼쪽 서브트리의 단말노드까지 방문할 것이고 탈출 조건 `if (!root)`를 만나면서 왼쪽 서브트리를 빠져나오면 오른쪽 서브트리로 진입한다(`get_height(root->right)`.

다음으로 탈출되는 조건을 살펴보자. 위 코드에서 상정한 탈출 조건은 **단말노드를 만났을 때**다. 단말노드란 자식이 없는 노드를 뜻한다. 그렇다면 단말노드인 것은 어떻게 알 수 있을까?

자식이 없는 노드가 단말노드이므로 아래와 같은 두 조건을 생각해볼 수 있다.

```C
/**
* if (root->left == NULL && root->right == NULL) // 왼쪽 서브트리와 오른쪽 서브트리가 없을 때
* if (root == NULL) or if (!root)	// 방문을 했는데 존재하지 않는 노드였을 경우
*/
```

`root == NULL`의 의미를 좀 더 풀어서 설명하자면 **자식 노드가 있나 살펴보려 서브 트리를 방문했는데 아무것도 발견할 수 없었다**라는 의미다. 위 코드는 이 조건을 적용한 코드다.

마지막으로 `get_height`함수에서 맨 아래 리턴하는 부분을 살펴보자. **왜 1을 더해서 리턴해주는 걸까?**라는 의문이 든다면 그 이전에 어떤 작업을 시행했는지를 살펴보자. 특히 첫번째 완전한 순환이 끝났을 때를 생각해보자. 순환을 계속하면서 각 서브 트리의 끝까지 방문한 상태(정확히는 오른쪽 서브트리를 끝까지 방문한 상태)에서 한 단계 더 내려가 `root == NULL`이라는 탈출 조건을 만났다. 그렇게 탈출 조건을 만나 빠져나오면 마지막 리턴문을 만나게 되는데 이때의 상황은 더 이상의 자식노드, 서브트리가 없는 상황이므로 리턴문에 있는 `left_h`와 `right_h`는 둘 다 0이 될 것이다.

위 상황에 대한 결론을 내려보면 나에게 자식노드, 서브트리는 존재하지 않지만 적어도 **나는 존재한다는 것을 입증했다는 것**이다. 따라서 나 자신을 하나의 개수로 칠 수 있다. 그래서 1을 더하는 것이다. 1을 더한 후에는 왼쪽 서브트리와 오른쪽 서브트리의 높이 중 더 큰 값을 택하기만 하면 되는 것이다.

순환의 개념을 접할 때는 추상적으로 이해하면 이해에 좀 더 도움이 된다. 큼지막한 매커니즘, 예를 들어 왼쪽 서브트리 높이 구하기, 오른쪽 서브트리 높이 구하기들이 대략 어떤 순서로 실행되는지를 파악하고 리턴은 언제 되고 탈출 조건은 어떻게 되는지를 살펴보는 것이다. 실행 흐름을 하나 하나 다 따지려 하기보다는 먼저 이렇게 개념적으로 접근한 후에 세부적으로 이해하려고 하면 좀 더 편하다.

## 3. 이진트리의 단말 노드 개수 구하기

2번에서 살펴본 알고리즘을 그대로 적용하면 의외로 쉽게 구할 수 있다. 아래의 코드만 보고 개념을 이해하도록 해보자.

### 3.1 코드

```C
typedef struct TreeNode{
    int data;
    struct TreeNode *left, *right;
} TreeNode;

int get_leaf(TreeNode *root);
// 아래와 같은 트리 구조를 생성한다.
//      n1
//    n3    n2
//  n4    n5

void main(){
    TreeNode n4 = { 500, NULL, NULL };
    TreeNode n5 = { 200, NULL, NULL };
    TreeNode n3 = { 100, &n4, &n5 };
    TreeNode n2 = { 50, NULL, NULL };
    TreeNode n1 = { 0, &n2, &n3 };
 
    printf("단말 노드의 갯수 = %d\n", get_leaf(&n1));
}

int get_leaf(TreeNode *root){		// 트리에 존재하는 단말노드의 갯수를 구한다.
    if(!root) return 0;
    if(root->left == NULL & root->right == NULL) return 1;
    else return get_leaf(root->left) + get_leaf(root->right);
}
```

위 코드의 탈출 조건은 `if (root->left == NULL && root->right == NULL)`다. 즉 **자식노드 혹은 서브트리가 존재하지 않을 때**가 탈출 조건이다. 의미는 **자식 노드는 존재하지 않지만 내가 존재한다는 건 적어도 증명했으니 난 1개로 셀 수 있다**는 것이다. 첫번째 `if (!root)`의 조건은 누군가 이 함수를 사용할 때 존재하지 않는 노드를 매개변수로 넘겼을 때를 대비하기 위함이다 .오류를 방지하는 용도로서의 의미를 가진 조건이다. 이 조건을 탈출 조건으로 쓸 수 없는 것은 이 조건 만으로는 단말 노드의 여부를 증명할 수 없기 때문이다. 아무것도 존재하지 않으므로 개수를 셀 수 없다.

# **> 트라이(Trie)**

---

> **문자열에서의 검색을 빠르게 해주는 자료구조**
>
> **래딕스 트리(radix tree)** 나 **접두사 트리(prefix tree)**라고도 한다.

우리는 정수형 자료형에 대해서 이진검색트리를 이용하면 O(logN)의 시간만에 원하는 데이터를 검색할 수 있다. 하지만 문자열에서 이진검색트리를 사용한다면 문자열의 최대길이가 M이라면 O(MlogN)의 시간 복잡도를 가지게 될 것이다.

우리는 문자열 검색을 개선하기 위해 트라이를 이용하여 O(M)의 시간만에 원하는 문자열을 검색할 수 있다.

트라이라는 명칭은 Re**trie**val에서 유래한다. 트라이가 retrieve(탐색)하는데 유용한 걸 생각하면 납득ㅇ ㅣ디ㅗㄴ다.

자 그러면 트라이는 어떻게 문자열의 검색을 O(M)만에 처리할까?

아래 그림은 문자열 집합 = {"AE" , "ATV", "ATES", "ATEV", "DE" ,"DC"} 가 존재할 때 트라이의 예입니다.

![image-20200910180006571](https://user-images.githubusercontent.com/58545240/92707306-23d19780-f390-11ea-9dbc-fb8affcde180.png)

쿼리에 따라서 처리해줄 수 있는 역할이 달라지겠지만 우리는 대부분 문자열이 끝나는 지점을 표시하는것이 쿼리를 처리할 때 편합니다.

![image-20200910180022996](https://user-images.githubusercontent.com/58545240/92707337-2a600f00-f390-11ea-92e0-76236f2927c8.png)

종료 노드들을 표시해주면 위와같은 그림이 되겠군요

자 우리는 트리형태를 띄는 트라이에서 검색을 할 경우 최대 트리의 높이까지 탐색하게 됩니다.

따라서 시간복잡도는 O(H)가 되겠죠 하지만 트리의 높이는 최대 문자열의 길이가 되기 때문에 O(M)의 시간복잡도에 문자열 검색이 가능한 것입니다.

자 그러면 우리는 트라이를 어떻게 구현해야 할까요?

많은 방법이 있겠지만 종만북을 참고하여 가장 보편적인 방법을 보여드리겠습니다.

## TrieNode.java

```java
import java.util.HashMap;
import java.util.Map;
public class TrieNode {
    // [ 변수 ]
    // 자식 노드 맵
    private Map<Character, TrieNode> childNodes = new HashMap<>();
    // 마지막 글자인지 여부
    private boolean isLastChar;
    // [ GETTER / SETTER 메서드 ]
    // 자식 노드 맵 Getter
    
    Map<Character, TrieNode> getChildNodes() {
        return this.childNodes;
    }
    // 마지막 글자인지 여부 Getter
    boolean isLastChar() {
        return this.isLastChar;
    }
    // 마지막 글자인지 여부 Setter
    void setIsLastChar(boolean isLastChar) {
        this.isLastChar = isLastChar;
    }
}
```

```c++
struct Trie {
    bool finish;    //끝나는 지점을 표시해줌
    Trie* next[26];    //26가지 알파벳에 대한 트라이
    Trie() : finish(false) {
        memset(next, 0, sizeof(next));
    }
    ~Trie() {
        for (int i = 0; i < 26; i++)
            if (next[i])
                delete next[i];
    }
    void insert(const char* key) {
        if (*key == '\0')
            finish = true;    //문자열이 끝나는 지점일 경우 표시
        else {
            int curr = *key - 'A';
            if (next[curr] == NULL)
                next[curr] = new Trie();    //탐색이 처음되는 지점일 경우 동적할당
            next[curr]->insert(key + 1);    //다음 문자 삽입
        }
    }
    Trie* find(const char* key) {
        if (*key == '\0')return this;//문자열이 끝나는 위치를 반환
        int curr = *key - 'A';
        if (next[curr] == NULL)return NULL;//찾는 값이 존재하지 않음
        return next[curr]->find(key + 1); //다음 문자를 탐색
    }
};
```

트라이는 자료구조이기 때문에 입맛에 따라서 변형하여 사용이 가능해야 합니다.

따라서 우리는 문제에서 원하는 조건에 따라서 find함수를 여러방식으로 변형하여 사용하게 될것입니다. 

그러면 우리는 트라이를 통하여 어떤 문제를 해결할 수 있을까요??

[BOJ 5052 전화번호 목록](http://icpc.me/5052) 문제를 보겠습니다.

전화 번호의 목록이 주어질 때 일관성이 있는지는 확인하는 문제입니다.

우리는 트라이를 이용하여 이 문제를 간단하게 해결할 수 있습니다.

모든 문자열을 트라이에 삽입해준 후 다시 모든 문자열을 트라이로 검색하면서 아직 검색중인데 finish인 부분이 한번이라도 존재한다면 일관성이 없다고 처리가 됩니다.

총 시간 복잡도는 O(T*(N*10))이 되겠군요 여기서 10은 전화번호의 최대길이입니다.

다음은 소스코드입니다.

```c++
#include <cstdio>
#include <algorithm>
#include <cstring>
#define MAX_N 10000
using namespace std;
struct Trie{
    Trie* next[10];
    bool term;
    Trie() : term(false){
        memset(next,0,sizeof(next));
    }
    ~Trie(){
        for(int i=0;i<10;i++){
            if(next[i])
                delete next[i];
        }
    }
    void insert(const char* key){
        if(*key=='\0')
            term=true;
        else{
            int curr = *key-'0';
            if(next[curr]==NULL)
                next[curr]=new Trie();
            next[curr]->insert(key+1);
        }
    }
    bool find(const char* key){
         if(*key=='\0')
            return 0;
        if(term)
            return 1;
        int curr = *key-'0';
        return next[curr]->find(key+1);
    }
};
int t,n,r;
char a[MAX_N][11];
int main(){
    scanf("%d",&t);
    while(t--){
        scanf("%d",&n);
        getchar();
        for(int i=0;i<n;i++)
            scanf("%s",&a[i]);
        Trie *root=new Trie;
        r=0;
        for(int i=0;i<n;i++)
            root->insert(a[i]);
        for(int i=0;i<n;i++){
            if(root->find(a[i])){
                r=1;
            }
        }
        printf("%s\n",r?"NO":"YES");
    }
    return 0;
}
```



# **> 세그먼트 트리(Segment Tree)**

---

> **각 구간들을 그대로 보존하고 있는 트리**

![image-20200914160424940](https://user-images.githubusercontent.com/58545240/93054868-01e45780-f6a5-11ea-824c-93a0ed3c2007.png)

전체 구간이 [0, N-1]이라 할 때, 즉 N개의 공간이 있을 때

이렇게 리프 노드들은 길이가 1인 각각의 구간을 갖고 있고

부모 노드는 자신의 자식들의 구간의 합을 갖고 있으며 모든 구간은 연속적이어야만 합니다.

루트는 전체 구간을 포함하게 됩니다.

이렇게 각 노드가 구간, 혹은 그 구간의 정보를 저장하고 있는 자료구조를 말합니다.

![image-20200914160437172](https://user-images.githubusercontent.com/58545240/93054876-06a90b80-f6a5-11ea-9a8e-9d3eb18fa8e5.png)

보통은 **완전 이진 트리**의 형태를 사용해 전체적으로 동일한 재귀적 구조가 반복되도록 이렇게 표현하며, 값의 개수가 2^n 꼴이 아닐 때 남는 구간을 의미없는, 혹은 기본 값으로 채워서 **포화 이진 트리** 형태로 사용하는 게 대부분입니다.

이렇게 하면 값이 N개일 때 반드시 트리의 높이가 **O(logN)**으로 균형잡혀 있기 때문이죠!

그리고 힙 때와 마찬가지로 루트의 인덱스가 1부터 시작되며 레벨 오더 순번으로 노드 번호를 매겨서 자신의 부모, 왼쪽/오른쪽 자식을 접근하게 쉽게 합니다.

즉, [0, 7]은 1번, [0, 3]은 2번, [4, 7]은 3번, [0, 1]은 4번...

그리고 리프 노드들은 8, 9, 10, ... , 15번으로 N ~ 2N-1번의 번호를 얻게 됩니다. 번호는 곧 인덱스라고 생각해도 좋습니다.

## BOJ[2042] : 구간합구하기

> https://www.acmicpc.net/problem/2042


이 문제를 살펴봅시다. 값이 N개이고 쿼리가 2개의 형태로 들어옵니다.

하나는 b번째 값을 c로 바꾸라는 것이고 하나는 구간 [b, c]에 속한 모든 원소의 합을 구하란 거네요.

만약 두 번째 쿼리만 있었다면 구간 합 배열(https://kks227.blog.me/220787178657)만을 사용하여 문제를 풀 수 있었을 것인데, 문제는 도중에 값을 바꾸는 쿼리가 들어온다는 점...

이 때문에 값을 바꿀 때마다 구간 합 배열을 O(N)으로 갱신해줘야 해서 쿼리 개수를 Q(=M+K)라 하면 전체 **O(NQ)**의 시간복잡도를 피할 수 없게 됩니다. 즉 시간초과...

그래서 좀 더 최적화된 자료구조가 필요하게 되었습니다!! 그것이 세그먼트 트리입니다.



세그먼트 트리는 구간 정보로 사용자가 원하는 아무 값이나 저장해 두는데,

가장 대표적인 것이 **구간에 속한 원소들의 합**, 구간에 속한 원소들의 곱, 구간 원소들 중 최댓값, 구간 원소들 중 최솟값 등이 있습니다. 즉...

![image-20200914160527201](https://user-images.githubusercontent.com/58545240/93054884-09a3fc00-f6a5-11ea-847a-69ff8be40b83.png)

위의 문제를 풀기 위해 자신이 포함하는 구간의 원소의 합을 갖고 있으면 이렇게 됩니다.

여기서 만약 구간 전체의 합을 알고 싶다면 바로 루트를 보면 됩니다. 14네요.

구간 [0, 3]의 합은? 그에 해당하는 노드가 2번입니다. 그 값이 9네요.

구간 [4, 5]는? 6번 노드를 보면 됩니다. 그 값이 4네요.

구간 [6, 6]은? 이건 리프 노드인 14번 노드의 값이자 그냥 배열의 6번 원소인 0이 되겠습니다.



이렇게 구간에 딱 맞춰 대응하는 노드가 있으면 그 노드의 값으로 구간 합을 구할 수 있음은 쉽게 알 수 있습니다.

그런데 하나의 노드로 표현할 수 없는 구간은? 예를 들면 [0, 2]나 [3, 6]은 어떻게 할까요?

![image-20200914160540717](https://user-images.githubusercontent.com/58545240/93054893-0dd01980-f6a5-11ea-90d0-444c55eb5208.png)

구간 [0, 2]의 합을 구하는 방법입니다.

보시면 구간을 여러 개로 쪼개서 트리상의 노드들로만 표현이 가능하게 해버렸죠.

[0, 1]과 [2, 2] 구간으로 쪼개서 그 각각의 합을 구했습니다.

![image-20200914160554683](https://user-images.githubusercontent.com/58545240/93054907-1163a080-f6a5-11ea-9990-733bfae13040.png)

구간 [3, 6]의 합을 구하는 방법입니다. 이번엔 저 빨간색 노드들의 합을 더하면 됩니다.

![image-20200914160605294](https://user-images.githubusercontent.com/58545240/93054916-16285480-f6a5-11ea-9a9c-8bb8882b6fb3.png)

구간 [2, 7]의 합입니다.

지금까지 예시를 보면 모두 구간을 여러 개로 쪼개고, 동시에 그 쪼개서 생기는 구간의 개수도 최소화하고 있습니다.

즉 어떤 넓은 구간이 원래 합을 구하려는 구간에 포함된다면 그 구간은 더 쪼개지 않고 바로 자신에 대응하는 노드 값을 보태버리면 됩니다.

만약 구간 [0, 1]과 [2, 3]이 동시에 목표 구간에 포함된다면 그 둘을 합친 구간 [0, 3] 또한 해당하는 노드가 있으므로 [0, 3] 구간을 쪼개지 않고 그 노드 값으로 처리하겠다는 거죠.



이걸 재귀함수로 구현할 수 있습니다. 먼저 루트부터 내려가면서, 구하려는 구간에 이 노드가 완전히 포함되면 자신의 값을 리턴하고, 아니면 구간을 양쪽으로 쪼개서 각각 재귀호출해 두 함수의 결과를 더하면 됩니다.

만약 이 노드의 구간이 목표 구간과 전혀 겹치지 않으면 더 탐색할 필요없이 역시 종료해버리면 됩니다.



구간 [L, R]에서 목표 구간에 속하는 원소들의 합을 구하는 함수를 sum(L, R)이라 해봅시다.

세 번째 그림을 예로 들어보자면 우리가 목표로 하는 구간이 [2, 7]이고, 맨 처음엔 루트인 [0, 7]부터 시작합니다. 즉, sum(0, 7)을 불러서 시작합니다.

호출된 sum(0, 7)은 이런 행동을 합니다. [0, 7]이 [2, 7]에 포함되지는 않으므로 구간을 양분해 [0, 3], [4, 7]로 나누어서 각각을 재귀호출해 그 결과를 더하도록 합시다. 즉, sum(0, 3)과 sum(4, 7)을 부릅니다.

sum(0, 3)은 마찬가지로 sum(0, 1)과 sum(2, 3)을 부릅니다.

sum(0, 1)은 목표 구간 [2, 7]과 **겹치는 구간이 전혀 없으므로** 0을 리턴하며 종료합니다.

sum(2, 3)은 목표 구간 [2, 7]에 **완전히 포함되므로** 자신의 값 4를 리턴합니다.

sum(0, 3)은 따라서 0+4 = 4를 리턴합니다.

sum(4, 7) 또한 [2, 7]에 완전히 포함되므로 바로 5를 리턴합니다.

최종적으로 sum(0, 7) = sum(0, 3) + sum(4, 7) = 4 + 5 = 9가 됩니다.



대충 이런 식으로 재귀호출이 이루어집니다.

```c++
 int sum(int L, int R, int nodeNum, int nodeL, int nodeR){
        if(R < nodeL || nodeR < L) return 0;
        if(L <= nodeL && nodeR <= R) return arr[nodeNum];
        int mid = (nodeL + nodeR) / 2;
        return sum(L, R, nodeNum*2, nodeL, mid) + sum(L, R, nodeNum*2+1, mid+1, nodeR);
 }
```

매개변수가 좀 많은데 종만북의 코드를 거의 그대로 옮긴 겁니다.

nodeNum은 현재 보고 있는 노드의 번호(인덱스)이고 nodeL과 nodeR은 그 노드가 포함하는 구간을 의미합니다. L과 R이 본래 우리가 구하고자 하는 구간이고요.

따라서 구간 [L, R]의 합을 구하고 싶을 때는 맨 처음에 **sum(L, R, 1, 0, N-1)**을 호출해야 합니다. N이 값의 개수, 즉 전체 구간의 크기입니다. 루트 번호는 1이구요.



첫 번째 줄은 [nodeL, nodeR]과 [L, R]이 **전혀 안 겹치는 경우.** 바로 0을 리턴하는데 0은 덧셈에 영향을 미치지 않죠.

두 번째 줄은 [nodeL, nodeR]이 [L, R]에 **완전히 포함되는 경우.** 바로 자신의 값을 리턴하면 됩니다. 이 경우는 구간 크기가 1인 경우도 자동으로 포함합니다.

세 번째~네 번째 줄이 그 외의 경우로 현재 노드의 구간을 양분해 각각을 재귀호출해서 더하는데, 이건 이 구간을 2등분하면 왼쪽 것은 이 노드의 왼쪽 자식, 오른쪽 것은 이 노드의 오른쪽 자식이 표현하고 있다는 걸 잘 이용한 형태입니다.

저의 경우는 구간 [L, R]이 아니라 구간 [L, R)의 형태로 짜서(즉, R은 구간에 포함 안 됨) 몇몇 식들이 조금 다릅니다.



자, 그럼 이 sum 함수의 시간복잡도가 얼마일까요?

기껏 이렇게 어려운 방법으로 구간 합을 구하고 있으니 적어도 O(N)보다는 적기를 기대합니다.

정답부터 말씀드리자면 **O(logN)**이고, 이는 트리의 높이가 O(logN)이라서 최대 그만큼의 연산을 하리라는 짐작에서 나옵니다.

그런데 간혹 구간이 엄청 절묘하고 예술적으로 뽑혀서 엄청 많은 수의 재귀호출을 해야 할 때가 있지 않을까요? O(logN)의 범주를 초과할 정도로...



**그럴 수는 없다**는 것이 중요합니다.

어떤 구간을 여러 개로 쪼개서 각 구간이 전부 세그먼트 트리상의 어떤 노드의 구간과도 같지 않게, 최대한 재귀호출이 많이 되게 만들어봅시다. 얼마나 많이 되도록 만들 수 있을까요?

이렇게 생각해 봅시다. 여태까지 예제에서 하나의 깊이에 두 번의 호출이 시도되는 경우는 봤습니다. 두 번째 그림([3, 6]의 합)의 깊이 4에서 [3, 3]과 [6, 6]이 불러진 게 그 예죠.

그럼 하나의 깊이에서 3개 이상의 호출이 시도될 수 있을까요?

그러려면 어떻게 해야 할까요? 어떤 연속된 하나의 구간을 3등분해서 각 구간이 호출되도록 만들어 봅시다.

![image-20200914160638046](https://user-images.githubusercontent.com/58545240/93054945-22acad00-f6a5-11ea-993a-d749bb895342.png)

예를 들면, 구간 [0, 5]의 합을 구하고 싶은데 깊이를 3으로 잡고 이걸 저렇게 [0, 1], [2, 3], [4, 5] 3개의 구간으로 나눠서 호출해 해결했다고 가정합니다.

근데... 이거 불가능하죠. 왜냐면 [0, 1]과 [2, 3]을 합한 구간 [0, 3]을 한번에 포함하는 상위의 노드가 엄밀히 존재하고 있습니다! 따라서 저런 호출은 절대 일어날 수가 없습니다.

이런 식으로 어떤 경우를 생각해봐도 **절대 하나의 깊이에서 3개의 호출이 일어날 일이 없습니다.**

따라서 호출은 많이 되어봐야 2*O(logN)번임을 알 수가 있죠!!



그럼 이제 우리를 이렇게 힘들게 만든, 어떤 원소의 값을 바꾸는 경우를 생각해 봅시다.

보통 update라는 이름의 함수나 연산으로 표현합니다.

만약 우리가 2번째 원소 -3을 어떤 값, 예를 들면 1로 바꾸었다고 합시다. 그럼 어떤 노드들의 값도 덩달아 바뀌어야 할까요?

![image-20200914160654341](https://user-images.githubusercontent.com/58545240/93054961-2809f780-f6a5-11ea-91b3-725e38cd829f.png)

이 노드들이죠. 2번 원소를 포함하는 구간이 있는 노드들!

이러한 노드는 각 깊이마다 단 1개이며, 그러므로 총 O(logN)개의 노드들의 값이 바뀌고

이건 리프 노드 값을 갱신한 후 부모를 찾아가며 루트까지 갱신을 계속해주면 됩니다.

그렇죠. 갱신에 필요한 시간이 **O(logN)**입니다!!!

원소 값을 바꾸는 연산, 구간 합을 구하는 연산 둘 다 시간복잡도가 O(logN)이므로, 값 개수 N과 쿼리 개수 Q가 주어지면 시간복잡도가 **O(QlogN)**이 됩니다!! 드디어 세그먼트 트리의 저력이 드러납니다.

```c++
// update
 void update(int i, int val){
        i += size;
        arr[i] = val;
        while(i > 1){
            i /= 2;
            arr[i] = arr[i*2] + arr[i*2+1];
        }
 }
```

update 함수는 이렇게 구현합니다. i번째 원소를 val로 갱신하라.

먼저 해당 원소가 있는 세그먼트 트리상의 진짜 노드 번호를 찾아야 합니다.

이 코드에서는 size가 값의 개수(2^K 꼴)라 가정했을 경우이고 그렇다면 size를 더해주면 그 인덱스가 되겠죠.

만약 size가 세그먼트 트리의 노드 개수였다면 size/2를 더해주면 될 것이구요.

이렇게 시작해서 i가 루트에 다다를 때까지 차례대로 부모를 방문해가며 값들을 갱신합니다. 자신의 왼쪽 자식 노드 + 자신의 오른쪽 자식 노드 값으로 갱신하면 됩니다.



맨 처음에 배열의 값을 초기화할 때도 이렇게 매번 업데이트 함수를 불러줘야 세그먼트 트리가 온전히 제작되겠죠.

아니면 초기화할 때만 리프 노드 값들만 먼저 조작해두고 그 다음 한 번에 모든 노드의 값을 깊은 곳부터 구해놓으면 연산 횟수가 줄어듭니다.

또한 세그먼트 트리의 특성상 **그 크기를 2^K 꼴로 맞춰주는 게 필수적**이므로 그러한 최소의 값을 찾아서 크기를 재조정해 주는 전처리도 필요합니다.



마지막으로, 필수적일 정도로 필요한 경우가 많지는 않으나 최적화에 꽤 도움을 주는 연산이 하나 더 있습니다. 바로 구축(construct) 연산입니다.

리프 노드들의 값을 미리 준 후, 이 값들로 세그먼트 트리를 구축하는 것인데 간단합니다.

```c++
void construct(){
    for(int i = MAX_ST/2-1; i > 0; --i)
        arr[i] = arr[i*2] + arr[i*2+1];
}
```

인덱스 [MAX_ST/2, MAX_ST)에 리프 노드들의 값이 있다고 할 때, 그 바로 위 노드들부터 인덱스가 감소하는 순으로 배열의 값을 구하는 것입니다.

값을 구할때 자신의 두 자식의 배열 값을 더해야 하는데, 인덱스가 감소하는 순으로 구하면 항상 제대로 된 값을 구할 수 있습니다.

각 노드를 한 번씩만 보니까 **O(N)**만에 세그먼트 트리를 만들 수 있습니다. 그냥 리프 노드를 하나하나 update하는 식으로도 구축은 가능하지만 **O(NlogN)**이 걸리게 됩니다. 확실히 이것보다는 빠르죠.



여튼간 이렇게 해서 구간 합, 구간 최댓값 등의 구간 정보를 매우 빠르게 구할 수 있게 되었습니다!

학교 자료구조나 알고리즘 커리큘럼에서는 잘 등장하지 않는 자료구조지만, 제가 상당히 재미있게 생각하는 자료구조이기도 하고 유용할 때도 많습니다.

## BOJ[12015] : 가장 긴 증가하는 부분 수열2


세그먼트 트리를 활용할 수 있는 것 중 하나가 **LIS**(Longest Increasing Sequence)입니다.

어떤 수열에서 증가하는 부분 수열을 뽑을 때 그 최대 길이인데요... 이거 O(N^2) DP로 구할 수 있었죠!

그러나 인생은 만만치 않아서 대부분 O(NlogN) 알고리즘이 필요할 정도로 큰 N을 줘버립니다.

LIS를 구하는 방법은 이것 하나뿐이 아니라 이분 탐색을 사용하는 방법도 존재하는데(종만북에 짤막하게 나와 있음),

굳이 세그먼트 트리를 사용한다면 이렇게 구현할 수 있습니다.



방법은 이러합니다. A[i] = x 값들을 모두 받아서 각각 (x, i) pair들을 만든 후 x 값에 대해 오름차순 정렬합니다.

이 문제에서는 그렇지 않지만 일단은 **x 값들은 전부 구분된다**고 가정해보죠.

어쨌든 정렬하면 작은 x값부터 훑으면서 그게 등장하는 인덱스 i를 알 수 있게 됩니다.

이제 작은 x값부터 순회하면서, **A[i]=x인 i에 대해 구간 [0, i]에 지금까지 존재하는 LIS 길이 +1이 x로 끝나는 LIS 길이**입니다.

이렇게 순회하면서 등장하는 가장 큰 길이가 답입니다.



이 방법을 구현하려면 이렇게 하면 됩니다.

**구간 최댓값**을 구하는 세그먼트 트리를 사용합니다. 처음엔 모든 자리가 0으로 초기화되어 있습니다.

그리고 작은 x부터 순회하면서 A[i]=x인 **구간 [0, i]에서 최댓값을 구하고**, 그 값+1을 세그먼트 트리의 인덱스 i인 리프 노드 값으로 **업데이트**합니다.

이러면서 등장하는 값들 중 제일 큰 게 정답이고요.



수열이 [6, 1, 2, 7, 8, 3, 5, 4]라고 해봅시다.

![image-20200914160812042](https://user-images.githubusercontent.com/58545240/93054979-2f310580-f6a5-11ea-9f0a-c8c9f679acf6.png)

수열에 등장하는 원소가 오름차순으로 [1, 2, 3, 4, 5, 6, 7, 8]이네요.

맨 처음엔 A[i]=1인 i를 방문하게 되고 그 i는 1입니다.

먼저 구간 [0, 1]의 최댓값을 보는데 0입니다. 따라서 1로 끝나는 LIS 길이는 1이고, 그 1 값을 인덱스 1에 업데이트해 줍니다.

![image-20200914160825767](https://user-images.githubusercontent.com/58545240/93054988-322bf600-f6a5-11ea-8a12-75b3440ecc66.png)

그 다음은 A[2]=2이므로 2를 방문하는데, 구간 [0, 2]의 최댓값이 1입니다.

따라서 2로 끝나는 LIS의 최대 길이는 2고, 이걸 또 업데이트해 줍니다.

![image-20200914160837115](https://user-images.githubusercontent.com/58545240/93055004-38ba6d80-f6a5-11ea-97a2-28d841ad7683.png)

다음, A[5]=3이므로 5를 방문해서 같은 걸 합니다.

![image-20200914160849071](https://user-images.githubusercontent.com/58545240/93055017-3ce68b00-f6a5-11ea-9ebf-546abc129b2a.png)

다음, A[7]=4.

![image-20200914160859687](https://user-images.githubusercontent.com/58545240/93055053-4839b680-f6a5-11ea-95c3-ff5cf8adc8bf.png)

그 다음은 A[6]=5니까 6을 방문하는데, 이번엔 지금까지와 달리 결과가 증가하지는 않습니다.

지금까지 보면서 알 수 있는 점은, 새로 보는 원소가 기존의 LIS 길이를 증가시키려면 **그 원소가 기존의 LIS보다 뒤에 나타나야 하죠?**

그걸 확인하는 것이나 다름없는 행위가 구간 [0, i]의 최댓값을 보는 겁니다. 이게 구간 [0, i] 안에만 속한 LIS의 최대 길이를 의미하고,

어차피 이번에 훑은 인덱스 i는 아직까지는 등장하지 않았으므로 구간 [0, i-1]의 최댓값과도 같은 결과일 겁니다.

이번에 훑은 값이 i-1보다 큰 인덱스니까 지금까지 찾은 구간 [0, i-1]에 속한 LIS보다 뒤에 있음도 보장되고,

x 값을 오름차순으로 방문 중이므로 지금까지 등장한 모든 값들보다도 크다는 것마저 보장됩니다.

따라서 LIS에 꼬리를 하나 달아 이를 1 늘일 수 있는 것이죠!

![image-20200914160913966](https://user-images.githubusercontent.com/58545240/93055072-525bb500-f6a5-11ea-8ce1-3f1acd8e6ae9.png)

그 다음은 A[0]=6이니까 0을 방문하는데 보시다시피 제일 왼쪽이라 별 실적을 못 냅니다.

![image-20200914160927712](https://user-images.githubusercontent.com/58545240/93055079-55ef3c00-f6a5-11ea-9190-224c7182a645.png)

그 다음, A[3]=7이므로 3을 방문했습니다.

여기서 지금까지 등장한 LIS는 길이 4를 갖고 있지만 원소 7과는 전혀 상관없음을 관찰할 수 있는데

그러한 LIS 마지막 원소들은 다 7보다 오른쪽에 있기 때문이죠.

그러한 결과도 지금 세그먼트 트리는 충실하게 반영하고 있습니다.

![image-20200914160939359](https://user-images.githubusercontent.com/58545240/93055091-58ea2c80-f6a5-11ea-8585-14ede7b1a0c0.png)

마지막으로 A[4]=8이므로 4를 방문. 길이가 4나 되는 증가수열을 찾아냈지만 지금까지의 결과와 같네요.

최종적으로 답은 4라는 것을 알 수 있고 이건 사실 모든 연산을 끝마친 후 세그먼트 트리의 루트 값과도 같습니다.



그런데 지금까지는 중복되는 값이 없을 거라 가정하고 한 건데 만약 중복되는 값이 존재한다면 이게 답을 제대로 못 구할 수 있습니다.

문제에서는 [2, 2]를 증가수열로 치지 않기 때문(같으면 증가한 게 아님). 따라서 여기서 0번 인덱스 방문 후 1번 인덱스를 방문하면 답이 1인데 2를 구해버릴 수 있습니다.

이걸 방지하려면 **중복되는 값들 중에서는 가장 큰 인덱스부터 방문**하면 됩니다. 정렬할 때 애초에 그렇게 정렬해두면 됩니다. 값 오름차순 -> 인덱스 내림차순으로요.



LIS 예제를 보면서 느끼셨을 수 있지만... 세그먼트 트리 역시 막상 활용하려고 하면 좀 어렵습니다.

대체로 처음부터 세그먼트 트리를 써야하게 생겼다기보다는 뭔가 알고리즘을 구상하다가 이러이러한 연산을 빨리 해야 하는데 그게 혹 세그먼트 트리에 적합할지도 모르겠다 식의 루트로 이어지는 편...

또한 LIS도 그 자체로 쓰이거나 문제의 키가 될 때가 많아서 아예 독자적인 분야로 인식됩니다. LIS를 구하는 방법이 한 가지도 아니라서요...



또한 구간 합을 구하는 데만 미친듯이 최적화되어서 시간복잡도는 같지만 실제로 더 적은 시간과 공간을 들이는 **펜윅 트리**(fenwick tree)라는 게 있으며, 2^k 꼴인 N에 대해 N+1칸의 배열만을 사용합니다.

다른 이름으로 **바이너리 인덱스 트리**(binary indexed tree, BIT)라고도 합니다.

가끔 2차원 배열~~뭐?~~에 대한 구간 합을 구해야 하는 ~~막장~~ 문제들이 존재하는데 이때는 거의 2차원 펜윅 트리를 사용하고는 합니다.

## 세그먼트 트리 관련 추천 문제

**2042번: 구간 합 구하기**

연습 문제입니다. 문제에서 경고하듯이 배열의 자료형을 int가 아니라 64비트 정수형으로 두세요.



**11505번: 구간 곱 구하기**

이번엔 구간 곱을 구하는 문제입니다. 연산의 특성상 값이 커질 수 있어서 modular를 줬으니 이것만 주의하시면 됩니다.



**2357번: 최소값과 최대값**

이번에는 값 갱신 쿼리는 안 들어오지만 구간 최소값과 최대값을 세그먼트 트리로 구해야 합니다.

즉, 세그먼트 트리를 서로 다른 용도로 2개를 만들어서 써야 합니다.



**12837번: 가계부 (Hard)**

단순한 구간 합 트리입니다. 다만 오버플로우를 피하기 위해 자료형을 64bit 정수형으로 설정해야 하고,

1번 연산 해석에 주의해야 합니다. p일의 내용이 x가 되는 것이 아니라, x가 더해지는 겁니다.



**12015번: 가장 긴 증가하는 부분 수열 2**

위에서 설명한 문제로, 최대 LIS 길이를 찾아야 합니다.



**1275번: 커피숍2**

문제 자체는 굉장히 쉬운데, **꼭 x<=y이지는 않고**, 입력만 int형 안이랬지 합도 int형 안이란 보장은 없습니다. 함정이 많은 문제.



**2268번: 수들의 합**

역시 그냥 세그먼트 트리 그 이상도 이하도 아닙니다. 다만 확인은 못해봤는데 i>j일 수도 있으니 조심하세요.



**3745번: 오름세**

LIS 여러 번 구하는 문제입니다.



**1365번: 꼬인 전깃줄**

문제에서 주어지는 입력을 배열이라 할 때 이 배열의 **LIS** 길이가 답입니다.



**3006번: 터보소트**

숫자를 1->N->2->N-1->... 순으로 방문하면서 쿼리를 날려 원하는 구간 안에 수가 몇 개 남아있는지를 세면 됩니다. 이걸 구간 합 트리로 구현할 수 있죠. 이때 세그먼트 트리 리프 노드들의 값은 1로 초기화되어 있습니다.

그 수를 원래 자리 밖으로 빼면서, 그 수가 있던 인덱스 값은 0으로 업데이트해 줍시다.



**1280번: 나무 심기 (★)**

일단 같은 위치에 나무가 여러 개 심어질 수도 있습니다.

세그먼트 트리의 리프 노드들의 경우 인덱스 i인 칸이 이 칸에 심어진 모든 나무들에 대해 x=0으로부터의 거리 합이라 합시다. 뭐... 나무가 k그루 심어져 있다면 항상 ki겠죠.

중요한 건 매번 나무를 심을 때마다 이 나무와 그 이전의 모든 나무들의 거리 합을 구하는 것.

이건 이번에 심을 나무의 위치를 x라 할 때,

왼쪽에 있는 나무들과의 거리 합은 **cnt(0, x-1)\*x - sum(0, x-1)**,

오른쪽에 있는 나무들과의 거리 합은 **sum(x+1, MAX) - cnt(x+1, MAX)\*x**

임을 도출할 수 있습니다. 이 둘의 합이 비용이고, cnt는 구간 내 심어진 나무 개수고 sum은 0으로부터의 거리 합입니다.

long long을 쓰셔야 합니다. 당연히 cnt, sum은 서로 다른 세그먼트 트리로 구해야 합니다.



**3653번: 영화 수집 (★)**

매번 자신보다 위에 쌓여 있는 영화 개수를 구해야 하는데, 맨 위에 쌓는다는 게 좀 어렵습니다. 그럼 전체 배열의 인덱스가 바뀌어버리는 것 아닌가...?

그러나 트릭을 써서 처음부터 세그먼트 트리의 원소 개수를 2N개로 잡고, i번째로 영화를 빼내서 맨 위에 쌓을 때 N+i번 위치로 옮겨버립니다.

그리고 쿼리를 날려서 이번 영화가 있는 위치를 i라 하면 구간 [i, 2N]의 영화 개수를 구간 합 트리로 세서 반환하면 됩니다.



**9345번: 디지털 비디오 디스크 (★)**

이 문제는 쿼리를 곧이곧대로 받아들이면 안 됩니다. 세그먼트 트리의 리프가 각각 그 자리에 몇 번 DVD가 있는지를 나타내면 풀기 어렵습니다.

바꿔서, 세그먼트 트리의 리프가 k번이라면 **k번 DVD가 어느 위치에 있는지**를 저장해 두면 됩니다. 매번 L~R번 DVD가 있는 위치들 중 최솟값과 최댓값이 각각 L, R인지 확인하면 문제를 풀 수 있습니다! 한 단계 발상의 전환이 필요한 문제.



**2243번: 사탕상자 (★)**

전체에서 k번째로 작은 수를 찾아야 합니다. 그리고 중복되는 값이 여러 개일 수도 있네요.

이때는 **구간 합 트리**를 마련하고, 재귀적으로 k번째 값을 찾을 때, 자신의 왼쪽 노드 구간에 포함되는 사탕 개수가 k 초과면 왼쪽 노드를 방문해 찾고, k 이하면 오른쪽 노드를 방문하는데 이때는 (k-왼쪽 자식 노드 구간의 사탕 개수)번째로 작은 수를 찾으면 됩니다. 즉



**2336번: 굉장한 학생 (★)**

문제에서 정보를 너무 많이 줘서 혼란스럽고 어렵습니다.

일단 첫 번째 시험, 두 번째 시험, 세 번째 시험 등수 순으로 오름차순 정렬해놓고 **첫 번째 시험 등수가 낮은 학생부터 차례대로 순회**합시다.

일단 이번에 순회한 학생은 지금까지 방문한 모든 학생보다 **첫 번째 시험 등수가 높으니까** 조건 하나는 아예 볼 필요가 없어졌습니다. 이제 두 번째와 세 번째 시험 등수만 신경쓰면 됩니다!

즉 지금까지 순회한 학생들 중 두 번째, 세 번째 시험 등수가 모두 자신보다 낮은 학생이 한 명이라도 있는지 알아보면 됩니다!



이것을 **구간 최솟값 트리**로 구현합니다. ~~뭐?~~

**자신보다 두 번째 시험 등수가 낮은 학생들 중, 세 번째 시험 등수 중 최솟값**을 찾는 겁니다. 최솟값이니까 이 값이 자신의 세 번째 시험 등수보다 낮으면 자신은 바로 그 학생을 능가했으므로 굉장한 학생이 되는 것이죠!

이것을 구현하려면 세그먼트 트리의 각 리프 노드들이 이런 형태면 됩니다. i번 리프 노드는 **2번째 시험 등수가 i인 학생의 3번째 시험 등수.**

이런 식으로 먼저 구간 최솟값 쿼리를 날리고, 자신의 정보도 세그먼트 트리에 업데이트시켜 가면서 문제를 풀면 됩니다.