

# Graph :fist_oncoming:

# **> Graph Algorithm - 개념과 표현**

---

## Graph

- (무방향) 그래프 G = (V, E)
  - V : 노드 혹은 정점(vertex)
  - E : 노드쌍을 연결하는 Edge 혹은 Link(간선)
  - Object들 간의 이진관계를 표현
  - n = |V|, m = |E|

![image-20200828143623650](https://user-images.githubusercontent.com/58545240/91525664-f8d15780-e93c-11ea-9dd3-c75da58350a4.png)

- 방향 그래프와 가중치 그래프
  - 방향그래프(Directed Graph) G = (V, E)
  - Edge (u, v)는 u로부터 v로의 방향을 가짐
- 가중치 그래프
  - Edge마다 가중치(weight)가 존재

### 그래프의 표현

- 인접행렬(adjacency matrix)

![image-20200828143638892](https://user-images.githubusercontent.com/58545240/91525670-fcfd7500-e93c-11ea-94c9-2bf4e7295fcb.png)

- 인접리스트(adjacency list)

  - 정점 집합을 표현하는 하나의 배열과
  - 각 정점마다 인접한 정점들의 연결 리스트

  ![image-20200828143658731](https://user-images.githubusercontent.com/58545240/91525679-0090fc00-e93d-11ea-895c-ffb31e63dda2.png)

  - 저장 공간 : O(n + m)
  - 어떤 노드 v에 인접한 모든 노드 찾기 : O(degree(v)) 시간
  - 어떤 Edge (u, v)가 존재하는지 검사 : O(degree(u)) 시간

- 방향그래프(directed graph)

  - 인접행렬은 비대칭
  - 인접 리스트는 m개의 노드를 가진다

  ![image-20200828143716749](https://user-images.githubusercontent.com/58545240/91525687-04bd1980-e93d-11ea-8c14-909aa0dbb0c4.png)

- 가중치 그래프의 인접행렬 표현

  - 엣지의 존재를 나타내는 값으로 1대신 엣지의 가중치를 저장
  - 엣지가 없을 때 혹은 대각선
    - 그때마다 상황에 따라 정의 가능
    - 특별히 정해진 규칙은 없으며, 그래프와 가중치가 의마하는 바에 따라서
    - Ex) 가중치가 거리 혹은 비용을 의미하는 경우라면 엣지가 없으면 oo(무한대), 대각선은 0
    - Ex) 만약 가중치가 용량을 의미한다면 엣지가 없을때 0, 대각선은 oo(무한대)

### 경로와 연결성

- 인접하다라는 것은 해당 경로를 거쳐서 그 노드에 도달할 수 있다라는 것이고, 연결되어 있다라는 것은 노드와 노드를 연결하는 경로가 존재할 때를 말한다.
- 무방향 그래프 G = (V, E)에서 노드 u와 노드 v를 연결하는 경로(path)가 존재할 때 v와 u는 서로 연결되어 있다고 말함
- 모든 노드 쌍들이 서로 연결된 그래프를 연결된(connected) 그래프라고 한다.
- 연결요소(connected component)

![image-20200828143739748](https://user-images.githubusercontent.com/58545240/91525707-0f77ae80-e93d-11ea-8ead-4230a975452b.png)



# **> BFS(Breadth-First Search, 너비우선탐색)**

---

## 그래프 순회

- 순회(traversal)
  - 그래프의 모든 노드들을 방문하는 일
- 대표적 두 가지 방법
  - BFS (Breadth-First Search, 너비우선순회)
  - DFS (Depth-First Search, 깊이우선순회)

### 너비우선탐색(BFS)

- BFS 알고리즘은 다음 순서로 노드들을 방문

  - L0 = {s}, 여기서 s는 출발 노드
  - L1 = L0의 모든 이웃 노드들
  - L2 = L1의 이웃들 중 L0에 속하지 않는 노드들
  - ...
  - Li = Li-1의 이웃들 중 Li-2에 속하지 않는 노드들
  - 한마디로 그래프에서 노드들을 동심원의 형태로 순회하는 방법

  ![image-20200828143917671](https://user-images.githubusercontent.com/58545240/91525714-17cfe980-e93d-11ea-9364-06bf8287dfab.png)

### 큐를 이용한 너비우선탐색

- 출발노드를 check하고 시작한다.
- 큐에 스타트 노드(1번노드)를 삽입한다.

![image-20200828143929375](https://user-images.githubusercontent.com/58545240/91525727-1dc5ca80-e93d-11ea-8cb4-646a6d314c30.png)

- whil문을 돌면서 큐가 비어있을 때까지 반복한다.
  - 큐에서 노드(v)를 하나 꺼내고
  - 꺼낸 노드의 인접노드 중, 아직 방문되지 않은(unchecked) 노드들(w)을 체크하고 큐에 넣는다.
  - 이 때, 큐에 넣는 순서는 중요하지 않다.

![image-20200828143943051](https://user-images.githubusercontent.com/58545240/91525736-23bbab80-e93d-11ea-9048-b90852d6cd2f.png)

- 다시 큐에서 노드를 하나 꺼내고(2번 노드)
- 2번 노드의 체크되지 않은 인접 노드들(4, 5번 노드)을 체크상태로 변경하고 큐에 넣는다.

![image-20200828143954255](https://user-images.githubusercontent.com/58545240/91525756-2c13e680-e93d-11ea-87d3-0eecfc835ad7.png)

- 이런 방법으로 큐가 비어있는 상태가 될때까지 반복한다.
- 최종적으로 노드를 방문한 순서는 1, 2, 3, 4, 5, 7, 8, 6 이 된다. 하지만, 이 방문 순서는 유일하지 않다. 큐에 인접노드를 삽입하는 순서에 따라 달라지기 때문이다.

### BFS pesudo code

- 그래프 G, 출발 노드 S

```java
00 BFS(G, s)
01   Q <- null;
02   Enqueue(Q, s);
03   while Q != null do
04     u <- Dequeue(Q);
05     for each v adjacent to u do
06       if v is unvisited then
07         mark v as visited;
08         Enqueue(Q, v);
```

### BFS와 최단경로

- BFS는 단순히 그래프의 모든 노드를 방문하는 것 이상의 추가적인 중요한 일을 할 수 있다. 최단 경로를 구하는 일이다.
- s에서 Li에 속한 노드까지 최댄 경로의 길이는 i이다.
  - 여기서 경로의 길이는 경로에 속한 엣지의 수를 의미한다.
- BFS를 하면서 각 노드에 대해서 최단 경로의 길이를 구할 수 있다.
- 입력
  - 방향 혹은 무방향 그래프 G = (V, E), 그리고 출발노드 s
- 출력
  - 모든 노드 v에 대해서
  - d[v] = s로 부터 v까지의 최단 경로의 길이(엣지의 개수)
  - π[V] = s로 부터 v까지의 최단경로상에서 v의 직전 노드(predecessor)
- Pseudo code
  - 02 - 04 : 모든 노드 u에 대해서 d[], π[]를 초기화
  - 05 - 06 : 스타트 노드의 d[], π[]를 설정
  - 11 : d[v] 가 -1인가를 체크하여 unvisited 체크를 구현
  - 12 - 13 : unvisited 노드에 대하여 d[v], π[v]를 저장
    - 최단경로 길이 d[v]는 u까지의 최단경로길이 d[u]를 지나오는 것이므로 d[u] + 1이 될 것이고,
    - v노드의 최단경로상에서 v의 직전노드는 u가 된다.
  - 14 : unchecked 노드만 큐에 들어갈 수 있으므로 어떤 노드도 큐에 두번 들어가지는 않는다.

```java
00 BFS(G, s)
01   Q <- null;
02   for each node u do
03     d[u] <- -1;
04     π[u] <- null;
05   d[s] <- 0;     //distance from s to s is 0
06   π[s] <- null;  //no predecessor of s
07   Enqueue(Q, s);
08   while Q != null do
09     u <- Dequeue(Q);
10     for each v adjacent to u do
11       if (d[v] == -1) then
12         d[v] <- d[u] + 1;    //distance to v
13         π[v] <- u;           //u is the predecessor of v
14         Enqueue(Q, v);
```

### 시간복잡도

- 02라인 for 의해 기본적으로 O(n)이다.
- 실제로는 08라인의 while문이 알고리즘의 시간복잡도를 결정한다.
- 기본적으로 while문이 한번 돌 때마다 큐에서 노드 하나씩 꺼내므로 while문은 최대 n번 돈다.
- 10라인의 for문은 u의 degree() 만큼 돈다. 리스트를 인접 행렬로 구현하느냐, 인접리스트로 구현하느냐에 따라 for문의 시간복잡도가 달라진다.
  - degree(v)는 어떤 한 노드 v에 실제로 인접한 노드의 수
- 그래프를 **인접 행렬로 구현할 경우** degree(v)를 찾으려면 O(n)이 든다. 따라서 인접행렬로 구현했을 떄의 while문의 시간복잡도는 O(n^2)이 된다.
- **인접 리스트로 구현할 경우**  전체 그래프에서 보면, for 문은 결국 모든 노드들의 degree() 만큼 돌 것이다. 인접리스트에서 그것은 2m이다.(무방향 그래프에서 총 엣지의 수) 시간복잡도는 O(m). 따라서, while문의 시간복잡도는 O(n + m)이 된다.
- 결과적으로 인접 리스트의 최악의경우 m이 n이 되므로 최악의 경우가 아닌 이상 인접 리스트로 구현하는 것이 좀 더 효율적이다.

### BFS로 구현한 d[]와 π[] 예시

![image-20200828144013107](https://user-images.githubusercontent.com/58545240/91525770-333af480-e93d-11ea-9e76-1cc6c00867d1.png)

### BFS 트리

- 각 노드 v와 π[v]를 연결하는 엣지들로 구성되는 트리
- BFS 트리에서 s에서 v까지의 경로는 s에서 v까지 가는 최단 경로
- 어떤 엣지도 동심원의 2개의 layer(L0에서 L2로 가지 않는다)를 건너가지 않는다.(동일 레이어의 노드를 연결하거나, 혹은 1개의 layer를 건너간다.)

![image-20200828144024810](https://user-images.githubusercontent.com/58545240/91525788-3b932f80-e93d-11ea-981b-c8c9e759cb31.png)

### 너비우선탐색: 최단 경로 출력하기

- 출발점 s에서 노드 v까지의 경로 출력하기
  - resursion으로 해결한다.
  - s에서 v까지 가는 최단 경로는 먼저 s에서 π[v]까지 가는 경로를 출력하고, v를 추가로 출력하면 된다.

```java
00 PRINT-PATH(G, s, v)
01   if v = s then
02    print s;
03  else if π[v] = null then    // 실제로 s에서 v까지 가는 경로가 없을 경우(최단경로도 없음)
04    print "no path from s to v exists";
05  else
06    PRINT-PATH(G, s, π[v]);
07    print v;
```

### 너비우선탐색(BFS) 정리

- 그래프가 connected 라면 모든 노드를 방문하게 된다. 하지만, 그래프가 **disconnected** 이거나 혹은 방향 그래프라면 BFS에 의해서 모든 노드가 방문되지 않을 수도 있다.
- disconnected 그래프의 모든 노드를 방문하려면 BFS를 반복하여 모든 노드 방문
  - 전체 노드중 unvisited 노드가 없을 때까지 BFS를 반복한다.

```java
BFS-ALL(G)
  while there exists unvisited node v
    BFS(G, V)
```

# **> DFS(Depth-First Search, 깊이우선탐색)**

---

- 이진트리의 순회 방법인 inorder, preorder, postorder 순회방법이 DFS의 이진트리 버전에 해당한다.
- lever order는 BFS의 이진트리 순회 버전이다.

## 깊이우선탐색(DFS)

- 출발점 s에서 시작한다.
- 현재 노드를 visited로 mark하고 인접한 노드들 중 unvisited 노드가 존재하면 그 노드로 간다.
- 2번을 계속 반복한다.
- 노드 8에 도달했을 때처럼 인접한 노드들중 invisited 노드가 존재하지 않는다면, unvisited인 이웃 노드가 존재하지 않는 동안 계속해서 직전 노드로 되돌아간다.
- 다시 2번을 계속 반복한다.
- 시작노드 s로 돌아오고 더 이상 갈 곳이 없으면 종료한다.

![image-20200828144256618](https://user-images.githubusercontent.com/58545240/91525796-41891080-e93d-11ea-935d-d054d8dde058.png)

- 다음과 같은 흐름으로 깊이우선순회가 이루어 진다.

![image-20200828144312828](https://user-images.githubusercontent.com/58545240/91525804-451c9780-e93d-11ea-93aa-9d4b21ebbcef.png)

### DFS, 깊이우선탐색

- 이진트리의 순회를 recursion으로 구현한 것처럼, 깊이우선탐색도 resursion으로 구현하는 것이 간명하다.
- 01 : 먼저 방문한 노드 v에 대해서 visited 체크를 하고
- 02 : v와 인접한 노드 x들에 대해서
- 03 : visited[x]가 No 이면,
- 04 : DFS(G, x)를 recursive하게 호출한다.
- 순회를 위해서 직전의 노드로 돌아가는 행동이 recursion으로 간명하게 구현된다.

```java
00 DFS(G, v)
01   visited[v] <- YES;
02   for each node x adjacent to v do
03     if visited[x] = No then
04       DFS(G, x);
```

- 그래프가 **disconnected 그래프 이거나 혹은 방향 그래프**라면 DFS에 의해서 모든 노드가 방문되지 않을 수도 있음
- DFS를 반복하여 모든 노드 방문
  - 모든 노드의 visited를 NO로 설정하고,
  - 해당 노드들을 출발노드로 하여 DFS를 호출, 연결되지 않은 그래프에 해당하는 노드는 visited가 NO로 유지되어서 DFS를 호출하게됨
- 시간복잡도
  - 첫번째 for문에 의해서 시간복잡도 O(n)은 피할 수 없고,
  - 두번째 for문에 의해서 v노드와 엣지로 이어진 노드가 visited인지를 체크한다. 따라서, 인접리스트로 표현했다면 시간복잡도는 엣지의 갯수에 비례하게 된다. O(m)
  - 최종적으로 O(n + m)의 시간복잡도를 갖는다.
  - 만약, 인접행렬로 표현했다면 인접노드의 여부를 알기위해서 전체 노드의 수 만큼 검색해야 하므로 O(n)이므로, O(n^2)의 시간복잡도를 갖는다.

```java
DFS-ALL(G)
  for each v in V
    visited[v] <- NO;
  for each v in V
    if (visited[v] = no) then
      DFS(G, v)
```



# **> 위상정렬(Topological Sort)**

---

> **어떤 일을 하는 순서를 찾는 알고리즘**
>
> => 즉, 방향 그래프에 존재하는 각 정점들의 선행 순서를 위배하지 않으면서 모든 정점을 나열하는 것

## 위상정렬의 특징

![image-20200911102426695](https://user-images.githubusercontent.com/58545240/92840886-9daf6280-f41c-11ea-99cd-f2b586831c2d.png)

- 하나의 방향 그래프에는 여러 위상 정렬이 가능하다.
- 위상 정렬의 과정에서 선택되는 정점의 순서를 위상 순서(Toplogical Order)라 한다.
- 위상 정렬의 과정에서 그래프에 남아 있는 정점 중에 진입 차수가 0인 정점이 없다면, 위상 정렬 알고리즘은 중단되고 이러한 그래프로 표현된 문제는 실행이 불가능한 문제가 된다.

=> 위상정렬이 가능하려면 ***DAG(Directed Acyclic Graph, 방향성이 있으며 사이클이 없는 그래프)***여야 한다.

1. 말 그대로 두 노드 `A`, `B` 사이에 A->B 같은 관계가 성립되어야 하며
2. A->B, B<-A 처럼 그래프들 사이에 사이클이 없어야 한다.

=> 위상정렬은 DFS를 사용하여 구현하거나 `indegree`배열을 사용하여 구현할 수 있다.(**indegree**가 가장 많이 쓰이고 간단하다)

- `List<List<Integer>> array` : 그래프의 관계를 표현하기 위한 2차원 인접 리스트
- `int[] indegree` : 해당 노드를 가리키는 간선 갯수를 담기 위한 배열
- `Queue<Integer> q` : `indegree` 값이 0이 된 노드들을 담기 위한 `Queue`
- `Queue<Integer> result` : `Queue`에서 꺼내져 결과로 출력하기 위해 담는 결과 `Queue`

## 위상정렬의 동작방식

![image-20200911104241195](https://user-images.githubusercontent.com/58545240/92840908-a4d67080-f41c-11ea-9f6e-861b6abf33da.png)

1. 진입차수가 0인 정점(즉, 들어오는 간선의 수가 0)을 선택
   - 진입차수가 0인 정점이 여러개 존재할 경우 어느 정점을 선택해도 무방하다.
   - 초기에 간선의 수가 0인 모든 정점을 큐에 삽입
2. 선택된 정점과 여기에 부속된 모든 간선을 삭제
   - 선택된 정점을 큐에서 삭제
   - 선택된 정점에 부속된 모든 간선에 대해 간선의 수를 감소
3. 위의 과정을 반복해서 모든 정점이 선택, 삭제되면 알고리즘 종료



- 위상 정렬은 정해진 결과 값이 없다. **중요한 점은 화살표가 가리키는 순서는 꼭 지켜져야 한다는 것!**

```bash
1 - 2 - 5 - 4 - 6
1 - 2 - 4 - 6
1 - 3 - 4 - 6
1 - 3 - 7
```

이 순서는 어떤 정렬 결과가 나오더라도 변하지 않을 것이다.

## 코드

```java
import java.util.*;
public class TopologicalSort{
    static int n;
    static int e;
    
    public static void main(String[] args){
        n = 7;	// 정점 갯수
        e = 9;	// 간선 갯수
        int[] indegree = new int[n+1];
        List<List<Integer>> array = new ArrayList<List<Integer>>();
        
        for(int i=0; i<n+1; i++){
            array.add(new ArrayList<Intger>());
        }
        
        // 간선목록 v1 -> v2
        int[] v1 = {1, 1, 2, 4, 3, 3, 5, 2, 5};
        int[] v2 = {2, 3, 5, 6, 4, 7, 6, 4, 4};
        
        /*
        1. v1 -> v2 인접리스트 생성
        2. v2를 가리키는 노드 갯수 indegree 증가
        */
        for(int i=0; i<e; i++){
            int c1 = v1[i];
            int c2 = v2[i];
            
            array.get(c1).add(c2);
            indegree[c2]++;
        }
        topologicalSort(indegree, array);
    }
    
    public static void topologicalSort(int[] indegree, List<List<Integer>> graph){
        Queue<Integer> q = new LinkedList<Integer>();
        Queue<Integer> result = new LinkedList<Integer>();
        
        // 큐에 indegree가 0인 노드 담기
        for(int i=1; i<n; i++){
            if(indegree[i]==0){
                q.offer(i);
            }
        }
        
        /*
        1. 큐에서 값을 꺼내며 해당 노드가 가리키는 노드의 indegree를 1 감소
        2. 만약 indegree가 0이 된다면 큐에 넣기
        3. 큐가 빌때까지 반복
        */
        while(!q.isEmpty()){
            int node = q.poll();
            result.offer(node);
            for(Integer i : graph.get(node)){
                indegree[i]--;
                
                if(indegree[i] == 0){
                    q.offer(i);
                }
            }
        }
        System.out.println(result);
    }
}
```

## 위상정렬 관련 문제

1. 각각의 작업이 완료되어야만 끝나는 프로젝트

2. 선수 과목

   - 큐를 이용한 위상정렬

     [줄 세우기 - 백준 2252번](https://www.acmicpc.net/problem/2252)

   - 우선순위 큐를 이용한 위상정렬

     [문제집 - 백준 1766번](https://www.acmicpc.net/problem/1766)

   - 여러 위상순서 중 가장 짧게 걸리는 위상 정렬 방법 구하기

     [작업 - 백준 2056번](https://www.acmicpc.net/problem/2056)

     [게임개발 - 백준 1516번](https://www.acmicpc.net/problem/1516)

## 참고

https://bcp0109.tistory.com/entry/%EC%9C%84%EC%83%81%EC%A0%95%EB%A0%AC-Topological-Sort-Java?category=848939

https://gmlwjd9405.github.io/2018/08/27/algorithm-topological-sort.html



# **> 유니온 파인드(Union-Find)**

---

> 그래프 알고리즘으로 **합집합 찾기 알고리즘**이다.
>
> **상호 배타적 집합(Disjoint-set)**이라고도 한다.

*Disjoint Set이란 서로 중복되지 않는 부분집합들로 나눠진 원소들에 대한 정보를 저장하고 조작하는 자료구조이다.*

## 유니온파인드의 특징

**Union-Find**란 Disjoint Set을 표현할 때 사용하는 알고리즘이다.

- 집합을 구현하는 데는 비트 벡터, 배열, 연결 리스트를 이용할 수 있으나 그중 가장 효율적인 **트리 구조**를 이용하요 구현한다.
- **`make-set(x)`**
  - 초기화
  - x를 유일한 원소로 하는 새로운 집합을 만든다.
- **`union(x,y)`**
  - 합하기
  - x가 속한 집합과 y가 속한 집합을 합친다.
- **`find(x)`**
  - 찾기
  - x가 속한 집합의 대표값(루트 노드값)을 반환한다. 즉 x가 어떤 집합에 속해 있는지 찾는 연산



여러 노드가 존재 할 때 두 개의 노드를 선택해서, 현재 두 노드가 서로 같은 그래프에 속하는지 판별하는 알고리즘이다.

총 2가지의 연산으로 이루어져 있다.

- **Find** : x가 어떤 집합에 포함되어 있는지 찾는 연산
- **Union** : x와 y가 포함되어 있는 집합을 합치는 연산

## 유니온 파인드의 동작방식

![image-20200911110302450](https://user-images.githubusercontent.com/58545240/92844373-bde12080-f420-11ea-8fc9-3855c3cf3399.png)

위와 같이 모두 연결되지 않고 각자 자기 자신만을 집합의 원소로 가지고 있을 때, 모든 값이 자기 자신을 가리키도록 만든다.

**`i` : 노드번호, `P[i]`: 부모 노드 번호**를 의미하며, 즉 자기 자신이 어떤 부모에 포함되어 있는지를 의미한다.

정리하면 **`Parent[i] = i`**

![image-20200911110501896](https://user-images.githubusercontent.com/58545240/92844392-c3d70180-f420-11ea-8789-6ec6c622624c.png)

**`Union(1,2), Union(3,4)`**를 해주어 위와 같이 노드를 연결해준다.

![image-20200911110550615](https://user-images.githubusercontent.com/58545240/92844412-c8031f00-f420-11ea-9f4e-68a91a05871d.png)

위와 같이 표로 표현이 된다. 2번째 인덱스에 '1'이 들어가고, 4번인덱스에 '3'이 들어간다.

**이와 같이 부모를 합칠 때는 일반적으로 더 작은 값 쪽으로 합친다.** 이것을 **합칩(Union) 과정**이라고 한다.

![image-20200911110639947](https://user-images.githubusercontent.com/58545240/92844427-cc2f3c80-f420-11ea-903e-2c60e02518a4.png)

![image-20200911110704352](https://user-images.githubusercontent.com/58545240/92844438-d05b5a00-f420-11ea-8154-8b330530555e.png)

1,2,3이 연결될 때는 위와 같은 표로 표현이 된다.

1과 3은 부모가 다르기 때문에 1과 3이 연결되었는지 파악하기 힘들다. 따라서 **재귀함수**가 사용된다.

3인 부모인 2를 먼저 찾고, 2인 부모인 1을 찾아 결과적으로 3의 부모는 1이되는 것을 파악하는 것이다.

**Union**의 과정이 수행된 후에는 다음과 같은 표로 바뀌게 된다.

![image-20200911110828805](https://user-images.githubusercontent.com/58545240/92844456-d6e9d180-f420-11ea-8b72-6d6ca2dc68e9.png)

결국 1,2,3의 부모는 모두 1이기 때문에 이 세가지 노드는 모두 같은 그래프에 속한다는 것을 알 수 있다.

해당 경로를 바꿔주는 과정은 아래와 같은 그림으로 변하게 된다.

![image-20200911110902955](https://user-images.githubusercontent.com/58545240/92844470-db15ef00-f420-11ea-8c16-644d71962d64.png)

## 유니온파인드의 최적화

### -최악의 상황

![image-20200911112959528](https://user-images.githubusercontent.com/58545240/92856933-fdaf0480-f42e-11ea-9fe9-9b83690f09a3.png)

- **트리구조가 완전 비대칭인 경우**
- 연결 리스트 형태
- 트리의 높이가 최대가 된다
- 원소의 개수가 N일 때, 트리의 높이가 N-1이므로 union과 find(x)의 시간 복잡도가 모두 O(N)이 된다.
- 배열로 구현하는 것 보다 비효율적이다.

### - find 연산 최적화

![image-20200911113107274](https://user-images.githubusercontent.com/58545240/92856954-01db2200-f42f-11ea-9091-eaf36fca95ec.png)

- **경로 압축(Path Compression)**
- 시간 복잡도 : O(logN)

```java
// 초기화
int root[MAX_SIZE];
for(int i=0; i<MAX_SIZE; i++){
    root[i]= i;
}

// find(x) : 재귀 이용
int find(int x){
    if(root[x] == x)
        return x;
    else P
        // 경로 압축
        // find하면서 만난 모든 값의 부모 노드를 root로 만든다.
        return root[x] = find(root[x]);
}
```

### - union 연산 최적화

- **union-by-rank(union-by-height)**
- rank에 트리의 높이를 저장한다.
- 항상 높이가 더 낮은 트리를 높은 트리 밑에 넣는다.

```java
//초기화
int root[MAX_SIZE];
int rank[MAX_SIZE];	// 트리의 높이를 저장할 배열
for(int i=0; i<MAX_SIZE; i++){
    root[i] = i;
    rank[i] = 0;	// 트리의 높이 초기화
}

// find(x): 재귀이용
int find(int x){
    // 위와 동일
}

// union1(x, y) : union-by-rank 최적화
void union(int x, int y){
    int x = find(x);
    int y = find(y);
    
    // 두 값의 root가 같으면(이미 같은 트리) 합치지 않는다.
    if(x == y)
        return;
    
    // "union-by-rank 최적화"
    // 항상 높이가 더 낮은 트리를 높이가 높은 트리 밑에 넣는다. 즉 높이가 더 높은 쪽을 rank로 삼음
    if(rank[x] < rank[y]){
        root[x] = y;	// x의 root를 y로 변경
    } else {
        root[y] = x;	// y의 root를 x로 변경
        
        if(rank[x] == rank[y])
            rank[x] ++;	// 만약 높이가 같다면 합친 후 (x의 높이 + 1)
    }
}
```

**두 원소가 속한 트리의 전체 노드의 수를 구하는 경우**

```java
// union2(x, y): 두원소가 속한 트리의 전체 노드의 수 구하기
int nodeCount[MAX_SIZE];
for(int i=0; i<MAX_SIZE; i++){
    nodeCount[i] = i;
}

int union2(int x, int y) {
    int x = find(x);
    int y = find(y);
    
    // 두 값의 root가 같지 않으면
    if(x != y){
        root[y] = x;	// y의 root를 x로 변경
        nodeCount[x] += nodeCount[y];	// x의 node 수에 y의 node 수를 더한다.
        nodeCount[y] = 1;	// x에 붙은 y의 node 수는 1로 초기화
    }
    return nodeCount[x];	// 가장 root의 node 수 반환
}
```



## 코드

```java
public class UnionFind{
    public static int[] parent = new int[1000001];
    
    public static int find(int x){
        if(x == parent[x])
            return x;
        else
            return parent[x] = find(parent[x]);
    }
    
    public static void union(int x, int y){
        int x = find(x);
        int y = find(y);
        //같은 부모를 가지고 있지 않을 때
        if(x != y){
            //y가 x보다 크다는 것을 가정하면
            parent[y] = x;
            // 더 작은 값으로 넣어 줄 때 다음과 같이 표현
            /*
            if(x < y) parent[y] = x;
            else parent[x] = y;
            */
        }
    }
    
    //같은 부모 노드를 가지는지 확인
    public static boolean isSameParent(int x, int y){
        x = find(x);
        y = find(y);
        if(x == y)
            return true;
        else
            return false;
    }
    
    public static void main(String[] args){
        for(int i=1; i<=8; i++){
            parent[i] = i;
        }
        union(1,2);
        union(2,3);
        System.out.println("1과 3은 연결되어 있나요? -> "+isSameParent(1,3));
    }
}
```

## 유니온파인드 관련 문제

1. 전체 집합이 있을 때 구성원소들이 겹치지 않도록 **분할하는 데** 자주 사용된다.

   - **Kruskal MST 알고리즘**에서 새로 추가할 간선의 양끝 정점이 같은 집합에 속해 있는지(사이클 형성 여부 확인)에 대해 검사하는 경우

   - 초기에 {0}, {1}, {2}, ... {n}이 각각 n+1개의 집합을 이루고 있다. 여기에 합집합 연산과, 두 원소가 같은 집합에 포함되어 있는지를 확인하는 연산을 수행하는 경우

     [집합의 표현 - 백준 1717번](**[https://www.acmicpc.net/problem/](https://www.acmicpc.net/problem/1717)1717**)

   - 어떤 사이트의 친구 관계가 생긴 순서대로 주어졌을 때, 가입한 두 사람의 친구 네트워크에 몇 명이 있는지 구하는 프로그램을 작성하는 경우

     [친구 네트워크 - 백준 4195번](https://www.acmicpc.net/problem/4195)

그외

[바이러스 - 백준 2606번](https://www.acmicpc.net/problem/2606)

[섬 연결하기 - 프로그래머스 42861번](https://programmers.co.kr/learn/courses/30/lessons/42861)

## 참고

https://brenden.tistory.com/33

# **> 스패닝 트리(ST)**

---

> **그래프 내의 모든 정점을 포함하는 트리**

- **Spanning Tree = 신장 트리 = 스패닝 트리**
- Spanning Tree는 그래프의 최소 연결 부분 그래프이다.
  - 최소 연결 = 간선의 수가 가장 적다.
  - n개의 정점을 가지는 그래프의 최소 간선 수는 (n-1)개이고, (n-1)개의 간선으로 연결되어 있으면 필연적으로 트리 형태가 되고 이것이 바로 Spanning Tree가 된다.
- 즉, 그래프에서 일부 간선을 선택해서 만든 트리

## 스패닝 트리의 특징

![image-20200911140355155](https://user-images.githubusercontent.com/58545240/92866780-e2e28d00-f43a-11ea-90c1-646b51f53c81.png)

- DFS, BFS를 이용하여 그래프에서 신장 트리를 찾을 수 있다.
  - 탐색 도중에 사용된 간선만 모으면 만들 수 있다.
- 하나의 그래프에는 많은 신장 트리가 존재할 수 있다.
- Spanning Tree는 트리의 특수한 형태이므로 **모든 정점들이 연결**되어 있어야 하고 **사이클을 포함해서는 안된다.**
- 따라서 Spanning Tree는 그래프에 있는 **n개의 정점을 정확히 (n-1)개의 간선으로 연결**한다.

## 스패닝 트리의 사용 사례

*통신 네트워크 구축*

![image-20200911140530755](https://user-images.githubusercontent.com/58545240/92866800-e70eaa80-f43a-11ea-9a87-534613ba6c65.png)

- 예를 들어, 회사 내의 모든 전화기를 가장 적은 수의 케이블을 사용하여 연결하고자 하는 경우
- n개의 위치를 연결하는 통신 네트워크를 최소의 링크(간선)를 이용하여 구축하고자 하는 경우, 최소 링크의 수는 `(n-1)`개가 되고, 따라서 Spanning Tree가 가능해진다.

# **> 최소 신장 트리(MST)**

---

> **Minimum Spanning Tree**
>
> **Spanning Tree 중에서 사용된 간선들의 가중치 합이 최소인 트리**

- 각 간선의 가중치가 동일하지 않을 때 단순히 가장 적은 간선을 사용한다고 해서 최소 비용이 얻어지는 것은 아니다.
- MST는 간선에 가중치를 고려하여 최소 비용의 Spanning Tree를 선택하는 것이다.
- 즉, 네트워크(가중치를 간선에 할당한 그래프)에 있는 모든 정점들을 가장 적은 수의 간선과 비용으로 연결하는 것이다.

## MST의 특징

1. 간선의 가중치의 합이 최소여야 한다.
2. `n`개의 정점을 가지는 그래프에 대해 반드시 `(n-1)`개의 간선만을 사용해야 한다.
3. 사이클이 포함되어서는 안된다.

## MST의 사용사례

*통신망, 도로망, 유통망에서 길이, 구축비용, 전송시간 등을 최소로 구축하려는 경우*

- 도로건설
  - 도시들을 모두 연결하면서 도로의 길이가 최소가 되도록 하는 문제
- 전기회로
  - 단자들을 모두 연결하면서 전선의 길이가 가장 최소가 되도록 하는 문제
- 통신
  - 전화선의 길이가 최소가 되도록 전화 케이블 망을 구성하는 문제
- 배관
  - 파이프를 모두 연결하면서 파이프의 총 길이가 최소가 되도록 하는 문제

## MST의 구현방법

### 1. Kruskal MST 알고리즘

> **탐욕적인 방법(greedy method)**을 이용하여 네트워크(가중치를 간선에 할당한 그래프)의 모든 정점을 최소 비용으로 연결하는 최적해를 구하는 것.

- MST가

  1. 최소 비용의 간선으로 구성되고
  2. 사이클을 포함하지 않음의 조건에 근거하여

  - **각 단계에서 사이클을 이루지 않는 최소 비용 간선을 선택** 하는 것이다.

- 간선 선택을 기반으로 하는 알고리즘

- 이전단계에서 만들어진 신장트리와는 상관없이 무조건 최소 간선만을 선택

- *그래프 내에 적은 숫자의 간선만을 가지는 '희소 그래프'에서 사용하기 적합하다*



***과정***

1. 그래프의 간선들을 가중치의 오름차순으로 정렬
2. 정렬된 간선 리스트에서 순서대로 사이클을 형성하지 않는 간선을 선택
   1. 즉, 가장 낮은 가중치를 먼저 선택
   2. 사이클을 형성하는 간선을 제외
3. 해당 간선을 현재의 MST의 집합에 추가



***주의!***

- 다음 간선을 이미 선택된 간선들의 집합에 추가할 때 **사이클을 생성하는지를 체크해야한다.**
  - 새로운 간선이 이미 다른 경로에 의해 연결되어 있는 정점들을 연결할 때 사이클이 형성된다.
  - 즉, 추가할 새로운 간선의 양끝 정점이 같은 집합에 속해 있으면 사이클이 형성된다.
- 사이클 생성 여부를 확인하는 방법은
  - 추가하고자 하는 간선의 양끝 정점이 같은 집합에 속해있는지를 먼저 검사해야한다.( **union-find 알고리즘 이용!** )

### 2. Prim MST 알고리즘

> **시작 정점에서부터 출발하여 신장트리 집합을 단계적으로 확장 해나가는 방법**

- 정점 선택을 기반으로 하는 알고리즘
- 이전 단계에서 만들어진 신장 트리를 확장하는 방법
- *그래프 간선이 많이 존재하는 '밀집 그래프'에서 사용하기 적합하다*



***과정***

1. 시작 단계에서는 시작 정점만이 MST 집합에 포함된다.
2. 앞 단계에서 만들어진 MST집합에 인접한 정점들 중에서 최소 간선으로 연결된 정점을 선택하여 트리를 확장한다.
   1. 즉, 가장 낮은 가중치를 먼저 선택한다.
3. 위의 과정을 트리가 `(n-1)`개의 간선을 가질 때까지 반복한다.

## MST 관련 문제

- [최소 스패닝 트리 - 백준 1197번](https://www.acmicpc.net/problem/1197)
- [네트워크 연결 - 백준 1922번](https://www.acmicpc.net/problem/1922)



# **> 다익스트라 알고리즘**

---

이제부터 그래프에 대한 글만 엄청 쓸 겁니다. 한 11~12개 정도 예정되어 있네요.

그래프... 정말 어렵고, 답없고, 온갖 문제가 많기로 유명합니다.

그 중에서도 처음을 장식할 최단 경로 알고리즘은 그 종류부터 3개나 됩니다.

그 중 첫 번째 알고리즘인 **다익스트라 알고리즘**(Dijkstra's algorithm)에 대해서 알아보겠습니다.



이 알고리즘이 하는 일은 그래프의 어떤 정점 하나를 시작점으로 선택하고,

나머지 정점들로의 최단거리를 모두 구합니다. 시작점 자신이야 뭐 그냥 0입니다.

정점 개수가 V, 간선 개수가 E일 때 기본적인 최적화를 거치면 **O(ElogV)**의 시간복잡도를 갖습니다.

그래프는 무향이거나 유향인데 대체로 유향인 경우가 많고, 간선마다 이동거리가 존재합니다.

또한 모든 거리값이 음수가 아닐 때만 사용할 수 있습니다.

이 이동거리가 거리 대신 비용(cost)이라는 용어로 대체되고서 최소비용을 구하라고 할 수도 있는데 같은 표현입니다.

![image-20200913210309128](https://user-images.githubusercontent.com/58545240/93018057-26d6bd00-f608-11ea-8adc-4b680477e8ae.png)

이런 무향 그래프를 예로 들어 설명하겠습니다. 영문 위키 예제를 퍼온 겁니다.

0번 정점을 시작점으로 하여, 0번에서 다른 정점으로 가는 최단 경로를 다 구할 겁니다.



다익스트라 알고리즘은 이렇게 작동합니다.

**① 아직 방문하지 않은 정점들 중 거리가 가장 짧은 정점을 하나 선택해 방문한다.**

**② 해당 정점에서 인접하고 아직 방문하지 않은 정점들의 거리를 갱신한다.**

맨 처음에는 시작점으로의 거리만 0이고 나머지는 다 거리가 무한입니다.

정점 i, j 사이의 거리를 d, 거리 테이블을 dist라고 부르겠습니다.



![image-20200913210333216](https://user-images.githubusercontent.com/58545240/93018094-42da5e80-f608-11ea-9e1a-2e9bb5e76b20.png)

dist가 제일 작은 것이 시작점이므로(나머지는 다 무한), 시작점인 0번 정점을 방문하고 이런 일을 합니다.

0번에서 바로 갈 수 있는 인접한 정점은 1, 2, 5번 정점이고,

0번을 통해 k번 정점으로 가는 거리는 dist[0] + d[0][k]이고, 이게 만약 dist[k]보다 작다면 dist[k]가 갱신됩니다.

지금은 0번을 제외한 모든 정점으로의 dist 값이 무한대이므로 무조건 갱신됩니다.

![image-20200913210354291](https://user-images.githubusercontent.com/58545240/93018097-48d03f80-f608-11ea-8a45-bdb6f4dffca2.png)

그 다음, 아직 방문하지 않은 정점 중 dist가 제일 작은 곳이 1번이므로

1번 정점을 방문하여 인접한 2, 3번 정점의 거리 갱신을 시도합니다.

0번 정점 또한 인접하지만, 0번 정점은 이미 방문한 상태이므로 아무것도 하지 않습니다.

여기서 2번 정점의 경우는 거리가 갱신되지 않습니다. dist[2]가 이미 dist[1] + d[1][2]보다 작거나 같기 때문.



![image-20200913210413878](https://user-images.githubusercontent.com/58545240/93018104-52f23e00-f608-11ea-92ad-6b9f35a68c96.png)

아... 여기부터는 아래의 간선에 실수로 방향을 안 없애놨네요. 무시해주시기 바랍니다.

여튼 이번엔 dist[2]가 제일 작으므로 2번 정점을 방문하여 3, 5번 정점으로의 거리를 갱신합니다.

![image-20200913210433148](https://user-images.githubusercontent.com/58545240/93018106-57b6f200-f608-11ea-846a-609787978b87.png)

그 다음은 5번 정점을 방문합니다.

![image-20200913210449644](https://user-images.githubusercontent.com/58545240/93018114-64d3e100-f608-11ea-8bb0-925bb72fd246.png)

3, 4번 정점이 남았는데 둘의 dist가 같네요. 이럴 때는 아무거나 방문해도 됩니다.

3번 정점에서 4번 정점의 거리 갱신을 시도했으나 먹히지 않았습니다.

![image-20200913210505798](https://user-images.githubusercontent.com/58545240/93018117-6a312b80-f608-11ea-8783-12ba0856544c.png)

마지막으로 4번 정점만 남았을 때는 나머지 정점을 다 방문한 상태이므로 아무것도 하지 않습니다.



여기까지가 다익스트라 알고리즘 작동의 과정인데, 이게 끝나고 나면 각 dist 값이 0번 정점으로부터의 실제 최단 거리가 됩니다.

즉 매 루프에서 방문된 상태의 정점의 dist값은 이미 최단거리고, 앞으로 절대 안 바뀐다는 겁니다.



왜일까요? 만약 이렇게 했는데 최단거리가 구해지지 않는 경우도 있을까요?

아직 방문하지 않은 정점들 중 가장 dist 값이 작은 정점이 u고, 사실 dist[u]는 최단거리보다는 아직 크다고 해 봅시다. 이때 u를 방문하면 dist[u] 값은 최단거리가 아니게 되겠죠.

또한 dist[u]가 아직 최단거리가 아니라는 말은, 다른 임의의 정점 v를 거치는 경로를 통해 최단거리로 갱신될 수 있다는 말입니다. 즉 dist[u] > dist[v] + d[v][u]인 어떤 정점 v가 존재할 겁니다.

그런데 **아직 방문하지 않은 정점 중에서** dist 값이 제일 작은 게 u라고 했으니까 v는 방문한 상태일 겁니다.

그런데 v를 방문했을 때 dist[u]는 이미 dist[v] + d[v][u]로 갱신되고 말았을 겁니다.

따라서 저렇게 될 수 있는 경우는... 없습니다..

런데 위 증명에서 중요하게 작용하는 성질이 바로 **d 값이 항상 0 이상**이라는 사실입니다.

만약 d 값이 음수인 경우도 있다면 이 과정이 성립하지 않아서, 진짜로 최단 경로를 못 구할 수도 있습니다.

이때는 조금 더 느리지만 전용 알고리즘인 **벨만 포드 알고리즘**을 써야 하고 이건 다음 글에서 쓸게요.



그럼 이제 이걸 구현해야 합니다.

가장 문제인 부분은 아직 방문하지 않은 정점들 중에서 dist 값이 제일 작은 정점을 찾아 방문하는 부분.

이걸 그냥 dist 값들을 다 비교해서 찾다가는 매번 O(V)고, 루프는 V-1번 실행되니까 O(V^2)의 시간복잡도가 발생하고 말아서 너무 큽니다.

따라서 이걸 영리하게 찾아야 하는데요, 여기에 사용되는 게 바로 **우선순위 큐**입니다!



최소 힙을 하나 마련합니다. 그리고 정점 u를 방문해서 인접한 정점 v의 거리를 갱신할 때마다 최소 힙에 **(dist[v], v) 쌍**을 넣습니다.

pair는 첫 번째 인자의 대소 비교를 먼저 하므로, dist 값이 작으면 작을수록 우선순위 큐에서 먼저 나오겠죠.

dist 값이 제일 작은 걸 뽑아서, 그 두 번째 인자인 정점 번호를 사용하면 됩니다.

또한 v를 방문하기 전에 값이 여러 번 갱신될 수도 있고, 그럼 서로 다른 (d, v) 값들이 우선순위 큐 안에 존재할 수 있는데 이땐 쿨하게 그냥 제일 작은 d 값 하나만 뽑아서 쓰면 되고 우선순위 큐가 이걸 자동으로 해결해 줍니다.

다만 아직 우선순위 큐에 남아있는 v 정점에 관한 쌍은 어떻게 하느냐? 이건 그냥 놔뒀다가 추후 top에서 나타나면 무시합니다. 즉, 꺼낸 정점이 이미 방문한 곳이면 무시하고 다음 top을 꺼내면 됩니다.



이렇게 하면, 한 정점에 최대한 많은 갱신이 이루어진다고 해도 넉넉잡아 V^2번 갱신이 이루어져서 PQ에 한 순간에 V^2개의 정보가 들어있다고 해도

원래 연산에 O(logN)의 시간이 드는 우선순위 큐 입장에서는 O(log(V^2)) = O(2logV) = O(logV).

즉, 최대 O(E)번 우선순위 큐에서 top을 꺼내는 연산 O(logV),

루프 전체를 통틀어서 인접한 정점으로의 거리를 갱신하는 부분도 최대 O(E)번 이루어질 것이므로

총 시간복잡도 합은 **O(ElogV)**입니다.

아, 여기서 O(E)라는 시간복잡도 또한 그래프를 **인접 리스트**로 구현했을 때의 말입니다.

인접행렬로 구현했다면 매번 인접한 정점을 찾아야 하니 루프마다 O(V)의 시간이 소요되어서 총합 O(V^2)가 될 것입니다...



한 가지 예외처리를 해야 하는 경우가 있습니다.

그래프 자체가 연결 그래프가 아니거나, 아니면 유향 그래프에서 시작점에서 어떤 정점으로 못 갈 때는 루프를 꼭 V-1번 돌지 못합니다. 중간에 우선순위 큐가 텅텅 비어버리게 되고 이때는 그냥 나와야 합니다.

아직 방문하지 못한 정점들의 경우는 거리가 무한으로 남아 있고, 이는 시작점에서 그 정점으로 갈 수 없다는 뜻이겠지요.



## 다익스트라 관련 문제

**1753번: 최단경로**

위에서 설명한 문제입니다.



**1916번: 최소비용 구하기**

역시 기본적인 다익스트라 알고리즘 연습 문제이며,

시작점과 도착점이 정해지는 데다가 항상 이동 가능해서 오히려 더 쉬울지도?

간선이 최대 10만 개고 각 비용이 최대 10만이어서 10만*10만은 int 범위를 넘어가지만,

도시 개수가 최대 1,000인지라 가능한 최단거리는 100,000*999라서 int 범위 안에 있습니다.



**1504번: 특정한 최단 경로**

반드시 거쳐야 하는 정점이 a, b일 때 가능한 경로는 1->a->b->N, 1->b->a->N 두 가지이고 둘 중 더 작은 경로가 답입니다.

1->a->b->N으로 가는 최단 경로는 그냥 1->a, a->b, b->N 최단 경로 3개를 더하면 되고, 이 중 하나라도 경로가 없는 경우 전체 경로가 존재하지 않습니다.

따라서 1, a, b 세 개의 정점을 시작점으로 하여 각각 다익스트라 알고리즘을 돌려 다른 모든 정점으로의 거리 정보를 얻고, 이들을 조합해서 문제를 풀면 될 것입니다.



**4485번: Obstacle Course**

이번엔 간선이 아니라 각 칸에 비용이 있네요.

이때는 인접한 두 칸 u, v가 있을 때 u에서 v로 가는 비용을 cost[v]로 두면 됩니다.

그러면 어떤 방을 여러 번 방문하면 cost가 중첩되어서 쌓이는 게 아니겠느냐...? 사실 한 방을 두 번 이상 방문한 시점에서 그건 이미 최단경로가 아니라서 신경쓰실 필요 없습니다.

시작점 S의 dist 값이 0이 아니라 cost[S]인 상태로 시작하여 dist[E]를 구하거나, 아니면 마지막에 dist[E]에 cost[S]를 더해서 출력하면 됩니다.



**1238번: 파티**

1~N번을 각각 시작점으로 해서 다익스트라 알고리즘을 한 번씩 돌려야 합니다.

각각 X번 마을로의 최단경로를 구해야 하고, X번 마을에서는 나머지 다른 마을로의 모든 최단경로를 구해야 하죠.

이 모든 정보를 조합해서 가장 긴 왕복거리 값을 찾으면 됩니다.

X번이 아닌 다른 마을에서 다익스트라 알고리즘을 시도할 때는 **X번 마을을 방문하면 바로 알고리즘을 종료**해버리는 게 시간 절약에 도움이 됩니다.

이론상의 시간복잡도는 **O(N^2logN + NM)**이네요.



**1261번: 알고스팟 (★)**

Obstacle Course 문제와 똑같이 풀면 됩니다.

벽인 방으로 이동하려면 벽을 뚫어야 하고 이건 cost 1이 들어감을 의미하죠.

뚫어야 하는 최소 벽 개수가 즉 최소 비용이 되겠습니다.



**10473번: 인간 대포 (★)**

기하 문제인데요. 시작점, 목적지, 그 외 모든 대포를 정점으로 두고

각 정점 사이의 최단 이동 **시간**을 죄다 구하는 것을 시작으로 다익스트라 알고리즘을 사용합니다.

시작점에서는 도착점이나 다른 모든 대포로 그냥 걸어가는 직선 거리를 구해서 시간을 구하고,

각 대포에서는 다른 대포나 도착점으로 가는 최단시간을 구해야 하는데, 일단 대포로 갔다는 건 발사는 했다는 말이므로 착지한 후 그대로 걸어가야 하는데 경우에 따라 발사하면서 목적지를 지나쳐 갈 수도 있는 등 여러 가지 케이스를 다 처리해 주셔야 합니다.



**2211번: 네트워크 복구 (★)**

prev 배열의 저력을 보여줄 때입니다.

1번 정점이 슈퍼컴퓨터이고, 간선들 중 일부만 골라서 모든 정점을 잇게 하되, 최소 개수의 간선만 고르라고 하네요.

이때는 정점 개수가 N인 그래프가 연결 그래프일 때 반드시 **N-1개의 간선**만 골라서 정점이 N개인 트리를 만들어서 조건을 만족시킬 수 있습니다. 이걸 **신장 트리**(spanning tree)라고 하는데 바로 다음 글에서 자세히 다루도록 하죠.



그러나 다른 조건이 있는데, 복구한 간선들만을 통해 도달할 수 있는, 1번 정점으로부터 다른 정점까지의 최단 경로가 원래와 같아야 한다네요(줄어들 수는 없습니다).

이때는 놀랍게도, 1번을 시작점으로 하여 다익스트라 알고리즘을 돌린 후 1번 정점을 제외한 각 정점 u에 대해 prev[v] = u라고 할 때, 간선 (u, v)들만 모아서 복구하면 문제가 해결됩니다.

특정 정점에서 prev 배열만 역으로 계속 따라가다 보면 시작점에서 도착점으로 가는 최단 경로를 역순으로 얻을 수 있다는 점에서 착안한 것입니다.



**16681번: 등산** 

각 마을마다, 1번 마을로부터의 거리와 N번 마을로부터의 거리를 구하면 됩니다. 1번과 N번을 각각 시작점으로 하여 다익스트라를 2번 돌리면 해결됩니다. 물론 높이가 높아지는 정점으로만 이동하게 해야겠죠.



**5719번: 거의 최단 경로 (★)**

어렵습니다. 한 번 최단 경로가 얼마인지 구한 후, 최단 경로로 가능한 모든 경로의 간선을 다 없애는 짓을 해야 합니다.

일단 시작점 S와 도착점 E가 있고 각 정점의 시작점으로부터의 거리 dist 값들이 있을 때, dist 값들을 다 구하고 나서 이런 행동을 해서 최단경로의 간선을 모두 체크할 수 있습니다.



① 큐에 시작점을 넣고 시작합니다.

② 큐의 맨 위에 있는 정점을 꺼내서 u라 하면, 인접한 정점 v 중 dist[u]+d[u][v] = dist[v]인 모든 v를 찾아 큐에 넣고, 그러한 v에 대해 간선 (u, v)를 가능한 최단 경로에 속한다고 판별합니다.



일종의 **BFS** 형태입니다. 이렇게 경로를 다 구하고 삭제하는 과정을 거친 후 한 번 더 다익스트라 알고리즘을 돌려야 하네요.

처음부터 S에서 E로 갈 수 없거나, 간선 삭제 후 갈 수 없게 되거나 하는 경우를 잘 처리해 주셔야 합니다.



**15422번: Bumped!**

BFS 글에서 응용 문제들을 유심히 보셨다면, 비슷하게 응용해서 이런 문제도 풀 수 있습니다.

이 문제의 경우 그래프가 주어짐과 동시에, 최대 하나만 골라서 공짜로 이용할 수 있는 비행권들이 있습니다.

벽 부수고 이동하기 문제와 비슷하게, 제공된 비행권들 중 하나를 사용했느냐 아니냐로 각 정점을 이등분해서 거기에 대해 다익스트라 알고리즘을 돌리면 풀 수 있습니다. 비행권은 양방향 간선이 아님에 주의하세요.



**1162번: 도로포장 (★)**

K가 최대 20밖에 안 돼서 이런 걸 시도할 수 있습니다.

정점 번호와 앞으로 더 포장할 수 있는 도로 개수를 갖고 있는 새로운 형태의 정점 (u, k)들을 생각해 봅시다. 그렇다면 시작점은 (1, K)이며 답은 (N, 0) ~ (N, K) 중 최솟값일 겁니다.

그냥 있던 도로를 따라간다면 (u, k)에서 (v, k)로 이동하게 되고 이때의 거리는 그냥 d[u][v]입니다.

그러나 k > 0일 때는 도로 하나를 포장할 수 있고, (u, k)에서 (v, k-1)로 cost 0을 들여서 이동할 수 있습니다.

이런 식으로 그래프를 모델링해서 다익스트라 알고리즘을 적용하면 됩니다.



**10217번: KCM Travel (★)**

도로포장 문제와 상당히 유사합니다.

이번엔 금액이라는 또다른 제한이 주어지는데, 공항 수 N이 최대 100이고 금액도 최대 10,000이라서

각 정점에다 현재 가지고 있는 돈의 정보를 묶어 (n, m) 형태의 정점을 새로 모델링할 수 있고, 시작점 (1, M)에서 도착점 (N, ?)으로 가는 최단시간이 되겠네요. 도착점에서 가지고 있을 돈의 액수는 아무래도 좋고 일단 도착만 가능하면 됩니다.

물론, 이번에도 돈이 부족하면 해당 간선은 못 지나갑니다. (u, v) 방향 간선이(u->v) 시간 d, 비용 c가 든다면 (u, 15)에서는 (v, 15-c) 정점으로 시간 d를 들여서 갈 수 있는 것이고, 비용 c만큼도 부족하다면 아예 갈 수 없습니다.

총 정점 개수가 O(NM)으로 약 백만 개지만 시간제한도 10초나 되어서 다익스트라 알고리즘으로 무리없이 풀 수 있습니다.

그리고 이 문제의 경우 항상 어떤 간선을 지날 때마다 최소 1의 비용이 소모되어서 **DP**로도 푸는 게 가능합니다.



# **> 벨만포드 알고리즘**

---

이어서 소개해드릴 것은 또다른 최단경로 알고리즘입니다.

**벨만 포드 알고리즘**(Bellman-Ford algorithm)인데요, 알고리즘을 개발한 두 학자의 성을 따서 붙인 이름이라고 합니다.

동시에 독자적으로 알고리즘을 개발했던 또다른 학자의 이름까지 붙여서 벨만 포드 무어 알고리즘이라 명명할 때도 있다는군요.



다익스트라 알고리즘과 마찬가지로 시작점을 정해 주면 다른 모든 정점으로의 최단 경로를 구하는데,

다익스트라 알고리즘보다는 시간이 오래 걸려서 **O(VE)**의 시간이 걸리지만

이 알고리즘은 **간선 cost가 음수일 때**도 사용할 수가 있습니다!!

아니 도대체 거리가 음수라니 무슨 소리냐, 뭐 그런 거 다 떼어놓고 그냥 최단거리가 정말 작으면 작을수록 좋다고 친다면, 설령 그게 음수가 되더라도 정확히 구해버린다는 거죠.

그나마 말이 되는 예시를 들자면 거리 대신 이동시간이라 생각하고, 타임머신을 타서 과거로 간다고 생각하는 겁니다. 이때는 시간을 역행했으므로 소요시간이 음수가 될 겁니다.

![image-20200913211046788](https://user-images.githubusercontent.com/58545240/93018125-761ced80-f608-11ea-9b05-918b5401a6e5.png)

예를 들어 이런 그래프가 있다고 합시다. 시작점이 0번 정점인데, 2번 정점까지의 최단거리를 구하려고 합니다.

이제부터는 간선 비용 자체가 음수일 수도 있어서, 그냥 최단거리 자체의 정의를 최소의 cost(음수가 되어도 상관없음)를 들여서 오는 경로의 cost 합이라 보는 게 좋겠죠.

여튼 2번 정점까지 가는 최단거리는 0->1->2를 거쳐서 12+(-7)=5여야 합니다.

그러나 다익스트라 알고리즘은 1, 2번 정점 중에서 dist[1]=12 > dist[2]=8이라 해서 2번 정점을 방문해버리게 되고, 실제 2번 정점까지의 최단 경로는 8보다 작기 때문에 이는 잘못되었으며

결국 다익스트라 알고리즘으로는 음의 간선이 존재하는 그래프에서 최단경로를 제대로 못 구할 수 있다는 사실을 보여줍니다.



따라서 벨만 포드 알고리즘은 2중 for문을 통해 철저하게 가능한 모든 경우를 다 체크하기로 합니다.

일단, 최단 경로라는 말은 **같은 정점을 두 번 지날 일이 없기 때문에** 가능한 최단 경로의 간선 개수는 많아봐야 **V-1**개입니다.

(뭔가 이상한 점을 느끼셨을지도 모릅니다. 그건 있다가 설명하겠습니다.)

따라서 루프를 V-1번 돌리는데, k번째 루프에서는 시작점으로부터 각 정점으로 k개의 간선을 거쳐서 도달할 수 있는 최단경로를 다 갱신해주자는 게 기본 아이디어입니다.

k-1번째 루프까지는 최대 k-1개 간선을 거치는 최단경로를 다 구해놓았다고 믿고(???) k번째 루프에서 그 정보들을 사용해 또다른 최단경로를 구해보는 것이죠.

## - BOJ[11657]:타임머신

https://www.acmicpc.net/problem/11657

이 문제를 벨만 포드 알고리즘으로 풀어버리려고 하는데요.

```c++
#include <cstdio>
#include <vector>
#include <utility>
#include <algorithm>
using namespace std;
typedef pair<int, int> P;
const long long INF = 1e18; // 절대 나올 수 없는 경로값
 
int main(){
    int N, M;
    long long dist[500];
    scanf("%d %d", &N, &M);
    vector<P> adj[500];
    for(int i=0; i<M; i++){
        int A, B, C;
        scanf("%d %d %d", &A, &B, &C);
        adj[A-1].push_back(P(B-1, C));
    }
    fill(dist, dist+N, INF);
    dist[0] = 0;
    for(int i=0; i<N-1; i++){ // (N-1)번의 루프
        for(int j=0; j<N; j++){
            // N-1번의 루프에 걸쳐 각 정점이 i+1개 정점을 거쳐오는 최단경로 갱신
            for(auto &p: adj[j]){
                int next = p.first, d = p.second;
                if(dist[j] != INF && dist[next] > dist[j] + d){
                    dist[next] = dist[j] + d;
                }
            }
        }
    }
    for(int i=1; i<N; i++)
        printf("%lld\n", dist[i]!=INF ? dist[i] : -1);
}
```


일단 코드는 이렇습니다. 다익스트라 알고리즘과 큰 구조가 다른데요.

일단 말씀드린 대로 V-1번의 루프를 돕니다. 이 문제에서는 V = N이죠.

그리고 안쪽의 구조는 사람마다 판이하게 다를 수 있는데, 다 하는 건 똑같습니다.

**존재하는 모든 간선을 돌아보면서** 이 간선을 통할 수도 있는 최단경로들의 거리를 갱신하는 것.



이때, **음의 간선이 존재하기 때문에** 간선 (u, v)를 볼 때 먼저 dist[u]가 아직 INF인지 확인을 해야 합니다.

구현에 따라서 둘 다 시작점에서 도달 불가능한 정점 u, v가 존재하고 (u, v) 가중치가 음수일 때

dist[u] = INF, dist[v] = INF-cost 꼴이 나올 수도 있고, 이러면 골치 아파집니다.

![image-20200913211244972](https://user-images.githubusercontent.com/58545240/93018138-8f259e80-f608-11ea-8c0b-952436a284c4.png)

가장 간단한 그래프를 하나 예로 들어봅시다. u가 시작점이고 처음엔 이 상태로 시작하죠.

![image-20200913211321205](https://user-images.githubusercontent.com/58545240/93018139-9056cb80-f608-11ea-9273-a6b17f5d95a0.png)

첫 번째 루프가 돌기 전에는 dist[v] = INF이기 때문에 간선 (v, w)는 의미가 없습니다.

의미가 있는 것은 dist[u] ≠ INF인 u이고, u에서 시작한 간선들이 인접한 정점의 dist를 갱신해주죠.



사실, **방문 순서에 따라 우연히도** (u, v)를 먼저 방문하고 dist[v]를 갱신하고 나서 (v, w)를 방문하면 한 번에 dist[w]까지 구해질 것이지만,

그 적절한 방문 순서를 알 방도가 없죠. 모르니까 우린 무식하게 가능한 경우를 다 따져보고 있는 것이구요.

따라서 최악의 사태를 대비하여 루프를 V-1번 돌리는 것이고, V-1번의 루프를 돌리면 아무리 운 나쁘게 갱신이 지연되어도 반드시 dist 값들이 모두 최단 거리를 담고 있게 됩니다.

![image-20200913211338679](https://user-images.githubusercontent.com/58545240/93018140-90ef6200-f608-11ea-9dc2-a8b4ec037b1b.png)

그 다음 루프에 제일 먼 정점인 w의 거리도 비로소 구해지게 됩니다.

이때, 정점이 3개고 루프 2개로 모든 게 끝났죠.

![image-20200913211354113](https://user-images.githubusercontent.com/58545240/93018141-92b92580-f608-11ea-9e72-3af3b6536256.png)

이번엔 다른 경우를 살펴볼 겁니다.

전체 그래프의 일부만 살펴볼 건데, 이런 경우도 존재할 수 있습니다.

v, w가 어쩌다 보니 시작점과 좀 가까워서 미리 저런 dist 값을 갖고 있고,

뒤늦게 정점 u의 dist 값이 갱신되어서 이런 형태를 마주할 수 있는데요.

지금 보면 dist[u] = 2기 때문에 정점 u를 거쳐가면 **dist[v]가 갱신됩니다.**

dist[v]가 갱신된다면, 그 뒤에 계단식으로 dist[w]까지 갱신되어야 할 겁니다.

![image-20200913211410831](https://user-images.githubusercontent.com/58545240/93018166-b41a1180-f608-11ea-8427-f5646579fdee.png)

그래서 이번 루프에서 먼저 dist[v]가 갱신됩니다.

아직 dist[w]는 갱신되지 않**을 수도 있**습니다.

![image-20200913211426138](https://user-images.githubusercontent.com/58545240/93018167-b4b2a800-f608-11ea-852e-e1d4a29f5e80.png)

그러나 다음 번 루프에서는 dist[w] 역시 반드시 갱신될 수밖에 없습니다.

이때, 아직 루프가 많이 남았다면 동시에 dist[u]가 더 줄어들 수도 있습니다.

그럼 뭐, 똑같이 연쇄적으로 계속 dist[v], dist[w]도 줄어들고... 그런 겁니다.

그런데, 음의 가중치가 있는 그래프에서 최단경로를 구할 때 항상 염두에 두어야 하는 것이 있습니다.

![image-20200913211446585](https://user-images.githubusercontent.com/58545240/93018168-b54b3e80-f608-11ea-9874-5ffe207e4e39.png)


이 그래프에서, 0번 정점에서 4번 정점으로 가는 최단거리가 얼마라고 생각하시나요?

저 빨간색 정점들을 잘 보세요. 일단 싸이클이긴 한데,

평소엔, 아니 지금까지는 최단거리는 같은 정점을 두 번 이상 지나지 않는다고 철석같이 믿고 살아왔건만,

저 싸이클을 보세요. 1->2->3->1을 순회하면 오히려 처음 1번 정점을 방문했을 때보다 **시간이 줄어듭니다!!!!**

3+(-4)+(-1)=(-2)만큼 시간이 역행해버리는 거죠.

문제는 이게 싸이클이라, 이 싸이클을 계속해서 돌면 시간이 언제까지고 줄어들 수가 있습니다.

게다가 이러한 싸이클에서 지금 4번 정점으로 갈 수가 있기 때문에, dist[4]는... 그렇습니다. **-∞**가 됩니다...

빨간색 싸이클 안에 속해있는 놈들도 말할 것이 없이 다 -∞입니다.

시작점인 0번 정점만이... 싸이클에서 도달할 수 없으므로 최단거리가 실수 범위에서 정해지게 됩니다.



이렇게 가중치 합이 0보다 작은 싸이클을 **음수 싸이클** 혹은 **음의 싸이클**(negative cycle)이라고 하며, 벨만 포드 관련 문제에서 반드시 등장하는 요소입니다.

다행히도 이 문제에서는 음의 싸이클이 하나라도 존재하면 그냥 다 필요없고 "-1" 하나만 출력하라고 명시해 주었으므로, 그냥 그걸 찾기만 하면 되는데요.

그럼 어떻게 찾을까요? 우리가 V-1번만 루프를 돌았고 이 이상 루프를 돌아봐야 최단거리들이 갱신되지 않으리라고 했죠.

그러나 만약 음의 싸이클이 존재한다면, **그 이후에 루프를 돌면 최단거리가 갱신되는 일이 발생합니다.**

싸이클에 속하는 정점들부터, 그 싸이클의 인접한 정점들로까지.

따라서 음의 싸이클의 존재여부만 판단한다면 맨 마지막에 확인차 루프를 한 번 더 돌아서 최단거리가 갱신되는 일이 있는지 보면 됩니다.

```c++
#include <cstdio>
#include <vector>
#include <utility>
#include <algorithm>
using namespace std;
typedef pair<int, int> P;
const long long INF = 1e18; // 절대 나올 수 없는 경로값
 
int main(){
    int N, M;
    long long dist[500];
    scanf("%d %d", &N, &M);
    vector<P> adj[500];
    for(int i=0; i<M; i++){
        int A, B, C;
        scanf("%d %d %d", &A, &B, &C);
        adj[A-1].push_back(P(B-1, C));
    }
    bool minusCycle = false;
    fill(dist, dist+N, INF);
    dist[0] = 0;
    for(int i=0; i<N; i++){ // (N-1) + 1번의 루프. 마지막은 음의 싸이클 존재 여부 확인용
        for(int j=0; j<N; j++){
            // N-1번의 루프에 걸쳐 각 정점이 i+1개 정점을 거쳐오는 최단경로 갱신
            for(auto &p: adj[j]){
                int next = p.first, d = p.second;
                if(dist[j] != INF && dist[next] > dist[j] + d){
                    dist[next] = dist[j] + d;
                    // N번째 루프에 값이 갱신되면 음의 싸이클이 존재한다.
                    if(i == N-1) minusCycle = true;
                }
            }
        }
    }
    if(minusCycle) puts("-1");
    else{
        for(int i=1; i<N; i++)
            printf("%lld\n", dist[i]!=INF ? dist[i] : -1);
    }
}
```

아아아아주 조금 달라졌습니다. 일단 루프 도는 횟수가 한 번 늘었고,

마지막 루프에 뭔가 갱신되면 minusCycle이란 flag 변수를 set하여 음의 싸이클이 존재함을 판정합니다.



여튼, 이렇게 큰 루프가 V번이고 안쪽에서 하는 일은 형태는 다양할지언정 동일하게 모든 간선을 순회하는 것이므로 총 시간복잡도는 **O(VE)**가 됩니다.



여기서 상당한 맹점이 있는데, 무한 루프가 없을 때 가능한 "최단 경로"의 최댓값은 (정점 수 - 1) * (최대 거리값)이라 4byte 정수형 값의 범위 안에 들어오지만, **이 문제에서는 안전하게 8byte 정수형 값을 사용해야 합니다.**

왜냐면 모든 간선이 절댓값 최대인 음의 가중치(이 문제에서는 -10000)를 가지고 있다면, N번의 루프 안에 계산 중간값의 절댓값이 4byte 정수형 값을 넘어가버릴 수 있게 됩니다.



다음과 같은 그래프를 생각해 봅시다. 정점이 1부터 N까지 있고, 간선도 N개 존재하는데 1->2, 2->3, ... -> (N-1)->N, N->1 을 이어주며, 각각의 비용이 -C(C > 0)라고 하겠습니다.

그렇다면 위 코드의 경우 첫 번째 루프에서 쭉쭉쭉 따라와서 dist[N-1] = -C*(N-1)이 계산되고, 이어서 dist[0] = -C*N 이 됩니다.

다음 루프에서는 최종적으로 dist[0] = -2*C*N이 됩니다.

그 다음 루프에서는 최종적으로 dist[0] = -3*C*N이 됩니다.

이 과정을 쭉 따라오면 마지막 루프에서 dist[0] = -C*N^2가 되는데요, 이 값에 문제의 최대 범위 값을 모두 투입해 보면 절댓값이 21억을 넘어가버리고 맙니다.

즉 양의 값들이 아니라 반대쪽에서 오버플로우가 일어날 가능성이 존재한다는 것입니다. 음의 비용이 있는 그래프 최단 경로 문제에서 항상 신경써야 할 어려운 점 같네요...







벨만 포드 알고리즘은 나머지 2개, 다익스트라와 플로이드에 비해 실제로 보기가 조금 어려운 유형에 속합니다.

그러나 나왔다 하면 항상 타임머신이나 블랙홀 등 과거로 가는 행동과 연관이 많습니다.

사실 그게 아니고서야 우리에게 뜬금없이 "봐봐 이 경로를 거치면 음수의 거리다."라고 하는것도 무리지만요...



또한 벨만 포드 알고리즘의 변형으로 시간복잡도는 그대로지만 실전에서 더 빠르게 돌아간다고 하는 **SPFA**(shortest path faster algorithm)이라는 게 있고, 다익스트라와 비슷한 코드인데 우선순위 큐가 아닌 큐를 사용한다는 점이 다릅니다.

물론 음의 가중치가 있는 그래프에 사용 가능하며, 훗날 MCMF 문제를 풀 때 애용되는 알고리즘입니다.

우선순위 큐(->다익스트라)나 유니온 파인드(->크루스칼)가 그러했듯이, 벨만 포드만 쓰는 문제보다도 MCMF 때문에 필요한 문제가 압도적으로 많습니다.

## 벨만포드 관련 문제

**11657번: 타임머신**

위에서 설명한 문제입니다.



**1738번: 골목길**

이 문제는 한때 도대체 출처와 정체와 지문의 뜻과 데이터의 상태 중 알 수 있는 게 한 개도 없는 정체불명의 정답률 0% 저주받은 문제였으나, 언젠가 정상적인 문제로 리메이크되었습니다.

타임머신 문제와는 좀 다르게, 음의 싸이클이 있기만 하면 끝이 아니라, 그 음의 싸이클에서 도착점으로 도달 가능해야 답이 -1입니다. 역방향 간선 리스트를 만들고 도착점으로부터 BFS를 해서 각 정점이 도착점으로 도달 가능한가 파악해 놓는 전처리가 가능합니다. 물론, 그냥 시작점에서 도착점에 도달 불가능해도 답이 -1입니다.



**1865번: 웜홀 (★)**

문제 자체는 상당히 간단합니다. 시작점조차 주어지지 않고, 그냥 N개 정점이 있는데 이 중 아무거나 시작점을 자신으로 했을때 자신으로 돌아오는 최단거리가 0보다 작은 경우가 하나라도 있냐고 물어보는데, 이 말을 잘 풀이해 보면 **음의 싸이클이 존재하냐**는 겁니다.

음의 싸이클이 시작점과 다른 먼 곳에 존재하고 음의 싸이클에서 시작점으로 못 돌아올 수도 있겠으나, 그때는 그냥 음의 싸이클 안의 정점들이 이미 문제에서 찾는 정점이기 때문에 이미 YES.



다만 이번에는 그래프를 이루는 **컴포넌트가 여러 개일 수도 있다**는 점을 조심하셔야 하고, 각 컴포넌트를 각 그래프로 취급하여 일일이 벨만 포드를 돌려보는 수밖에 없습니다.

물론 시간 초과의 위험이 있으니 너무 무식하게 짜지는 마시고,

상위의 visited 배열을 준비해서 방문 안 한 정점이 나타나면 그 정점을 시작점으로 하여 벨만 포드를 한 번씩 돌려주면 그 컴포넌트 안에 존재하는 음의 싸이클은 찾을 수 있을 겁니다.

이렇게 모든 정점을 순회하시면 됩니다.



**10360번: The Mountain of Gold?**

시작점의 과거로 돌아갈 수 있는지를 묻는 문제입니다.

N번째 루프에서 시작점으로부터의 거리가 확실히 작아지는 정점들 중 시작점으로 가는 길이 있는 정점이 있다면 가능합니다. 시작점이 그 음의 싸이클에 포함되더라도 이 성질은 성립합니다.



**1219번: 오민식의 고민 (★)**



정점을 지날 때마다 돈을 벌어들이는데, 돈을 벌어들이는 것은 소비하는 것과 반대되므로 음의 가중치로 부여합니다. 마침 문제에서 구하라는 것도 돈의 최댓값인데, 소지금 자체를 음수로 본다면 최소의 음수가 되겠죠.

저번에 정점에 가중치가 있는 문제를 풀었을 때처럼, 그냥 정점을 방문할 때마다 그 정점의 가중치까지 cost에 넣어주면 됩니다. 맨 처음엔 dist[S]는 -(S에서 벌 수 있는 돈)으로 시작합니다.



단, 음의 싸이클이 존재는 하더라도 도착 도시로 못 가는 경우도 존재할 수 있습니다. 따라서 음의 싸이클 안에 속해있다고 판정되는 정점이 나타날 경우, 꼭 거기서 도착점으로 도달 가능한지도 체크해 주어야 Gee 여부를 정확히 판정할 수 있습니다.

또한 결과인 최단거리는 int 범위 안이지만 도중의 연산 과정에서 이 한도를 벗어날 수 있기에 long long형 배열을 사용하셔야 합니다.

# **> 플로이드 와샬 알고리즘**

> **Floyd-Warshall algorithm**
>
> **앞의 두 최단거리 알고리즘과는 다르게 정점 V개가 있고 거리가 다 주어져 있을 때, 단 한번의 시행으로 모든 정점 쌍 사이의 거리를 다 구해낸다.**

코드는 굉장히 짧은데, 아주 전형적인 3중 for문의 형태를 하고 있고 **O(V^3)**입니다.

음의 가중치가 있는 간선 그래프에서도 제대로 동작합니다.

## -BOJ[11404] : 플로이드

이 문제를 풀 겁니다. 아니 제목부터 대놓고 플로이드입니다. 그러므로 플로이드를 씁시다.

각 정점 u, v 쌍에 대해 u에서 v로 가는 최단 경로를 한 번에 다 구할 것이고, 이를 위해 먼저 2차원 배열 dist를 준비합니다.

초기에는 자기 자신으로 가는 dist[i][i] 꼴은 다 0이고, 나머지는 ∞으로 설정해놓고 시작합니다.

이때, dist[i][i]=0이라는 것은 자기 자신으로 이동이 가능하다는 의미인데, 문제에 따라 기본적으로 이게 안 될 수도 있고 그때는 dist[i][i]도 ∞로 초기화합니다.

그리고 간선 정보를 받아서 u->v로 가는 거리가 w라면 dist[u][v] = w로 갱신합니다.

혹시라도 똑같은 u, v 쌍에 대해 서로 다른 w가 두 번 이상 들어올 수 있는데 이때는 그 중 가장 작은 것으로 갱신해야 합니다.

여기까지가 전처리에 해당하는 그래프 모델링이고, 이제 이 dist 배열만을 갖고 플로이드 알고리즘을 적용할 겁니다.



플로이드는 최단경로를 **DP** 형태의 문제로 정의하고 풀어냅니다.

**shortestPath(i, j, k)**라는 문제는 i번 정점에서 j번 정점까지, 1~k번 정점만 사용할 때의 최단 거리를 구하라는 의미입니다.

k단계 문제를 풀려면 k-1단계의 정보가 필요한데, 그래서 k=1~N까지 시도하며 정보를 계속해서 갱신하게 됩니다.

이때, k-1단계 이전의 정보는 더이상 필요하지 않아서 3차원 배열을 쓰지 않고 **슬라이딩 윈도우** 기법을 적용하여 덮어써서 2차원 배열 dist만 가지고도 해결이 됩니다.

이걸 저번의 벨만 포드 알고리즘과 비슷하게 k번의 루프를 돌려보면 마지막엔 더 이상 갱신되지 않는 최단 경로 배열 dist가 완성되는 겁니다.



매 단계마다 하는 일은 이러합니다.

이번이 k단계, 즉 1~k번 정점을 사용하여 도달가능한 최단거리를 구해야 하는 단계라 합시다.

그렇다면 지금까지 dist 배열에는 1~k-1번 정점만 사용해서 나올 수 있는 최단거리가 남아있죠.

이걸 사용해서 갱신합니다.



*어떤 두 정점 i, j에 대해, k번 정점을 사용해 우회하면 지금까지보다 최단거리가 짧아지는가?*



이 질문을 모든 i, j 쌍에 대해 던져보고 만약 그렇다면 갱신하는 것인데요. 이 쿼리의 형태는

**if( dist[i][j] > dist[i][k] + dist[k][j] )**

이런 형태가 됩니다. 현재 dist[i][j]는 지금까지 찾은 최단거리를 담고 있는데,

여기서 dist[i][k]+dist[k][j], 즉 k번 정점을 새로 우회하여 가는 경로가 더 빠를 수도 있는데 그걸 묻고 있는 겁니다.

만약 더 빠르다면, 이제 dist[i][j]는 dist[i][k]+dist[k][j] 값으로 갱신되어 더 작아집니다.

```c++
#include <cstdio>
#include <algorithm>
using namespace std;
const int INF = 1000000000; // 절대 나올 수 없는 경로값
 
int main(){
    int N, M, dist[100][100];
    scanf("%d %d", &N, &M);
    // dist 배열 초기화
    for(int i=0; i<N; i++)
        for(int j=0; j<N; j++)
            dist[i][j] = i==j ? 0 : INF;
    // 간선 정보 입력받음
    for(int i=0; i<M; i++){
        int a, b, c;
        scanf("%d %d %d", &a, &b, &c);
        dist[a-1][b-1] = min(dist[a-1][b-1], c);
    
    // 플로이드 와샬 알고리즘 적용
    for(int k=0; k<N; k++)
        for(int i=0; i<N; i++)
            for(int j=0; j<N; j++)
                dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]);
    
    // 이제 dist 배열은 실제 최단 경로를 담고 있음
    for(int i=0; i<N; i++){
        for(int j=0; j<N; j++)
            printf("%d ", dist[i][j]);
        puts("");
    }
}
```

이게 위 문제를 푸는 소스 코드인데...

실제로 그래프가 마련되어 있을 때 플로이드 알고리즘은 20~23번 줄, 단 4줄밖에 안됩니다...

엄청 짧죠. 외워지기도 제일 빨리 외워지는 알고리즘입니다.

이게 끝나면 dist 배열의 i행 j열엔 말 그대로, i->j로 가는 최단 거리가 남게 됩니다!!



정점 V개에 대해 모든 정점에서 다익스트라 알고리즘을 돌리면 **O(V(E+VlogV))**일 것이고

만약 간선 개수가 V^2보다 많이 작다면 다익스트라 알고리즘이 약간 우위지만

음의 가중치를 가진 그래프에서는 이건 사용이 불가능하고,

벨만 포드 알고리즘을 모든 정점에 대해 돌리면 **O(V^2\*E)**이니 이쪽은 플로이드가 거의 무조건 우위입니다.

모든 정점 간의 거리를 빠르게 구해야 할 땐 플로이드가 최고지요.

또한 그 코드의 간단함과 목적의 명확함 때문에, 어려운 문제들은 이게 최단경로 문제인가조차 처음엔 알 수 없게 포장되어 나오기도 합니다.

## 플로이드 관련 문제

**추천 문제**



**11404번: 플로이드**

위에서 설명한 문제입니다.



**11403번: 경로 찾기**

위에서 설명한 문제입니다.



**1389번: 케빈 베이컨의 6단계 법칙**

문제 설명이 좀 길지만, 그냥 자기 자신으로부터 다른 모든 정점으로의 각 최단거리 합이 가장 작은 애를 하나 찾으라는 문제입니다.



**1613번: 역사**

a가 b보다 먼저 일어났다고 할 때 dist[a][b] = 1, 나머지는 ∞인 상태로 플로이드를 돌립니다.

이러면 끝나고 나서도 dist[u][v] = ∞, dist[v][u] = ∞이면 u, v는 서로 전후관계를 알 수 없다는 말입니다.

만약 dist[u][v]가 무한대가 아니라면 u에서 v로 가는 경로가 존재한다는 것이고, 따라서 u가 v보다 먼저 일어났다는 걸 알 수 있습니다.

u가 v보다 나중에 일어났다는 것을 확인하려면 반대로 dist[v][u]를 확인하면 됩니다.



**2610번: 회의준비**

위원회의 수는 컴포넌트의 수이고, 각 컴포넌트마다 안에서 대표를 뽑아야 하는데 이 대표는 컴포넌트 안의 다른 정점들로의 최단거리 중 최댓값이 가장 작은 사람이겠죠.

따라서 각 정점을 컴포넌트별로 분리하는 작업도 필요합니다.



**1956번: 운동**

간단하죠. dist[i][i]도 다 ∞인 상태로 시작하여 플로이드를 돌리고

마지막에 dist[i][i]가 최소인 i를 찾고 그 값을 출력하면 됩니다.



**13168번: 내일로 여행 (★)**

입력 데이터만으로도 책을 쓸 정도로 입력이 길지만, 시크하게 map 등으로 문자열을 정점 번호로 대응시킨 후 넘어갑시다.

그럼 이 문제는 a->b->c->...->a 형태의 고정된 경로의 최단비용이므로, 각 경로의 최단비용을 다 답해야 하니까 아예 모든 경로의 최단비용을 구해놓는 플로이드가 매우 적합하지요.

티켓을 샀을 때와 사지 않았을 때 몇몇 간선의 cost를 달리하면서, 둘 중 어느 쪽이 좋은지 결과를 놓고 비교하면 됩니다.



**9205번: 맥주 마시면서 걸어가기 (★)**

각 편의점에 들를 때마다 무조건 맥주를 풀로 조달해간다면, 출발해서 다른 정점까지 1000미터 이하의 거리라면 그 정점으로는 갈 수 있습니다.

따라서 출발점, 도착점 정점을 추가로 만들고, 거리가 1000 이하인 정점들 사이에만 간선을 놓고, 출발점에서 도착점까지 이동 가능한지를 판별하면 됩니다.



**2458번: 키 순서 (★)**

u보다 v가 키가 클 때 dist[u][v] = 1이고 나머지는 ∞인 상태로 시작해서,

마지막에 자신을 제외한 모든 정점에 대해 자신이 그 정점으로 갈 수 있거나 그 정점에서 자신으로 갈 수 있는 정점 수를 세면 됩니다.

u에서 v로 갈 수 있다면 u보다 v가 확실히 크다는 것이고, 반대방향은 v보다 u가 확실히 키가 작다는 정보를 주기 때문입니다.

둘 다 아니라면 u, v의 키 관계를 알 수 없게 됩니다.



**11562번: 백양로 브레이크 (★)**

알고스팟 등의 문제를 풀어봤다면 이 문제도 쉽게 풀 수 있습니다. 아마...

건물 s에서 건물 e로 갈 때 양방향으로 바꿔야 하는 길의 최소 개수란, 현재 그래프에서 거쳐야 하는 역방향 간선의 최소 개수를 말하겠죠.

따라서 (u->v)로 가는 길이 존재하고 그 길이 양방향이라면 dist[u][v] = dist[v][u] = 0, 아니라면 dist[u][v]만 0이고 dist[v][u]는 1로 두면 됩니다. 역방향으로 v에서 u로 가려면 이 길을 양방향으로 바꿔야 하니까요.



**1507번: 궁금한 민호 (★)**

플로이드가 최단경로를 갱신하는 방법을 반대로 이용하면 됩니다.

만약 dist[i][j] = dist[i][k] + dist[k][j]라면, 어차피 i->k->j로 우회해 간 거리가 원래의 최단거리이므로 i->j로 바로 가는 간선을 지워버려도 됩니다.

이렇게 해서 간선을 지울 수 있는 만큼 모두 지우는데, 만약 중간에 dist[i][j]보다 dist[i][k] + dist[k][j]가 더 작은 경우가 존재할 경우 모순입니다.



