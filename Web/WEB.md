# WEB

>   참고 : https://github.com/gyoogle/tech-interview-for-developer
>
>   전반적인 흐름은 gyoogle님의 깃허브를 참고하였으며, 추가 레퍼런스는 글을 진행하며 알려드릴 것입니다. 파이팅 !

# 브라우저 동작 방법

---

*브라우저가 어떻게 동작하는지 아세요?*

웹서핑을 하다보면 우리는 여러 url을 통해 사이트를 돌아다닌다. 이 url이 입력되었을 때 어떤 과정을 거쳐서 출력되는걸까?

`WEB`의 기본적인 개념이지만 설명하기 어려울 것이다.. 렌더링? 파싱?

브라우저 주소 창에 [http://naver.com](http://naver.com/)을 입력했을 때 어떤 과정을 거쳐서 네이버 페이지가 화면에 보이는 지 알아보자



## 브라우저 주요 기능

-   사용자가 선택한 자원을 서버에 요청하여 브라우저에 표시된다.
-   자원은 html 문서, pdf, image 등 다양한 형태가 있다.
-   자원의 주소는 `url`에 의해 정해진다.

브라우저는 html과 css 명세에 따라 html 파일을 해석해서 표시한다.

이 '명세'는 웹 표준화 기구인 `W3C(World Wide Web Consortium)`에서 정해진다.

>   예 전 브라우저들은 일부만 명세에 따라 구현하고 독자적 방법으로 확장했는데, 그러다보니 심각한 호환성 문제가 발생하여 요즘은 대부분 표준 명세를 따른다.

브라우저가 가진 인터페이스는 비슷비슷한 요소들이 있다. 시간이 지나면서 사용자에게 필요한 서비스들로 서로 모방하며 갖춰지게 된것이다.
(ex. URl를 입력하는 주소 표시줄, 버튼, 북마크, 새로고침 버튼, 홈버튼 등...)



## 브라우저 기본 구조

[![img](https://camo.githubusercontent.com/0e3ac4e617b8eda5046f592c74a1f7e4cbfb82a5c6abe8d5699020002c1227b6/68747470733a2f2f64322e6e617665722e636f6d2f636f6e74656e742f696d616765732f323031352f30362f68656c6c6f776f726c642d35393336312d312e706e67)](https://camo.githubusercontent.com/0e3ac4e617b8eda5046f592c74a1f7e4cbfb82a5c6abe8d5699020002c1227b6/68747470733a2f2f64322e6e617665722e636f6d2f636f6e74656e742f696d616765732f323031352f30362f68656c6c6f776f726c642d35393336312d312e706e67)

-   `사용자 인터페이스`
    -   주소 표시줄, 이전/다음 버튼, 북마크 등 사용자가 활용하는 서비스들 (요청한 페이지를 보여주는 창을 제외한 나머지)부분
-   `브라우저 엔진`
    -   사용자 인터페이스와 렌더링 엔진 사이의 동작 제어
-   `렌더링 엔진`
    -   요청한 콘텐츠 표시 (html 요청이 들어오면 -> html, css 파싱해서 화면에 표시)
-   `통신`
    -   http요청과 같은 네트워크 호출에 사용(플랫폼의 독립적인 인터페이스로 구성되어 있다)
-   `UI 백엔드`
    -   플랫폼에서 명시하지 않은 일반적 인터페이스. 콤보 박스 창 같은 기본적 장치를 그린다.
-   `자바스크립트 해석기`
    -   자바스크립트 코드를 해석하고 실행하낟
-   `자료 저장소`
    -   쿠키 등 모든 자원을 하드 디스크에 저장하는 계층



## 렌더링이란?

웹 분야를 공부하다 보면**렌더링**이라는 말을 많이 볼 것이다.

렌더링 엔진은 요청 받은 내용을 브라우저 화면에 표시해준다.

기본적으로 html, xml 문서와 미지를 표시할 수 있다.

추가로 플러그인이나 브라우저 확장 기능으로 pdf 등 다른 유형도 표시가 가능하다
(추가로 확장이 필요한 유형은 바로 뜨지 않고 팝업으로 확장 여부를 묻는 것을 볼 수 있을 것이다.)



### 렌더링 엔진 종류

-   `크롬, 사파리` : **웹킷(Webkit)** 엔진 사용
-   `파이어 폭스` : **게코(Gecko)** 엔진 사용

```bash
# 웹킷 엔진
최초의 리눅스 플랫폼에 동작하기 위한 오픈소스 엔진
(애플이 맥과 윈도우에서 사파리 브라우저를 지원하기 위해 수정을 더했음)
```



### 렌더링 동작 과정

[![img](https://camo.githubusercontent.com/b7b2e4f87463a5508b6cc434e99d58c48b5b8ba1aa8a4d917d9d240fd94aebf1/68747470733a2f2f64322e6e617665722e636f6d2f636f6e74656e742f696d616765732f323031352f30362f68656c6c6f776f726c642d35393336312d322e706e67)](https://camo.githubusercontent.com/b7b2e4f87463a5508b6cc434e99d58c48b5b8ba1aa8a4d917d9d240fd94aebf1/68747470733a2f2f64322e6e617665722e636f6d2f636f6e74656e742f696d616765732f323031352f30362f68656c6c6f776f726c642d35393336312d322e706e67)

1.  먼저 html 문서를 파싱한다.
2.  콘텐츠 트리 내부에서 태그를 모두 `DOM` 노드로 변환한다.
3.  외부 css파일과 함께 포함된 스타일 요소를 파싱한다.
4.  이 스타일 정보와 html 표시 구칙은 렌더 트리라고 부르는 또 다른 트리를 생성한다.
5.  이렇게 생성된 렌더트리는 정해진 순서대로 화면에 포시되는데, 생성 과정이 끝났을 때 배치가 진행되면서 노드가 화면의 정확한 위치에 표시되는 것을 의미한다.
6.  이후에 `UI 백엔드`에서 렌더 트리의 각 노드를 가로지으며 형상을 만드는 그리기 과정이 진행된다.
7.  이러한 과정이 점진적으로 진행되며, 렌더링 엔진은 좀더 빠르게 사용자에게 제공하기 위해  모든 HTML을 파싱할 때까지 기다리지 않고 배치와 그리기 과정을 시작한다. (마치 비동기 처럼?)
8.  전송을 받고 기다리는 동시에 받은 내용을 먼저 화면에 보여준다.
    (우리가 웹페이지에 접속할 때 한꺼번에 뜨지 않고 점점 화면에 나오는 것이 이 때문이다)



## DOM 이란?

>   Document Object Model(문서 객체 모델)

웹페이지 소스를 까보면 `<html>, <body>`와 같은 태그들이 존재한다. 이를 `Javascript`가 활용할 수 있는 객체로 만들면 바로 `문서 객체`가 된다.

모델은 말 그대로 모듈화로 만들었다거나 객체를 인식한다라고 해석하면 된다.

즉, **`DOM은 웹 브라우저가 html페이지를 인식하는 방식`**을 말한다.(트리 구조)



## 파싱과 DOM 트리 구축

파싱은 렌더링 엔진에서 매우 중요한 과정이다.

**`파싱(parsing)`**

문서 파싱은 브라우저가 코드를 이해하고 사용할 수 있는 구조로 변환하는 것이다.

문서를 가지고, **어휘 분석과 구문 분석 과정**을 거쳐 파싱 트리를 구축한다.

어휘 분석기를 통해 언어의 구문 규칙에 따라 문서 구조를 분석한다. 이 과정에서 구문 규칙과 일치하는 지 비교하고, 일치하는 노드만 파싱 트리에 추가시킨다.
(끝까지 규칙이 맞지 않는 부분은 문서가 유효하지 않고 구문 오류가 포함되어 있다는 것 !)

파서 트리가 나왔다고 해서 끝이 아니고, 컴파일의 과정일 뿐, 다시 기계코드 문서로 변환시키는 과정까지 완료되면 최종 결과물이 나온다.

보통 이런 **파서(Parser)**를 생성하는 것은 문법에 대한 규칙 부여 등 복잡하고 최적화 하기 힘드므로, 자동으로 생성해주는 **파서 생성기**를 많이 활용한다.

>   웹킷은 플렉스(flex)나 바이슨(bison)을 이용하여 유용하게 파싱이 가능하다.

우리가 head 태그를 실수로 빠트려도, 파서가 돌면서 오류를 수정해준다.(head 앨리먼트 객체를 암묵적으로 만들어준다.)

결국 이 파싱 과정을 거치면서 서버로부터 받은 문서를 브라우저가 이해하고 쉽게 사용할 수 있는 `DOM 트리구조`로 변환시켜주는 것이다.



## 요약

-   주소창에 url을 입력하고 Enter를 누르면 **서버에 요청이 전송**됨
-   해당 페이지에 존재하는 여러 자원들(text, image 등)이 보내짐
-   이제 브라우저는 해당 자원이 담긴 `html`과 스타일이 담긴 `css`를 `W3C`명세에 따라 해석함
    -   이 역할을 하는 것이 **렌더링 엔진**
    -   렌더링 엔진은 우선 `html` 파싱 과정을 시작함. html 파서가 문서에 존재하는 어휘와 구문을 분석하면서 `DOM 트리`를 구축
    -   다음엔 `css` 파싱 과정 시작. css 파서가 모든 csㄴ 정보를 스타일 구조체로 생성
    -   이 2가지를 연결시켜 **렌더 트리**를 만든다. 렌더 트리를 통해 문서가 시각적 요소를 포함한형태로 구성된 상태
-   화면에 배치를 시작하고 `UI 백엔드`가 노드를 돌며 형상을 그린다.
-   이 때 빠른 브라우저 화면 표시를 위해 '배치와 그리는 과정'은 페이지 정보를 모두 받고 한꺼번에 진행되지 않는다. 자원을 전송받으면, **기다리는 동시에 일부분 먼저 진행하고 화면에 표시한다.**

# 쿠키 & 세션

---

>   Cookie & Session

|          |                     Cookie                      |     Session      |
| :------: | :---------------------------------------------: | :--------------: |
| 저장위치 |                     Client                      |      Server      |
| 저장형식 |                      Text                       |      Object      |
| 만료시점 | 쿠키 저장시 설정 (설정 없으면 브라우저 종료 시) | 정확한 시점 모름 |
|  리소스  |               클라이언트의 리소스               |  서버의 리소스   |
| 용량제한 |        한 도메인 당 20개, 한 쿠키당 4KB         |     제한없음     |

## 저장 위치

-   쿠키 : 클라이언트의 웹 브라우저가 지정하는 메모리 or 하드디스크
-   세션 : 서버의 메모리에 저장

## 만료 시점

-   쿠키 : 저장할 때 expires 속성을 정의해 무효화시키면 삭제될 날짜 정할 수 있음
-   세션 : 클라이언트가 로그아웃하거나, 설정 시간동안 반응이 없으면 무효화 되기 때문에 정확한 시점 알 수 없음

## 리소스

-   쿠키 : 클라이언트에 저장되고 클라이언트의 메모리를 사용하기 때문에 서버 자원 사용하지 않음
-   세션 : 세션은 서버에 저장되고, 서버 메모리로 로딩 되기 때문에 세션이 생길 때마다 리소스를 차지함

## 용량 제한

-   쿠키 : 클라이언트도 모르게 접속되는 사이트에 의하여 설정될 수 있기 때문에 쿠키로 인해 문제가 발생하는 걸 막고자 한 도메인당 20개, 하나의 쿠키 당 4KB로 제한해 둠
-   세션 : 클라이언트가 접속하면 서버에 의해 생성되므로 개수나 용량 제한 없음

# HTTP status code

---

>   클라우드 환경에서 HTTP API를 통신하는 것이 대부분이다.
>
>   이 때, 응답 상태 코드를 통해 성공/실패 여부를 확인할 수 있으므로 API 문서를 작성할 때 꼭 알아야 하는 것이 **HTTP status code**이다.
>
>   -   10x : 정보 확인
>   -   20x : 통신 성공
>   -   30x : 리다이렉트
>   -   40x : 클라이언트 오류
>   -   50x : 서버 오류

-   200번대 : 통신성공

    | 상태코드 |    이름     |           의미           |
    | :------: | :---------: | :----------------------: |
    |   200    |     OK      |      요청 성공(GET)      |
    |   201    |   Create    |     생성 성공(POST)      |
    |   202    |  Accepted   | 요청 접수O, 리소스 처리X |
    |   204    | No Contents |  요청 성공O, 내용 없음   |

-   300번대 : 리다이렉트

    | 상태코드 |       이름       |             의미              |
    | :------: | :--------------: | :---------------------------: |
    |   300    | Multiple Choice  | 요청 URI에 여러 리소스가 존재 |
    |   301    | Move Permanently |  요청 URI가 새 위치로 옮겨감  |
    |   304    |   Not Modified   |    요청 URI의 내용이 변경X    |

-   400번대 : 클라이언트 오류

    | 상태코드 |        이름        |               의미                |
    | :------: | :----------------: | :-------------------------------: |
    |   400    |    Bad Request     | API에서 정의되지 않은 요청 들어옴 |
    |   401    |    Unauthorized    |             인증 오류             |
    |   403    |     Forbidden      |        권한 밖의 접근 시도        |
    |   404    |     Not Found      |   요청 URI에 대한 리소스 존재X    |
    |   405    | Method Not Allowed | API에서 정의되지 않은 메소드 호출 |
    |   406    |   Not Acceptable   |             처리 불가             |
    |   408    |  Request Timeout   |        요청 대기 시간 초과        |
    |   409    |      Conflict      |               모순                |
    |   429    |  Too Many Request  |        요청 횟수 상한 초과        |

-   500번대 : 서버오류

    | 상태코드 |         이름          |         의미         |
    | :------: | :-------------------: | :------------------: |
    |   500    | Internal Server Error |    서버 내부 오류    |
    |   502    |      Bad Gateway      |   게이트웨이 오류    |
    |   503    |  Service Unavailable  |   서비스 이용 불가   |
    |   504    |    Gateway Timeout    | 게이트웨이 시간 초과 |

# REST API

>   REST : 웹 (HTTP)의 장점을 활용한 아키텍쳐
>
>   **REpresentationaal State Transfer**



## REST란

***REST의 정의***

-   자원을 이름(자원의 표현)으로 구분하여 해당 자원의 상태(정보)를 주고 받는 모든 것을 의미.
-   즉, 자원(resource)의 표현(representation)에 의한 상태 전달
    -   **자원(resource)의 표현(representation)**
        -   `자원` : 해당 소프트가 관리하는 모든 것
            ex)  문서, 그림, 데이터, 소프트웨어 자체 등
        -   `자원의 표현` : 그 자원을 표현하기 위한 이름
            ex) DB의 학생 정보가 자원일 때, 'students'를 자원의 표현으로 정한다.
    -   **상태(정보) 전달**
        -   데이터가 요청되어지는 시점에서 자원의 상태(정보)를 전달한다.
        -   `JSON` 혹은 `XML`을 통해 데이터를 주고받는 것이 일반적
-   월드 와이드 웹(www)과 같은 분산 하이퍼 미디어 시스템을 위한 소프트웨어 개발 아키텍처의 한 형식
    -   `REST`는 기본적으로 웹의 기존 기술과 `HTTP` 프로토콜을 그대로 활용하기 때문에 **웹의 장점을 최대한 활용할 수 있는 아키텍처 스타일이다.**
    -   `REST`는 네트워크 상에서 Client와 Server 사이의 통신 방식 중 하나이다.



***REST의 구체적인 개념***

-   **`HTTP URI`**(Uniform Resource Identifer)를 통해 자원(Resource)를 명시하고, **`HTTP Method`**(POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 `CRUD` Operation을 적용하는 것을 의미한다.
    -   즉, REST는 자원 기반의 구조(ROA) 설계의 중심에 Resource가 있고 `HTTP` Method를 통해 Resource를 처리하도록 설계된 아키텍쳐를 읨미한다.
    -   웹 사이트의 임미지, 텍스트, DB 내용 등의 모든 자원에 고유한 ID인 `HTTP URI`를 부여한다.
    -   **CRUD Operation**
        -   `CREATE` : 생성(POST)
        -   `READ`: 조회(GET)
        -   `UPDATE` : 수정(PUT)
        -   `DELETE` : 삭제(DELETE)
        -   `HEAD` : header 정보 조회(HEAD)



## REST의 요소

-   `Method`

    | Method |  의미  | Idempotent |
    | :----: | :----: | :--------: |
    |  POST  | Create |     No     |
    |  GET   | Select |    Yes     |
    |  PUT   | Update |    Yes     |
    | DELETE | Delete |    Yes     |

    `Idempotent` : 한번 수행 하나, 여러 번 수행했을 때 결과가 같나?

-   `Resource`

    -   http://myweb/users와 같은 URI
    -   모든 것을 `Resource(명사)`로 표현하고, 세부  `Resource`에는 id를 붙인다.

-   `Message`

    -   메시지 포맷이 존재

        :`JSON, XML`과 같은 형태가 있다. (최근에는 `JSON`을 많이 사용한다)

        ```json
        HTTP POST, httmp://myweb/users/
        {
        	"users" : {
                "name" : "sunghyun"
            }
        }
        ```



## REST 특징

-   `Uniform Interface`

    -   HTTP 표준만 맞는다면, 어떤 기술도 가능한 Interface 스타일

        ex ) REST API 정의를 `HTTP + JSON`으로 하였다면, C, JAVA, Python, IOS 플랫폼 등 특정 언어나 기술에 종속받지 않고, 모든 플랫폼에 사용이 가능한 **Lossely Coupling 구조**

    -   포함

        -   Self-Descriptive Messages
            -   API 메시지만 보고, API를 이해할 수 있는 구조
                (Resocure, Method를 이용해 무슨 행위를 하는지 직관적으로 이해할 수 있다)
        -   **`HATEOS`(Hyptermdediaa As The Engine Of Applicaation State)**
            -   Applicaation의 상태(State)는 Hyperliink를 통해 전이되어야 함
            -   서버는 현재 이용 가능한 다른 작업에 대한 하이퍼링크를 포함하여 응답해야 함.
        -   Resource Identification In Request
        -   Resource Manipulation Through Representations

-   `Statelessness`

    -   즉, HTTP Session과 같은 컨텍스트 저장소에 **상태 정보 저장 안함**
    -    **Request만 Message로 처리**하면 되고, 컨텍스트 정보를 신경쓰지 않아도 되므로, **구현이 단순하다**
    -   따라서, REST AAPI 실행 중 실패가 발생한 경우, `Transaction` 복구를 위해 기존의 상태를 저장할 필요가 없다.(**POST Method 제외**)

-   `Resource 지향 아키텍쳐` (**`ROA` : Resoucre Oriented Architecture**)

    -   Resource 기반의 복수형 명사 형태의 정의를 군정한다.

-   `Clinet-Server Architecture`

-   `Cache Ability`

-   `Layered System`

-   `Code On Demand(Opitonal)`