# Spring Framework

- [객체 지향 프로그래밍: OOP](#oop)
- [서블릿: Servlet](#servlet)
- [JSP](#jsp)
- [POJO](#pojo)
- [MVC 패턴이 무엇인가](#mvc-패턴)
- [Spring MVC](#spring-mvc)
- [의존성 주입: DI](#di)

# OOP

---

[위로](#spring-framework)

> Object-Oriented Programming

객체지향 패러다임이 나오기 이전의 패러다임들부터 간단하게 살펴보자.

패러다임의 발전 과정을 보면 점점 개발자들이 편하게 개발할 수 있도록 개선되고 있다는 것을 알 수 있다.

가장 먼저, **순차적, 비 구조적 프로그래밍**이 있다. 말 그대로 순차적으로 코딩하는 것이다.

필요한 게 있으면 계속 순서대로 추가해가며 구현하는 방식이다. 직관적이야 하겠지만 점점 규모가 커지면 어떻게 될까?



이러한 **순차적, 비 구조적 프로그래밍에서는 goto문을 활용한다.**

만약 이전에 작성했던 코드가 다시 필요하면 그 곳으로 이동하기 위한 것이다. 규모가 커지면 커질수록 `goto`문을 무분별하게 사용하게 되고, 마치 스파게티 처럼 베베 꼬이게 된다.(스파게티 코드). 나중에 코드가 어디가 어떻게 연결되어 있는지 확인하기 조차 어렵게 되는 문제점이 발생한다.

오늘날 공부하면서 **goto문은 사용하지 않는게 좋다!**라는 말을 들어봤을 것이다. `goto`문은 장기적으로 봤을 때 도움이 되지 않는 방식이라는 것은 자명하기 때문이다.



이런 문제점을 해결하기 위해 탄생한 것이 바로 **절차적, 구조적 프로그래밍**이다.

**반복될 가능성이 있는 것들을 재사용이 가능한 함수(프로시저)로 만들어 사용**하는 프로그래밍 방식이다.

여기서 '절차'라는 의미는 **함수(프로시저)**를 뜻하고, 구조는 **모듈**을 뜻한다. 모듈이 함수보다 더 작은 의미긴 하지만, 요즘은 큰 틀로 같은 의미로 쓰인다.

> ***프로시저란?***
>
> 반환값(리턴)이 따로 존재하지 않는 함수를 말한다.
>
> 예를들면, `printf`와 같은 함수는 반환값을 얻기 위한 것보단, 화면에 출력하는 용도로 쓰이는 함순데, 이와 같은 함수를 프로시저라 부른다.
> (정확히는 `printf`는 `int`형을 반환하긴 하지만, 목적 자체는 프로시저에 가깝다.)

하지만 이런 절차적 프로그래밍에도 문제점이 존재하는데, **`너무 추상적`**이라는 것이다.

실제로 사용되는 프로그램들은 추상적이지만은 않다. 함수는 논리적 단위로 표현되지만, 실제 데이터에 해당하는 변수나 상수 값들은 물리적 요소로 연결되어 있기 때문이다.



도서 관리 프로그램이 있다고 가정해보자.

책에 해당하는 자료형(필드)를 구현해야 한다. 또, 책과 관련된 함수도 구현해야 한다. 구조적인 프로그래밍에서는 이들을 따로 만들어야 한다.

결국 많은 데이터를 만들어야 할 때, 구분하기 힘들고 비효율적으로 코딩할 가능성이 높아진다.

> 책에 대한 자료형, 책에 대한 함수가 물리적으로 같이 있을 수 는 있지만(같은 위치에 기록)
>
> 논리적으로는 함께할 수 없는 구조가 **구조적 프로그래밍**이다.

따라서, 이를 한 번에 묶기 위한 패러다임이 탄생한다.



바로 **객체지향 프로그래밍이다.**

우리가 `VO`를 만들때와 같은 형태다.

클래스마다 필요한 필드르 선언하고, `getter`와 `setter`로 구성된 모습으로 해결한다. 바로 **특정한 개념의 함수와 자료형을 함께 묶어서 관리하기 위해 탄생**한 것이다.

가장 중요한 점은, **객체 내부에 자료형(필드)와 함수(메소드)가 같이 존재하는 것**이다.

이제 도서관리 프로그램을 만들 때, 책의 제목, 저자, 페이지와 같은 **`자료형`**과 읽기, 예약하기 등 **`메소드`**를 `책`이라는 **객체**에 한번에 묶어서 저장하는 것이 가능해졌다.

이처럼 가능한 모든 물리적, 논리적 요소를 하나의 객체로 만드려는 것이 `객체지향 프로그래밍`이라 할 수 있다.

객체지향 프로그래밍을 사용하게 되면, 객체간의 독립성이 생기고 중복코드의 양이 줄어드는 장점이 있따. 또한, 독립성이 확립되면 유지보수에도 도움이 될 것이다.



## 특징

객체 지향의 패러다임이 생겨나면서 크게 4가지 특징을 갖추게 되었다.

이 4가지 특징을 잘 이해하고 구현해야 객체를 통한 효율적인 프로그래밍이 가능해진다.



### 1. 추상화

> Abstraction
>
> 필요로 하는 속성이나 행동을 추출하는 작업

추상적인 개념에 의존하여 설계해야 유연함을 갖출 수 있다.

즉, 세부적인 사물들의 공통적인 특징을 파악한 후 하나의 집합으로 만들어내는 것이 추상화이다.

```bash
아우디, 벤츠, BMW는 모두 '자동차'라는 공통점이 있다.
자동차라는 추상화 집합을 만들고, 자동차들이 가진 공통적인 '특징'들을 만들어 활용한다.

예를 들면, 현대와 같은 다른 자동차 브랜드가 추가될 수 있다.
이 때 추상화로 구현해 두면 다른 곳의 코드는 수정할 필요 없이 추가되는 부분만 새로 생성해주면 된다.
```



#### - 특징

* 추상클래스 - `abstract`의 의미
  * 미완성된 클래스, 모든 내용이 구현이 되어있지 않은 클래스로 완성되지 않았으므로 객채생성을 할 수 없다.
  * 메소드의 body가 구현되지 않은 메소드를 갖고 있는 클래스(추상메소드)
* 추상 메소드를 선언하는 방법
  * 접근제어자 abstract 리턴타입 메소드명(매개변수 list 1, 2, 3, ...)
  * 추상메소드가 정의된 클래스는 미완성된 추상클래스가 되므로, 일반클래스와 다르다.
  * 따라서, 추상클래스를 정의하는 경우 클래스 선언부에도 abstract을 추가해야 한다.
* 추상 클래스의 특징
  * 일반메소드와 추상메소드 모두 정의할 수 있다.
  * 내가 기능을 작성하는게 아니라 하위클래스에서 기능을 한다.
  * 추상메소드가 한 개라도 정의되어 있는 클래스는 반드시 abstract을 추가해야 한다.
  * 추상클래스는 인스턴스화 할수 없다.(객체 생성 불가능)
  * 추상클래스(abstract클래스)를 상속하면 에러가 발생한다?
  * AbstractSub클래스가 abstract메소드를 갖고있는 AbstractSuper클래스를 상속하면서 AbstarctSub클래스도 추상클래스로 변경된 것이다.
  * [해결방법]
    * 상위클래스로 사용될 목적으로 만들어진 클래스라면 클래스 선언부에 abstract을 추가한다.
    * 모든 "추상메소드"를 반드시 오버라이딩해야 한다.
* 추상클래스와 추상메소드를 사용하는 이유?
  * **다형성을 정의하기 위해**
  * 상위클래스로 사용하기 위한 목적(객채생성을 문법적으로 제한하기 위해)
  * 하위클래스에서 반드시 재정의해야하는 메소드를 문법적으로 정의하여 반드시 재정의하도록 하기위해





### 2. 캡슐화

> Encapsulation
>
> 낮은 결합도를 유지할 수 있도록 설계하는 것

**쉽게 말하면, 한 곳에서 변화가 일어나도 다른 곳에 미치는 영향을 최소화 시키는 것**을 말하낟.

객체가 내부적으로 기능을 어떻게 구현하는지 감추는 것이다.



결합도가 낮게 만들어야 하는 이유가 무엇일까?

여기서 **결합도(coupling)이란, 어떤 기능을 실행할 때 다른 클래스나 모듈에 얼마나 의존적인가를 나타내는 정도**이다.

즉, 독립적으로 만드어진 객체들간의 의존도가 최대한 낮게 만드는 것이 중요하다. 객체들 간의 의존도가 높아지면 굳이 객체지향으로 설계하는 의미가 옅어지기 때문이다.

우리는 소프트웨어 공학에서 **객체 안의 모듈 간의 요소가 밀접한 관련이 있는 것으로 구성하여 응집도를 높이고 결합도를 줄여야 요구사항 변경에 대처하는 좋은 설계 방법**이라고 배운다.

이것이 바로 **`캡슐화`**와 연관된 부분이라고 할 수 있다.



그렇다면 캡슐화는 어떻게 **높은 응집도**와 **납은 결합도**를 갖게 할까?

바로 **정보 은닉**을 활용하는 것이다.

외부에서 접근할 필요가 없는 것들은 **`private`**으로 접근하지 못하도록 제한을 두는 것이다.

객체안의 필드를 선언할 때는 `private`으로 선언하라는 말이 바로 이 때문이다.



### 3. 상속

> 일반화 관계(Generalization)이라고도 하며, 여러 개체들이 지닌 공통된 특성을 부각시켜 하나의 개념이나 법칙으로 성립하는 과정이다.

일반화(상속)은 또 다른 캡슐화다.

**자식 클래스를 외부로부터 은닉하는 캡슐화의 일종**이라고 말할 수 있다.



아까 자동차를 예로 들어 추상화를 설명했다. 여기에 추가로 대리 운전을 하는 사람 클래스가 있다고 생각해보자.

이 떄, 자동차의 자식 클래스에 해당하는 벤츠, BMW, 아우디 등은 캡슐화는 통해 은닉해둔 상태이다.

사람 크랠스의 관점으로는 구체적인 자동차의 종류가 숨겨져 있는 상태이다. 대리 운전자 입장에서는 자동차의 종류가 어떤 것인지는 운전하는 데 크게 중요하지 않다.

새로운 자동차들이 추가된다고 해도, 사람 클래스는 영향을 받지 않는 것이 중요하다. 그러므로 **캡슐화**를 통해 사람 클래스 입장에서는 확인할 수 없도록 구현하는 것이다.



이처럼, 상속 관계에서는 단순히 하나의 클래스 안에서 속성 및 연산들의 캡슐화에 한정되지 않는다. 즉, 자식 클래스 자체를 캡슐화하여 `'사람 클래스'와 같은 외부에 은닉하는 것으로 확장되는 것이다.

이렇게 자식 클래스를 캡슐화 해두면, 외부에선 이러한 클래스들에 영향을 받지 않고 개발을 이어갈 수 있는 장점이 있다.



#### - 상속 재사용의 단점

1. 상위 클래스(부모 클래스)의 변경이 어려워 진다.
   - 부모 클래스에 의존하는 자식 클래스가 많을 때, 부모 클래스의 변경이 필요하다면 이를 의존하는 자식 클래스들이 영향을 받게 된다.
2. 불필요한 클래스가 증가할 수 있다.
   - 유사기능 확장 시, 필요 이상의 불필요한 클래스를 만들어야 하는 상황이 발생할 수 있다.
3. 상속이 잘못 사용될 수 있다.
   - 같은 종류가 아닌 클래스의 구현을 재사용하기 위해 상속을 받게 되면, 문제가 발생할 수 있다.
   - 상속 받는 클래스가 부모 클래스와 **`IS-A`** 관계가 아닐 때 이에 해당한다.



#### - 해결책

객체 조립(`Compostion`), 컴포지션이라고 부른다.

객체 조립은, **필드에서 다른 객체를 참조하는 방식으로 구현**된다.

상속에 비해 비교적 런타임 구조가 복잡해지고, 구현이 어려운 단점이 존재하지만 변경 시 유연함을 확보하는 데 장점이 매우 크다.

따라서 같은 종류가 아닌 클래스를 상속하고 싶을 때는 객체조립을 우선적으로 적용하는 것이 좋다.

> ***그럼 상속은 언제 사용해?***
>
> - `IS-A` 관계가 성립할 때
> - 재사용 관점이 아닌, 기능의 확장 관점일 때



#### - 특징

* 상속관계에서 **`멤버변수`**가 갖는 특징

  1. 상속관계에서는 상위클래스에서 정의된 멤버변수를 하위클래스에서 사용할 수 있다.

     (하위클래스 참조 변수를 통해서 접근할 수 있다.)

  2. 상위클래스의 변수와 동일한 이름의 변수를 하위클래스에 정의하는 경우 하위클래스의 멤버변수가 우선순위가 높다.

  3. 부모클래스의 변수를 액세스 하려면 super를 이용해서 접근한다.

     * this - 자기자신의 객체
     * super - 부모 객체

  4. private으로 선언된 변수는 상속관계에 있다고 하더라도 하위클래스에서 접근할 수 없다.

  5. 상위클래스는 하위클래스의 일반적인 내용을 정의하기 위해서 사용하는 클래스이므로 주로 하위클래스를 생성해서 사용한다.

  6. 상위클래스를 쓰는게 아니라 하위클래스(자식)를 쓰는 것이다.

* 상속관계에서 **`메소드`**가 갖는 특징

  1. 상속관계에서는 상위클래스에 정의된 메소드를 하위클래스에서 사용할 수 있다.

     (하위클래스 참조 변수를 통해서 접근할 수 있다.)

  2. 상위클래스에 정의된 메소드와 동일한 메소드를 하위클래스에서 정의하고 사용할 수 있다. 이런 경우 하위클래스의 메소드가 호출된다.

     * 메소드를 재정의 했으면 부모보다 재정의한 메소드가 우선인식된다.

     * 상위클래스에 선언된 메소드와 동일한 메소드를 하위클래스에 정의하는 것을 메소드 재정의

       (*메소드 오버라이딩*)이라고 한다.

       * 메소드 선언부가 부모클래스의 메소드 선언부와 반드시 일치해야한다.

         => 메소드명, 매개변수 갯수, 매개변수 타입, 리턴타입이 모두 동일해야한다

  3. 부모클래스의 메소드를 사용하고 싶은 경우 super로 호출한다.

  4. 모든 클래스의 첫째줄에는 자동으로 object가 상속되어 있다.

* 상속관계에서 **`생성자`**가 갖는 특징

  1. 클래스의 모든 생성자메소드의 첫 번째 문장에는 부모클래스의 기본 생성자를 호출하는 명령문이 생략되어 있다.
     * 부모클래스도 메모리에 할당되어야 사용할 수 있으므로
     * 부모의 생성자를 호출하는 방법은 super(...)
       - super()는 부모의 매개변수 없는 기본 생성자
     * 이미 다른 생성자를 호출하는 경우에는 super()를 할 수없다.
       * this()를 호출하는 경우 super를 호출할 수 있다.
  2. 모든 클래스의 최상위 클래스는 java.lang.Object이다.
     * 자바에서 실행되는 모든 객체가 갖는 공통의 특징을 정의한 클래스로 상속받고 있는 클래스가 없는 경우 컴파일러가 자동으로 상속하도록 한다.
  3. 부모클래스에 정의되어 있는 멤버변수가 값을 셋팅해야 하는 경우에도 하위클래스에서 전달될 수 있도록 정의한다.
     * super(값1, 값2, .....)를 통해 접근한다





### 4. 다형성

> Polymorphism
>
> 서로 다른 클래스가 객체가 같은 메세지를 받았을 때 각자의 방식으로 동작하는 능력
>
> 상속, 오버라이딩, 추상클래스, 객체의 형번환과 같은 개념들의 총체적 융합이다.

객체지향의 핵심과도 같다.

다형성은, 상속과 함께 활용할 때 큰 힘을 발휘한다. 코드를 간결하게 해주며 유연함을 갖추게 해준다.

**부모 클래스의 메소드를 자식 클래스가 `Overriding(오버라이딩)`해서 자신의 역할에 맞게 활용하는 것이 다형성**이다.

다형성을 사용하면, 구체적으로 현재 어떤 클래스 객체가 참조되는 지는 무관하게 프로그래밍하는 것이 가능하다.

상속관계에 있으면, 새로운 자식 클래스가 추가되어 부모 클래스의 함수를 참조해오면 되기 때문에 다른 클래스는 영향을 받지 않게 된다.



#### - 특징

* 부모타입의 변수로 선언하면 모두 받을 수 있다.

* type이 Parent라면 Parent밖에 접근 못한다.

* 동일한 타입(상위 타입)의 변수를 선언 => 실행시점에 다양한 객체가 실행될 수 있게끔 =>

  => **다양한 객체의 다양한 메소드 실행**(상속관계에 있어야 한다.)

* 유지보수하고 추가된 것들을 반영하기 위해 

* 시스템의 모듈화

* 이 모든것의 베이스는 "`다형성`"을 적용할 수 있기 때문이다. - API가 가장 좋은 예시.

* 결국 상속관계, 클래스 설계를 잘 해야한다.

* **조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 하기위해**





### + 인터페이스

> 추상메소드(상수도 포함)만 정의하는 특별한 클래스

* 인터페이스는 **`interface`**키워드를 이용해서 정의

* 인터페이스는 추상메소드만 정의하는 특별한 클래스

  * public abstract이 생략 가능
  * 상속을 받으면 자동으로 추가된다.

* 인터페이스가 인터페이스를 상속할 수 있다.(extends 이용)

  * 하위 인터페이스가 상위인터페이스의 추상메소드를 상속받는다.

* 클래스가 인터페이스를 상속할 수 있다.(implements 이용)

  * 인터페이스를 상속받는 클래스가 이미 다른클래스를 상속하는 경우에 extends를 먼저 정의하고 implements를 정의해야 한다.

* 인터페이스는 여러개를 상속할 수 있다. 즉, 다중 상속이 가능하다.

  * implements 뒤에서 인터페이스를 정의할 때, " , " 로 구분해서 나열

* 클래스와 인터페이스들을 상속받는 하위클래스는 모든 클래스와 인터페이스의 하위로 인식된다.

  (상속받는 모든 클래스, 인터페이스의 하위 타입이 된다.) - 하위 메소드들에게 스펙을 제시.

* 원래 자바는 단일상속만 가능하지만, 인터페이스를 이용해 다중상속을 구현한다.

>  ***사용목적***
>
> 1. 다중 상속을 허용하고 다형성을 적용할 수 있도록 한다.
> 2. 기본적으로 구현해야 하는 기능이 무엇인지 정의하기 위한 목적



## 객체지향 설계 과정

- 제공해야 할 기능을 찾고 세분화 한다. 그리고 그 기능을 알맞은 객체에 할당한다.
- 기능을 구현하는 데 필요한 데이터를 객체에 추가한다.
- 그 데이터를 이용하는 기능을 넣는다.
- 기능은 최대합 캡슐화하여 구현한다.
- 객체 간에 어떻게 메소드 요청을 주고받을 지 결정한다.



## 객체지향 설계 원칙

> `SOLID` 라고 부르는 5가지 설계 원칙이 존재한다.

1. **SRP(Single Responsibility)** - `단일 책임 원칙`
   - 클래스는 단 한개의 책임을 가져야 한다.
   - 클래스는 변경하는 이유는 단 한개여야 한다.
   - 이를 지키지 않으면 한 책임의 변경에 의해 다른 책임과 관련된 코드에 영향이 갈 수 있다.
2. **OCP(Open-Closed)** - `개방 폐쇄 원칙`
   - 확장에는 열려있어야 하고, 변경에는 닫혀 있어야 한다.
   - 기능을 변경하거나 확장할 수 있으면서, 그 기능을 사용하는 코드는 수정하지 않는다.
   - 이를 지키지 않으면 `instanceof`와 같은 연산자를 사용하거나 다운 캐스팅이 일어난다.
3. **LSP(Liskov Subsitution)** - `리스코프 치환 원칙`
   - 상위 타입의 객체르르 하위 타입의 객체로 치환해도, 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
   - 상속관계가 아닌 클래스들을 상속 관계로 설정하면, 이 원칙이 위배된다.
4. **ISP(Interface Segregation)** - `인터페이스 분리법칙`
   - 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
   - 각 클라이언트가 필요로 하는 인터페이스들을 분리함으로써, 각 클라이언트가 사용하지 않는 인터페이스에 변경이 발생하더라도 영향을 받지 않도록 만들어야 한다.
5. **DIP(Dependency Inversion)** - `의존 역전 법칙`
   - 고수준 모듈을 저수준 모듈의 구현에 의존해서는 안된다.
   - 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다.
   - 즉, 저수준 모듈이 변경돼도 고수준 모듈을 변경할 필요가 없는 것이다.



참조 : https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Software%20Engineering/Object-Oriented%20Programming.md

# Servlet

---

[위로](#spring-framework)

> **클라이언트의 요청을 처리하기 위한 기술.**
>
> 또, 요청에 대한 결과를 반환하는 Servlet 클래스의 구현 규칙을 지킨 자바 웹 프로그래밍 기술
>
> 간단히 말해서, 서블릿이란 자바를 사용해 웹을 만들기 위해 필요한 기술이다.
>
> 즉, 클라이언트가 어떠한 요청을 하면 그에 대한 결과를 다시 전송 해주어야 하는데, 이러한 역할을 하는 자바 프로그램 인 것이다.
>
> 클라이언트로부터 요청이 전달되면 서버에서 실행되며 DB연동이나 서버의 자원을 액세스하여 만들어진 결과를 다시 클라이언트로 응답한다.
>
> 이 클라이언트의 요청을 인식하고 실행하도록 하기 위해서는 서블릿은 **정해진 규칙**대로 작성되어야 하고, 서버가 서블릿을 찾아 실행될 수 있도록 **정해진 위치**에 작성되어야 한다.
>
> > *정해진 위치?*
> >
> > 표준화된 폴더 구조안에 있는 classes 폴더(서블릿 디렉토리)
> >
> > ![89752786-b3c1be80-db10-11ea-94da-d4bb100c5636](https://user-images.githubusercontent.com/58545240/121325922-ffb9db80-c94c-11eb-8363-b14d46620892.png)
>
> - 특징
>   - 클라이언트의 요청에 대해 동적으로 작동하는 웹 어플리케이션 컴포넌트
>   - HTML을 사용하여 요청에 응답한다
>   - Java Thread를 이용해 동작한다.
>   - MVC 패턴에서 Controller로 이용된다.
>   - HTTP 프로토콜 서비스를 지원하는 `javax.servlet.http.HttpServlet` 클래스를 상속받는다.
>   - UDP보다 처리 속도가 느리다.
>   - HTML 변경시 Servlet을 재컴파일해야 하는 단점이 있다.
>
> 
>
> 일반적으로 웹 서버는 정적인 페이지만을 제공하기 때문에 동적인 페이지를 제공하기 위해서 웹 서버는 다른 곳에 도움을 요청해 동적인 페이지를 작성해야 한다.
>
> 동적인 페이지로는 임의의 이미지만을 보여주는 페이지와 같이 사용자가 요청한 시점에 페이지를 생성해서 전달해주는 것을 의미한다.
>
> 여기서 웹서버가 동적인 페이지를 제공할 수 있도록 도와주는 어플리케이션이 **서블릿**이며, 동적인 페이지를 생성하는 어플리케이션이 **CGI**이다.



## 서블릿 동작 방식

![image-20210609133452649](https://user-images.githubusercontent.com/58545240/121325986-119b7e80-c94d-11eb-88b2-9b42904a9fb8.png)

1. 사용자(클라이언트)가 `URL`을 입력하면 `HTTP Request`가 Servlet Container로 전송한다.
2. 요청을 전송받은 Servlet Container는 `HTTPServletRequest, HttpServletResponse` 객체를 생성한다.
3. `web.xml`을 기반으로 사용자가 요청한 `URL`이 어느 서블릿에 대한 요청인지 찾는다.
4. 해당 서블릿에서 service 메소드를 호출한 후 클라이언트의 **GET**, **POST** 여부에 따라 `doGet()` 또는 `doPost()`를 호출한다.
5. `doGet()` or `doPost()` 메소드는 동적 페이지를 생성한 후 `HttpServletResponse` 객체에 응답을 보낸다.
6. 응답이 끝나면 `HTTPServletRequest, HttpServletResponse` 두 객체를 소멸시킨다.



## 서블릿 컨테이너

> 서블릿을 관리해주는 컨테이너
>
> ex) Tomcat

우리가 서버에 서블릿을 만들었다고 해서 스스로 작동하는 것이 아니고, **서블릿을 관리해주는 것**이 필요한데 그러한 역할을 하는 것이 **서블릿 컨테이너**이다.

서브릸이 어떠한 역할을 수행하는 정의서라고 하면, 서블릿 컨테이너는 그 정의서를 수행한다고 볼 수 있다.

서블릿 컨테이너는 **클라이언트의 요청(Request)를 받아주고, 응답(Respone)할 수 있도록, 웹 서버와 소켓으로 통신**하며 대표적인 예로 **`톰캣(Tomcat)`**이 있다.

톰캣은 실제로 웹 서버와 통신하며 `JSP`와 `Servlet`이 작동하는 환경을 제공해준다.



### 역할

1. 웹 서버와의 통신 지원
   - 서블릿 컨테이너는 서블릿과 웹 서버가 손쉽게 통신할 수 있도록 해준다.
   - 일반적으로 우리는 소켓을 만들고 `listen`, `accept` 등을 해야 하지만 서블릿 컨테이너는 이러한 기능을 API로 제공하여 복잡한 과정을 생략할 수 있게 한다.
   - 그래서 개발자가 서블릿에 구현애야 할 비즈니스 로직에 대해서만 초점을 두게끔 한다.
2. 서블릿 생명주기(Life Cycle) 관리
   - 서블릿 컨테이너는 서블릿의 탄생과 죽음을 관리한다.
   - 서블릿 클래스를 로딩하여 인스턴스화 하고, 초기화 메소드를 호출하고, 요청이 들어오면 적절한 서블릿 메소드를 호출한다.
   - 또한, 서블릿이 생명을 다 한 순간에는 적절하게 **Garbage Collection**을 진행하여 편의를 제공한다.
3. 멀티쓰레드 지원 및 관리
   - 서블릿 컨테이너는 요청이 들어올 때마다 새로운 자바 쓰레드를 하나 생성하는데, `HTTP` 서비스 메소드를 실행하고나면, 쓰레드는 자동으로 죽게 된다.
   - 원래는 쓰레드를 관리해야 하지만 서버가 다중 쓰레드를 생성 및 운영해주니 쓰레드의 안정성에 대해 걱정하지 않아도 된다.
4. 선언적인 보안 관리
   - 개발자는 보안에 관련된 내용을 서블릿 또는 자바 클래스에 구현해 놓지 않아도 된다.
   - 일반적으로 보안관리는 `XML` 배포 서술자에 기록하므로, 보안에 대해 수정할 일이 생겨도 자바 소스 코드를 수정하여 다시 컴파일 하지 않아도 보안관리가 가능하다.



### 생명주기

![image-20210609134925916](https://user-images.githubusercontent.com/58545240/121326017-195b2300-c94d-11eb-8af1-0951347a4ff0.png)

1. 클라이언트의 요청이 들어오면 컨테이너는 해당 서블릿이 메모리에 있는지 확인하고, 없을 경우 **`init()`** 메소드를 호출하여 적재한다.
   `init()` 메소드는 처음 한번만 실행되기 때문에, 서블릿의 쓰레드에서 공통적으로 사용해야 하는 것이 있다면 **오버라이딩**하여 구현하면 된다.
   실행 중 서블릿이 변경될 경우, 기존 서블릿을 파괴하고 `init()`을 통해 새로운 내용을 다시 메모리에 적재한다.
2. `init()`이 호출된 후 클라이언트의 요청에 따라서 **`service()`** 메소드를 통해 요청에 대한 응답이 `doGet()`과 `doPost()`로 분기된다.
   이 때, 서블릿 컨테이너가 클라이언트의 요청이 오면 가장 먼저 처리하는 과정으로 생성된 **`HttpServletRequest`, `HttpServletResponse`**에 의해 request와 response 객체가 제공된다.
3. 컨테이너가 서블릿에 종료 요청을 하면 **`destroy()`** 메소드가 호출되는데 마찬가지로 한번만 실행되며, 종료시에 처리해야 하는 작업들을 `destroy()` 메소드를 **오버라이딩**하여 구현하면 된다.



## 서블릿 작성 규칙

1. 표준화된 폴더 구조 안에서 서블릿 디렉토리에 저장되어야 된다. - classes 폴더

   -   ex) **C:\\iot\\setup\\java\\work\\webwork.metadata.plugins\\org.eclipse.wst.server.core\\tmp0\\wtpwebapps\\serverweb\\WEB-INF\\classes**에 작성되어야 한다. => 이 위치에 서블릿 클래스가 없으면 못 찾는다.

2. public 클래스로 작성해야 한다.

   -   서버가 찾아서 실행해야 하므로

3. 서블릿클래스를 상속해야 한다.

   -   서버가 우리가 작성한 서블릿 클래스를 찾아서 생성하고 호출하기 위해서는 서버가 인식할 수 있는(서버가 사용할 수 있는) 타입이어야 하므로 서버가 서버에 등록된 타입으로 서블릿 클래스를 작성한다.
   -   Servlet(인터페이스)이 => **아래 클래스서블릿들을 상속해야 한다.**
       -   GenericServlet(클래스) - 일반적인 내용을 담고 있는 서블릿
       -   HttpServlet(클래스) - http프로토콜에 특화된 내요을 담고 있는 서블릿
       -   MyServlet - 내가 하고 싶은 일을 담고 있는 서블릿(개발자가 만드는 서블릿)
   -   컨테이너 설정 : properties - build path - add library - tomcat9.0 를 설정한다.

4. 서버가 호출하는 메소드가 오버라이딩 해야 한다.

   -   서블릿 클래스는 일반 클래스를 사용하는 방법처럼 객체생성해서 사용하는 클래스가 아니다.
   -   서블릿이 호출되면 서버가 서블릿 객체를 생성하고 적절한 시점에 따라 정해진 메소드를 자동으로 호출한다.
   -   즉, 서블릿의 \_LifeCycle\_을 서버가 관리한다.
   -   _LifeCycle_ ? : 객체를 생성하고 소멸하는 것
   -   서버가 적절한 시점에 따라 자동으로 메소드를 호출할 때 원하는 작업을 처리하기 위해서는 서버가 호출하는 메소드를 오버라이딩해서 내가 원하는 내용을 기술해야 한다.

   **\[오버라이딩할 메소드\]**

   _\- init_ : 서블릿이 초기화될 때 호출

   _\- service_ : 클라이언트가 요청을 하면 호출되는 메소드

    => 클라이언트의 요청을 처리할 수 있는 내용을 기술

    => 요청방식의 구분없이 모두 호출

    ex) 로그인, 게시판 목록보기, 회원가입....

   _\- doGet_ : service와 동일하게 동작하며 클라이언트가 get방식으로 요청하는 경우에만 호출

   _\- doPost_ : service와 동일하게 동작하며 클라이언트가 post방식으로 요청하는 경우에만 호출

   _\- destroy_ : 서블릿 객체가 소멸될 때 (메모리에서 해제될 때) 호출

5. 서블릿을 등록

   -   서버가 서블릿을 찾아서 실행할 수 있도록 서블릿을 web.xml에 등록
   -   _web.xml_? : 서블릿에 대한 내용을 서버에 등록하는 설정파일

   1) 서블릿 등록

   -   사용할 서블릿이 어떤 클래스인지 정의

   ```html
   <servlet>
         <servlet-name>서블릿의 이름(별칭)</servlet-name>
         <servlet-class>실제 사용할 서블릿클래스(패키지 포함)</servlet-class>
   </servlet>
   ```

   ex) basic패키지에 작성한 FirstServlet을 first라는 이름으로 등록

   ```html
   <servlet>
         <servlet-name>First</servlet-name>
         <servlet-class>basic.FirstServlet</servlet-class>
   </servlet>
   ```

   2) 서블릿 매핑

   -   서블릿을 어떤 url로 요청할지 등록

   ```html
   <servlet-mapping>
         <servlet-name>미리등록한 서블릿의 이름</servlet-name>
         <url-pattern>요청url(반드시 /나 .으로 시작)</url-pattern> 
   </servlet-mapping>
   ```

   ex) 위에서 등록한 first서블릿을 /first.multi로 요청

   ```html
   <servlet-mapping>
         <servlet-name>first</servlet-name>
         <url-pattern>/first.html</url-pattern> //path이름은 내맘대로
   </servlet-mapping>
   ```

   => 이렇게 요청하면 first라는 서블릿을 호출할건데 그 first는 basic.FirstServlet에서 만들어진 것이고 그건 basic에 있다.

> xml파일은 다른 플랫폼(파이썬, 닷넷 등등등) 에서 사용하기 위해서 만들어진 문서이고 다소 무거운 단점이 있음. => 그래서 나온게 _JSON_



## 서블릿 요청 방법

### 특징

1. **`get`** 
   : 요청할 때 입력하는 내용이 url 뒤에 추가되어 전송되는 방식(요청메세지 헤더에 추가)

   - 클라이언트가 입력하는 내용이 그대로 노출된다.
   - 전송할 수 있는 데이터의 크기에 제한이 있다.
   - 서버의 데이터를 가져오기

   *ex) 게시판 목록 확인하기, 상품정보 가져오기, 검색하기*

2. **`post`** 
   : 요청메시지 body에 추가되어 전송되므로 클라이언트에 노출되지 않지만 툴을 이용해서 확인하면 확인할 수 있으므로 암호화해서 전송해야 한다.

   - 보낼 수 있는 데이터 크기에 제한이 없다.
   - 서버의 값을 클라이언트가 원하는 값으로 update하는 경우

   *ex) 회원등록(insert문 실행), 회원정보 수정하기(update문 실행), 파일업로드, 메일쓰기*

3. 클라이언트가 전달하는 요청 메시지에서 클라이언트의 입력 정보를 추출하기

   **1) 요청**

   ```bash
   [요청객체]
   -   ServletRequest (상위)
       -   HttpServletRequest (하위)
   ```

   - 클라이언트가 요청 메시지를 서버로 전달하면 여러 가지 클라이언트의 정보가(클라이언트가 입력한 데이터, 쿠키, 세션정보, 클라이언트의 IP, Port...) 서버로 전달된다.
   - 서버는 이 데이터를 가지고 요청객체(요청객체를 만들면서 전달받은 데이터를 요청객체에 셋팅하는 작업을 수행한다.)를 생성한다.
   - http프로토콜에 특화된 내용은 `HttpServletRequset`에서 찾는다.
   - 일반적인 내용은 `ServletRequest`에서 찾는다.

   **2) 요청정보 추출**

   ~~/serverweb/login.do?id=lee&pass=1234

   -   id : 파라미터 name
   -   lee : 파라미터 value



### get 요청

1. 주소표시줄에 입력하고 요청

   - 거의대부분 테스트용으로 사용
   - [http://70.12.115.65:8088/serverweb/first.multi](http://70.12.115.65:8088/serverweb/first.multi)
   - _serverweb_ ? : server.xml에 등록한 path (보통은 context명)
   - _first.multi_ ? : web.xml에 등록한 요청 path ( 에 등록 )

   ```html
   <a href="http://localhost:8088/serverweb/first.multi">받은편지함(하이퍼링크 요청)</a>
   <a href="http://70.12.115.65:8088/serverweb/first.multi">받은편지함(하이퍼링크 요청)</a>
   <a href="/serverweb/first.multi">받은편지함(하이퍼링크 요청)</a>
   ```

2. 하이퍼링크 클릭

   ```html
   <a href="http://서버ip:port:contextpath/서블릿요청url">하이퍼링크</a>
   <a href="/contextpath/서블릿요청url">하이퍼링크</a>
   ```

3. 태그에서 method속성을 "get"으로 설정하고 submit버튼 선택

   - action속성에서 설정한다
   - form태그를 정의하면서 method속성을 생략하면 get방식으로 요청
   - submit버튼을 눌러서 요청하면
     태그의 action속성에 정의한 서블릿이 요청되며
     내부에 정의한 모든 양식태그들의 name과 value가 서블릿으로 전달된다.



### post 요청

1. 태그에서 method속성을 "post"으로 설정하고 submit버튼 선택

   - action속성에서 설정한다

   - form태그를 정의하면서 method속성을 생략하면 get방식으로 요청

   - submit버튼을 눌러서 요청하면

     태그의 action속성에 정의한 서블릿이 요청되며

     내부에 정의한 모든 양식태그들의 name과 value가 서블릿으로 전달된다.

# JSP

---

[위로](#spring-framework)

> Java Server Page
>
> Java코드가 들어가 있는 HTML 코드
>
> Life Cycle은 서블릿과 비슷하다.

서블릿은 자바소스코드 속에 HTML 코드가 들어가는 형태인데, **JSP는 이와 반대로 HTML 소스코드 속에 자바 소스코드가 들어가는 구조**를 갖춘 웹 어플리케이션 프로그래밍 기술이다.

클라이언트의 요청에 대해 동적 컨텐츠를 생성해서 응답결과를 만들어줄 때 사용하는 기술로 html문서에 화면을 작성하는 방법과 동일하게 작성하면 된다.

실행이 될 때 WAS 내부에 있는 JSP 컨테이너에 의해 서블릿으로 변환되서 실행이 되므로 자바코드를 사용할 수 있는 것이다.

## 스크립트 요소

1. `스크립트릿` (Scriptlet)

   ```java
   <% %>
   ```

   - 자바코드를 작성할 수 있는 스크립트 요소
   - 웹 브라우저로 보내는 것이 아니라 웹 서버에서 실행되는 부분이다.
   - 문장의 끝에 반드시 `세미콜론(;)`을 붙여야 한다.
   - 스크릿트릿 요소는 여러번 반복해서 정의할 수 있지만 지양한다.
   - 서블릿이 공유하는 데이터를 꺼내서 출력하기 위해 사용된다.
   - `.java` 파일에서 할 수 있는 모든 작업을 할 수 있다.(메소드 선언, 클래스 선언 제외)
   - `java.lang` 패키지 빼고 모두 import 해주어야 한다.
   - 스크립트릿 내부에서 정의하는 변수는 모두 `jspService()` 메소드의 지역변수로 추가해야 한다.

2. `선언문`

   ```java
   <%! %>
   ```

   - `.jsp` 파일이 서블릿으로 변환될 때 서블릿 클래스의 멤버로 작성될 메소드나 변수를 정의
   - 잘 안쓴다.

3. `표현식`

   ```java
   <%= %>
   ```

   - 동적으로 만들어진 컨텐츠를 구성하는 값을 출력하기 위해 사용하는 스크립트 요소

   - 서블릿으로 변환될 때 `out.print()`의 내부에 매개변수로 추가되므로 `세미콜론(;)`를 추가하지 않는다.

     ```java
     // 오류상황 예시
     <%= "test" ;%>   ----> out.print("test";); // error !
     ```

   - 표현식은 값을 출력하기 위해서 사용하므로 사용할 수 있는 타입이 제한적이다.

   - 기본형, String, 앞의 나열한 타입을 반환하는 메소드 호출문 연산 시 사용한다.

# POJO

---

[위로](#spring-framework)

> Plain Old Java Object
>
> **오래된 방식의 간단한 자바 오브젝트** 라는 말로서, Java EE 등 중량 프레임워크들을 사용하게 되면서 점점 무거운 객체를 만들게 된 것에 반발해서 생겨난 개념이다.

오래된 방식의 간단한 자바 오브젝트가 무엇일까?

쉽게 말하자면, 특정 '기술'에 종속되어 동작하는 것이 아닌 순수한 자바 객체를 일컫는다.

예를들어, ORM(Object Relationship Mapping)이 새롭게 등장했을 때를 생각해보자. `ORM` 기술을 사용하고 싶다면 `ORM`을 지원하는 `ORM` 프레임워크를 사용해야 한다. (대표적으로  **Hibernate**라는 프레임워크가 있다.)
만약, 자바 개체가 `ORM` 기술을 사용하기 위해서 **`Hibernate`**프레임워크를 직접 의존하는 순간, 이는 `POJO`라고 할 수 없다.

특정 기술에 종속되었기 때문이다.



## POJO를 지향해야 하는 이유

스프링 프레임 워크 이전에는 원하는 엔터프라이즈 기술이 있다면 그 기술을 직접적으로 사용하는 객체를 설계했다. 그리고 이러한 개발 방식이 만연했고, 특정 기술과 환경에 종속되어 의존하게 된 자바 코드는 가독성이 떨어져 유지보수에 어려움이 생긴 것이다.

또한, 특정 기술의 클래스를 상속받거나, 직접 의존하게 되어 확장성이 매우 떨어지는 단점이 있었다.

이 말은 **객체지향의 화신인 자바가 객체지향 설계의 장점들을 잃어버리게 된 것이다.**

그래서, `POJO`라는 개념이 등장했다. 본래 자바의 장점을 살리는 **`오래된` 방식의 `순수한` 자바객체** 말이다.



## Spring에서의 POJO

스프링 프레임워크는 **`IoC`(Inversion of Control, 제어의 역전)** 컨테이너 안에서 `POJO`를 구성 및 관리하는 것이 가장 핵심으로 `POJO`를 매우 잘 다루는 프레임워크가 바로 스프링 프레임워크이다.

Java EE 등을 사용할 때에 비해서 특정 인터페이스를 구현하거나 상속할 필요가 없고 라이브러리를 지원하기에 용이하며 객체 또한 가벼운 것이 특징이다.



## 특정 기술을 사용하고 싶다면?

> 스프링이 POJO를 유지하면서 Hibernate를 사용할 수 있는 이유? -> **`PSA`**

`Hibernate`는 스프링 개발에서 많이 사용되고 있는 기술이다. 특정 기술에 종속적이면 `POJO`가 아니라면서 스프링에서는 어떻게 가능한걸까?

바로 스프링에서 정한 표준 인터페이스가 있기 때문이다.

스프링 개발자들은 `ORM`이라는 기술을 사용하기 위해서 **`JPA`**라는 표준 인터페이스를 정해두었다.

그리고 이제 여러 `ORM` 프레임워크들은 이 `JPA`라는 표준 인터페이스 아래, 구현되어 실행된다. 이것이 스프링이 새로운 엔터프라이즈 기술을 도입하면서도 `POJO`를 유지하는 방법이다.

이런 방법을 스프링의 **PSA**라고 이야기한다.



## 진정한 POJO란

토비의 스프링에서는 진정한 POJO를 아래와 같이 정의했다고 한다.

> 그럼 특정 기술규약과 환경에 종속되지 않으면 모두 POJO라고 말할 수 있는가? 많은 개발자가 크게 오해하는 것 중의 하나가 바로 이것이다. ...(중략)... **진정한 POJO란 객체지향적인 원리에 충실하면서, 환경과 기술에 종속되지 않고 필요에 따라 재활용될 수 있는 방식으로 설계된 오브젝트**를 말한다.



참조 : https://siyoon210.tistory.com/120
https://siyoon210.tistory.com/120

# MVC 패턴

---

[위로](#spring-framework)

> M, V, C가 나뉘어서 서버를 구성하는 모델을 모델2라고 한다. 모델 1과 모델2의 차이도 있지만 여기서는 넘어가겠다.

## M, V, C의 역할

- `Model(모델)`
  - 컨트롤러가 호출할 때, 요청에 맞는 역할을 수행한다.
  - **비즈니스 로직을 구현하는 영역으로 응용프로그램에서 데이터를 처리하는 부분**이다.
  - 비즈니스 로직이란 업무에 필요한 데이터처리를 수행하는 응용프로그램의 일부이다.
  - DB에 연결하고 데이터를 추출하거나 저장, 삭제, 업데이트, 변환 등의 작업을 수행한다.
  - 상태 변화가 있을 때 컨트롤러와 뷰에 통보해 후속 조치 명령을 받을 수 있도록 한다.
  - 애플리케이션의 상태(data)를 나타내고 일반적으로 **`POJO`**로 구성된다.
  - **Java Beans**
- `Contoller(컨트롤러)`
  - 일종의 조정자라고 할 수 있다.(View - Model 사이의 인터페이스 역할)
  - **클라이언트의 요청을 받았을 때, 그 요청에 대해 실제 업무를 수행하는 모델 컴포넌트를 호출**한다.
  - 또한, 클라이언트가 보낸 데이터가 있다면 모델에 전달하기 쉽게 데이터를 가공한다.
  - 모델이 업무를 마치면 그 결과를 뷰에게 전달한다.
  - `Controller -> Service -> DAO -> DB`
- `View(뷰)`
  - **컨트롤러부터 받은 모델의 결과값을 가지고 사용자에게 출력할 화면을 만드는 일**을 한다.
  - 만들어진 화면을 웹브라우저에 전송하여 웹브라우저가 출력하게 하는 것이다.
  - 화면에 표시되는 부분으로 추출한 데이터나 일반적인 텍스트 데이터를 표시하거나 입력폼 또는 사용자와의 상호작용을 위한 인터페이스를 표시하는 영역이다.
  - **JSP**
  - JSP 이외에도 Thymeleaf, Groovy, Freemarker 등 여러 템플릿 엔진이 존재



## MVC 구동원리

![image-20210609151104276](https://user-images.githubusercontent.com/58545240/121326126-3859b500-c94d-11eb-9138-d7f6ad636512.png)

> Client - Server 구조로 요청을 하면 그에 맞는 응답을 하는 것을 기반으로 한다.

1. 웹 브라우저가 웹 서버에 웹 애플리케이션 실행을 요청한다. (MVC구조가 WAS라고 보면 된다)
2. 웹 서버는 들어온 요청을 처리할 수 있는 서블릿을 찾아서 요청을 전달한다.(Matching)
3. 서블릿은 모델 자바 객체의 메서드를 호출한다.
4. 데이터를 가공해서 값 객체를 생성하거나, JDBC를 사용해 데이터베이스와의 인터랙션을 통한 값 객체를 생성한다.
5. 업무 수행을 마친 결과값을 컨트롤러에게 반환한다.
6. 컨트롤러는 모델로부터 받은 결과값을 View에게 전달한다.
7. JSP는 전달받은 값을 참조하여 출력할 결과 화면을 만들고 다시 컨트롤러에게 전달한다.
8. 뷰로부터 받은 화면을 웹 서버에게 전달한다.
9. 웹 브라우저는 웹 서버로부터 요청한 결과값을 받으면 그 값을 화면에 출력한다.



참조 : https://asfirstalways.tistory.com/180

# Spring MVC

---

[위로](#spring-framework)

> MVC 패턴을 적용한 Spring framework
>
> Spring에는 개발자들이 일반적으로 사용할만한 기능과 운영 방식들이 편리하게 정의되어 있다.
>
> Spring MVC에는 스프링이 제공하는 모든 기능을 잘 활용하기 위해서 스프링이 내가 작성한 자바 bean(객체)을 관리할 수있도록 해야 한다.
>
> Spring Framework 내부에는 **IOC 컨테이너**가 존재해 내가 등록한 bean(객체)을 생성하고 관리해준다. -> *결합도(Coupling)을 낮출 수 있게 된다.*
>
> 이를 위해 Dispatcher Servlet 이라는 Front-Controller 패턴의 Servlet을 가장 앞단에 둬서 컨테이너로 들어오는 모든 요청을 적절한 세부 컨트롤러로 작업을 위임해준다.
>
> > ***구성***
> >
> > - `DispatcherServlet`
> >   - 클라이언트의 모든 요청을 처리하기 위해 첫 번째로 실행되는 서블릿
> > - `HandlerMapping`
> >   - 클라이언트가 요청한 path를 분석해 어떤 컨트롤러를 실행해야 하는지 찾아서 DispatcherServlet으로 넘겨주는 객체
> > - `Controller`
> >   - 클라이언트의 요청을 처리하는 객체
> >   - DAO의 메소드를 호출하는 기능을 정의
> > - `ModelAndView`
> >   - Controller에서 DAo의 메소드를 실행결과로 만들어진 데이터에 대한 정보나 응답할 View에 대한 정보를 갖고 있는 객체
> > - `ViewResolver`
> >   - `ModelAndView`에서 저장된 view의 정보를 이용해서 실제 어떤 view를 실행해야 하는지 정보를 넘겨주는 객체
> >
> > 
> >
> > 스프링 MVC를 구축하면, 위 클래스 들이 자동으로 실행되며 일처리를 한다.
> >
> > 필요에 따라 ViewResolver나 HandlerMapping 객체를 다양하게 등록하고 사용할 수 있다.

## Dispatcher-Servlet

> 서블릿 컨테이너에서 HTTP 프로토콜을 통해 들어오는 모든 요청을 프레젠테이션 계층의 제일 앞에 둬서 중앙집중식으로 처리해주는 프론트 컨트롤러(Front Controller)

클라이언트로부터 어떠한 요청이 오면 `Tomcat`과 같은 서블릿컨테이너가 요청을 받는 데, 이 때 **제일 앞에서 서버로 들어오는 모든 요청을 처리하는 `Front Controller`**를 Spring에서 정의하였고, 이를 **Dispatcher-Servlet**이라고 한다.

그래서 공통처리 작업을 DispatcherServlet이 처리한 후 적절한 세부 컨트롤러로 작업을 위임해준다.

물론 Dispathcer-Servlet이 처리하는 `URL` 패턴을 지정 해줘야 하는데 일반적으로 `/*.do`와 같이 `/`로 시작하며 `.do`로 끝나는 `URL`패턴에 대해서 처리하라고 지정되어 있다.



### 흐름 & 장점

Spring MVC는 Dispatcher-Servlet이 등장함에 따라 `web.xml`의 역할을 상당히 축소시켜주었다.

기존에는 모든 서블릿에 대해 `URL Mapping`을 활용하기 위해 `web.xml`에 모두 등록해줘야 했지만, **dispatcher-servlet이 해당 어플리케이션으로 들어오는 모든 요청을 핸들링**해주면서 작업을 상당히 편리하게 할 수 있게 되었다.

그리고 이 서블릿을 이용한다면 `MVC` 역시 사용할 수 있게 되어 좋다. 

![image-20210609150000076](https://user-images.githubusercontent.com/58545240/121326054-2415b800-c94d-11eb-8bfd-bdecc03c9711.png)

위 그림과 같이 Dispatcher Servlet이 모든 요청을 Controller로 넘겨주는 방식으 효율적으로 보이나, **모든 요청을 처리하다 보니 이미지나 HTML 파일을 불러오는 요청마저 전부 Controller로 넘겨버린다.**

게다가, `.jsp` 파일 안의 Javascript나 StyleCSS 파일들에 대한 요청들까지도 모두 디스패처서블릿이 가로채는 까닭에 자원을 불러오지 못하는 상황도 발생할 수 있다.

이에 대한 해결책 두 가지가 있다.



첫 째로, 클라이언트의 요청을 2가지로 분리하여 구분하는 것이다.

1. `/apps`의 `URL`로 접근하면 Dispatcher Serlvet이 담당한다.
2. `/resources`의 `URL`로 접근하면 Dispatcher Servlet이 컨트롤할 수 없으므로 담당하지 않는다.

이러한 방식은 괜찮지만 상당히 코드가 지저분해지며 모든 요청에 대해 저런 prefix `URL`을 붙여주기 때문에 직관적인 설계가 될 수 없다.

두번째 방법으로 모든 요청을 컨트롤러에 등록하는 것인데, 이는 상당히 무식한 방법이다.



Spring은 이러한 문제들을 해결함과 동시에 편리한 방법을 제공해주는데, 바로 `<mvc:resources />`를 이용한 방법이다. 이것은 만약 디스패처 서블릿에 **해당 요청에 대한 컨트롤러를 찾을 수 없는 경우, 2차적으로 설정된 경로에서 요청을 탐색하여 자원을 찾아내는 것**이다.

이렇게 영역을 분리하면 효율적인 리소스 관리를 지원할 뿐 아니라 추후에 확장을 용이하게 해준다는 장점이 있다.

참조 : https://mangkyu.tistory.com/18?category=761302

# DI

---

[위로](#spring-framework)

> 의존관계 주입
>
> 스프링 컨테이너가 지원하는 핵심 개념중 하나로, 설정파일을 통해 객체간의 의존관계를 설정
>
> 이는, 스프링에서만 사용되는 용어가 아니라 객체지향 프로그래밍에서 통용되는 개념이다.
>
> 
>
> **강한 결합**
>
> 객체 내부에서 다른 객체를 생성하는 것은 **강한 결합도**를 가지는 구조이다.
>
> A클래스 내부에서 B라는 객체를 직접 생성하고 있다면, B객체를 C객체로 바꾸고 싶은 경우, A클래스도 수정해야 하는 방식이고, 이를 강한결합이라 한다.
>
> 
>
> **느슨한 결합**
>
> 객체를 주입받는 다는 것은 외부에서 생성된 객체를 인터페이스를 통해 넘겨받는 것이다.
>
> 이렇게하면 **결합도를 낮출수 있고, 런타임 시에 의존관계가 결정**되기 때문에 유연한 구조를 가진다.
>
> 
>
> `SOLID`의 원칙 중 `O`에 해당하는 **Open Closed Principle**을 지키기 위해서 디자인 패턴 중 전략패턴을 사용하게 되는데, **생성자 주입**을 사용하게 되면 전략패턴을 사용하는 것이다.
>
> 스프링 프레임워크에서는 필드주입이나, 수정자 주입 방법 보다, 생성자 주입을 더 권장하고 있다. 그 이유를 알아보자.

## 생성자 주입

> Constructor Injection

`Spring Framework 4.3` 버전 부터는 의존성 주입으로부터 클래스를 완벽하게 분리할 수 있다.

단일 생성자인 경우에는 `@Autowired` 어노테이션을 붙이지 않아도 되지만 생성자가 2개 이상인 경우에는 생성자에 어노테이션을 붙여주어야 한다.

```java
@Component
public class MyExample {
    // final로 선언할 수 있는 보너스
    private final HelloService helloService;
    
    // 단일 생성자인 경우 추가적인 어노테이션이 필요 없다.
    public MyExample(HelloService helloService) {
        this.helloService = helloService;
    }
}
```



## 필드 주입

> Field Injection

사용법이 매우 간단하다. 사용하고자 하는 필드에 `@Autowired` 어노테이션을 붙여주면 자동으로 의존성이 주입된다.

편리하기 때문에 가장 많이 접할 수 있는 방법이다.

```java
@Component
public class MyExample {
    @Autowired
    private HelloService helloService;
}
```



## 수정자 주입

> Setter Injection

수정자(Setter)를 이용한 주입 방법도 있다.

꼭 setter 메서드일 필요는 없다. 메서드 이름이 수정자 네이밍 패턴(`setXXX`)이 아니어도 동일한 기능을 하면된다.

그래도 일관성과 명확환 코드를 만들기 위해 정확한 이름을 사용하는 것을 추천한다.

```java
@Component
public class MyExample {
    private HelloService helloService;
    
    @Autowired
    public void setHelloService(HelloService helloService) {
        this.helloService = helloService;
    }
}
```



대부분, 코드에서 `@Autowired` 어노테이션을 필드에 붙여 사용하는 필드 주입 코드를 많이 봤을 것이다. 이는 사용하기 편리하기 때문일 것인데, 스프링팀에는 **생성자 주입 방법을 권장**하고 있다. 그 이유는 무엇일까?



## 왜 생성자 주입을 권장할까

그렇다면 왜 생성자 주입 방법을 더 권장하는 이유는 무엇일까? `@Autowired` 어노테이션만으로 간단하게 의존성을 주입할 수 있는데 말이다. 필드 주입이나 수정자 주입 방법과 다르게 생성자 주입 방법이 주는 장점에 대해서 살펴보자.

### > 순환참조 방지

개발을 하다 보면 여러 컴포넌트 간에 의존성이 생긴다. 그중에서도 A가 B를 참조하고, B가 다시 A를 참조하는 순환 참조도 발생할 수 있는데 아래 코드를 통해 어떤 경우인지 살펴보자.

우선 두 개의 서비스 레이어 컴포넌트를 정의한다. 그리고 서로 참조하게 한다. 조금 더 극단적인 상황(?)을 만들기 위해서 순환 참조하는 구조에 더불어 서로의 메서드를 순환 호출하도록 한다. 

그러니까 빈이 생성된 후에 비즈니스 로직으로 인하여 서로의 메서드를 순환 참조하는 형태이다. 실제로는 이러한 형태가 되어서는 안되며, 직접적으로 서로를 계속해서 호출하는 코드는 더더욱 안된다. “순환 참조가 되면 이럴 수도 있구나~”라고 생각하자.

```java
@Service
public class MyPlayService {
    // 순환 참조
    @Autowired
    private MyLifeService myLifeService;
    
    public void sayMyPlay() {
        myLifeService.sayMyLife();
    }
}
```

```java
@Service
public class MyLifeService {
    // 순환 참조
    @Autowired
    private MyPlayService myPlayService;
    
    public void sayMyLife() {
        myPlayService.sayMyPlay();
    }
}
```

위 코드는 애플리케이션이 아무런 오류나 경고 없이 구동되고, 실제 코드가 호출되기 전까지 문제를 발견할 수 없다.

그렇다면 생성자 주입을 사용한 경우에는 어떻게 될까?

```java
@Service
public class MyPlayService {
    private final MyLifeService myLifeService;
    
    public MyPlayService(MyLifeService myLifeService) {
        this.myLifeService = myLifeService;
    }
    
    // 생략
}
```

```java
@Service
public class MyLifeService {
    private final MyPlayService myPlayService;
    
    public MyLifeService(MyPlayService myPlayService) {
        this.myPlayService = myPlayService;
    }
    
    // 생략
}
```

실행 결과는 `BeanCurrentlyInCreationException`이 발생하며 애플리케이션이 구동조차 되지 않는다.
따라서, 발생할 수 있는 오류를 사전에 알 수 잇다.

### > 테스트에 용이

### > 좋은 품질의 코드

### > 불변성



## 정리

정리해보면 아래와 같은 이유로 필드주입이나 수정자 주입보다 생정자 주입의 사용이 권장된다.

- 순환 참조를 방지할 수 있다.
  - 순환 참조가 발생하는 경우 애플리케이션이 구동되지 않는다.
  - NPE 방지
- 테스트 코드 작성이 편리하다.
  - 단순 `POJO`를 이용한 테스트 코드를 만들 수 있다.
- 나쁜 냄새를 없앤다.
  - 더 품질 좋은 코드를 만들 수 있다.
- `immutable` 하다.
  - 의존성 주입이 필요한 필드를 final로 선언가능하다.
  - 실행 중에 객체가 변하는 것을 막을 수 있다.
  - 오류를 사전에 방지할 수 있다.



참조 : https://madplay.github.io/post/why-constructor-injection-is-better-than-field-injection