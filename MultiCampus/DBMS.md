# 1. DBMS

## 0. 데이터 베이스란?

> 대량의 정보를 컴퓨터가 효율적으로 접근할 수 있도록 가공 및 저장한 것을 '데이터베이스'라고 한다.

1. 계층형 데이터 베이스(HDBMS)
2. 관계형 데이터베이스(RDBMS)
   * 열과 행으로 이루어진 2차원 표형식으로 데이터를 관리
   * 가장 많이사용
3. 객체지향 데이터베이스(OODB)
4. XML 데이터베이스(XMLDB)
5. 키-밸류형 데이터스토어(KVS)

- 정형화 데이터 처리 프로그램
  - DB
  - Oracle
    - 대부분의 기업들이 사용(일반적)
    - 데이터 저장, 대량처리 가능
  - MySQL
    - 보통 중소기업
  - MSSQL
    - 보통 중소기업
  - 티베로

### 1. 데이터베이스 정규화

> 관계형 데이터베이스 설계시 중복을 최소화하도록 데이터를 구조화 하는 작업

#### 1. 함수 종속성

관계형 데이터베이스의 설계에서 중복된 데이터가 최소화되도록 데이터베이스의 구조를 결정하는 것을 정규화 (normalization)라고 한다. 정규화된 데이터베이스가 그렇지 않은 데이터베이스에 비하여 더욱 효율적으로 데이터에 대한 연산을 수행할 수 있는 것은 매우 당연한 것이다. 이러한 데이터베이스의 정규화 과정에서 함수 종속성이라는 개념은 매우 중요하게 이용된다.

함수 종속성은 수학에서의 함수와 같이 두 필드의 집합이 many-to-one 관계로 사상되는 것을 말한다. 즉, 함수와 같이 어떠한 값을 통해 종속 관계에 있는 다른 값을 유일하게 결정할 수 있다는 것이다. 데이터베이스에서의 함수 종속성을 더욱 명확하게 정의하면 다음과 같다.

어떤 테이블 RR에 존재하는 필드들의 부분집합을 각각 XX와 YY라고 할 때, XX의 한 값이 YY에 속한 오직 하나의 값에만 사상될 경우에 "YY는 XX에 함수 종속 (YY is functionally dependent on XX)"이라고 하며, XX→YY라고 표기한다.

예를 들어, 테이블에 [생일]과 [나이]라는 필드가 존재할 경우에 [나이] 필드는 [생일] 필드에 함수 종속이다. 즉, 생일을 알고 있다면, 나이에 대한 필드를 참조하지 않거나, 아예 필드를 유지하지 않아도 나이를 결정할 수 있다. 데이터베이스 설계 단계에서 함수 종속 관계에 있는 필드를 찾는다면, 그 만큼 중복된 데이터를 줄일 수 있다. 그러므로, 데이터베이스 설계 단계에서 각 정보들 간의 함수 종속 관계를 찾는 것은 매우 중요하다.



#### 2. 함수 종속의 성질

어떠한 테이블 RR에 대해 X,Y,ZX,Y,Z라는 필드의 집합이 있을 때, 함수 종속은 다음과 같은 성질을 만족하며, 이를 암스트롱의 공리 (Armstrong's axioms)라고 한다.

- **augmentation**: 만약 X→YX→Y이면, XZ→YZXZ→YZ이다.
- **t****ransitivity**: 만약 X→YX→Y이고 Y→ZY→Z이면, X→ZX→Z이다.
- **reflexivity**: 만약 YY가 XX의 부분집합이면, X→YX→Y이다.
- **self-determination**: 자기 자신은 자신에 의해 함수 종속적이다. 즉, X→XX→X이다.
- **union**: 만약 X→YX→Y이고 X→ZX→Z이면, X→YZX→YZ이다.
- **decomposition**: 만약 X→YZX→YZ이면, X→YX→Y이고 X→ZX→Z이다.

관계형 데이터베이스는 이산수학의 relation 및 function의 개념을 이용하여 정의되었기 때문에 그 성질 또한 이산수학의 개념과 유사한 것을 볼 수 있다.



#### 3. **키의 종류**

1. 슈퍼키(Super key) -유일성을 만족하는 키이다. 즉 기본키의 유니크 속성 예를 들어  게임 아이디에서 (게임 닉네임+ 게임 아이디), (게임 닉네임), (게임 아이디) 또는 (게임 아이디 소유자 이름 + 거주지)같은 것이다. 참고로 키는 튜플들이 모여서 키가 될 수 있으므로 (게임 아이디+ 게임 아이디) 는 두 가지 다른 튜플이 모여서 키를 이룬 것이라고 할 수 있다.
2. 후보키(Candidate Key) - 유일성과 최소성을 만족하는 키이다. 위에서 게임 아이디는 중복되게 만들 수 있나..
3. 기본 키(Primary Key) - 후보키 중에서 기본적으로 사용하기 위해 선택한 키이다.
4. 대체 키(Surrogate Key) - 기본 키로 선택되지 못한 후보키이다. 위에서 게임 아이디를 기본 키로 선택했다면 게임  닉네임은 대체키가 된다.
5. 외래키(Foreign Key) - 다른 릴레이션의 기본 키를 참조하는 키이다. 참조하는 릴레이션 : 외래키를 가진 릴레이션, 참조되는 릴레이션 : 외래키가 참조하는 기본키를 가진 릴레이션



#### 4. Closure개념을 이용한 Super 키 판별

어떠한 테이블에서 주어진 필드의 집합이 해당 테이블의 super key인지를 판별하기 위해 closure라는 개념을 이용할 수 있다. 어떠한 테이블의 모든 필드가 주어진 필드의 집합 SS에 대해 함수 종속이라면, 주어진 필드의 집합 SS는 해당 테이블의 super key라고 할 수 있다. 따라서, 함수 종속성과 암스트롱의 공리, closure 개념을 이용하여 super key를 판별할 수 있다. 예를 들어, 어떠한 테이블 R(A,B,C,D,E,F)R(A,B,C,D,E,F)에서는 다음과 같은 함수 종속성이 존재한다.



![img](../Embedded/images/256E4F42584AAFBB06)



위에 주어진 함수 종속성을 이용하여 주어진 테이블에서 {A,B}{A,B}가 super key인지를 판별하는 알고리즘은 다음과 같다.



1) 필드의 집합 CLOSURE={A,B}CLOSURE={A,B}를 정의한다.

2) 위의 주어진 함수 종속성에서 (1)에 해당하는 함수 종속 관계를 통해 A→CA→C임을 알 수 있다. 그러므로, 필드의 집합인 CLOSURECLOSURE에 CC를 추가한다.

3) 함수 종속 관계 (2)에 대해서는 해당하는 사항이 없다.

4) 함수 종속 관계 (3)에 의해 B→EB→E라는 사실을 알 수 있다. 그러므로, CLOSURECLOSURE에 EE를 추가한다.

5) 함수 종속 관계 (4)에 대해서는 해당하는 사항이 없다.

6-1) CLOSURECLOSURE에 변화가 있었으면, [과정 2]로 이동하여 현재 CLOSURECLOSURE 집합에 대해 알고리즘을 다시 실행한다.

6-2) CLOSURECLOSURE에 변화가 없었으면, 알고리즘을 종료한다.



알고리즘을 끝낸 후의 CLOSURECLOSURE는 주어진 테이블의 속성 중에서 DD가 빠진 {A,B,C,E,F}{A,B,C,E,F}와 같다. 따라서, 필드의 집합 {A,B}{A,B}는 해당 테이블의 super key가 아니다.



#### 5. 정규화 작업의 장점과 단점

정규화는 기본적으로 하나의 테이블을 여러개의 테이블로 분리시키는 과정이므로 정규화가 진행될 수록 테이블 수가 늘어나게 됩니다. 정규화의 장점은 위와 같이 중복된 데이터를 제거하고 각종 이상증상을 없애는데 있지만 이에 반해 테이블 수가 늘어나게 되어 "**조회**"시에 여러 테이블을 참조해야만 하므로 "**조회**" 성능이 저하되는 단점이 있습니다.

```bash
여러 테이블에 분산되어 있는 정보는 "조회"시에 다시 하나로 모아야 하는데 이 작업은 JOIN이라는 명령으로 수행됩니다. 그런데 이 JOIN 명령이 테이터베이스에서 가장 부하가 많이 걸리는 작업 중에 하나입니다. 참고로 JOIN 작업을 줄이기 위해서 **Subquery** (쿼리 속의 쿼리)를 사용하기도 합니다.
```

따라서 정규화 과정은 대체적으로 성능과 이상증상의 제거를 서로 고려하여 적당한 선에서 결정합니다. 정규화는 1NF, 2NF, 3NF, BCNF, 4NF, 5NF 등 많이 있으나 (NF=Normal Form, 정규형) 성능 등을 고려하여 적당히 3NF 또는 BCNF 정도에서 멈추게 됩니다. 

(성능을 위해 이미 정규화가 진행된 테이블을 서로 합치는 것을 **역정규화**라고 합니다.)



### 2. First Normal Form (1NF)

테이블에 존재하는 필드가 모두 scalar value만을 가지며, 필드의 값이 모두 atomic 할 때, 1NF라고 한다. 여기에서 atomic 하다는 것은 테이블에 중복되는 항목이 존재하지 않아야 한다는 것과 같다. 1NF에서 "중복되는 항목이 없다"에 대한 정의는 명확한 것이 아니기 때문에 1NF에 대한 정의 또한 여러 개가 존재할 수 있다.

![image-20191218214325557](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20191218214325557.png)

​																	[그림 1] 예제 테이블 SUPPLIERS

 위의 [그림 1]에 있는 테이블 SUPPLIERS는 {S#, P#}을 primary key로 가지며, 1NF의 정의를 만족하지 않는 테이블을 보여준다. 1NF의 정의를 만족하지 않기 때문에 아래의 [그림 2]에 표시된 것과 같이 서로 다른 primary key를 갖는 두 레코드가 같은 값을 갖고 있다. 즉, [그림 2]의 테이블에서는 [STATUS=10, CITY=Seoul, QTY=300]과 [STATUS=20, CITY=Busan, QTY=100]이라는 중복된 항목이 존재한다.

![image-20191218214514258](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20191218214514258.png)

위의 [그림 2]와 같은 테이블에서는 INSERT, DELETE, UPDATE 시에 이상 현상이 나타날 수 있다.

#### (1) INSERT anomaly

만약, [그림 2]의 테이블에 S5이라는 공급자가 London에 있다는 정보를 저장하고 싶다면, primary key의 구성 요소인 P#에 해당하는 필드에 dirty data를 입력해야 한다.

#### (2) DELETE anomaly

테이블에서 S3이라는 공급자가 더는 P2를 공급하지 않게 되어, S#이 S3에 해당하는 레코드를 삭제하면, S3이라는 공급자가 Busan에 있다는 정보까지 손실된다.

#### (3) UPDATE anomaly

테이블에서 S1이라는 공급자가 있는 도시를 Seoul에서 Paris로 변경하려면 총 3번의 update 연산이 필요하다. 즉, 하나의 정보를 변경하기 위해 불필요한 update 연산이 2번 더 실행되어야 한다.



* [그림 1]의 테이블을 {S#, STATUS, CITY}, {S#, P#, QTY}로 이루어진 두 개의 테이블로 분해하여 1NF의 정의를 만족하는 새로운 테이블로 변경할 수 있다. 1NF의 정의를 만족하도록 분해한 새로운 테이블에서는 위에서 예시로 들은 anomaly가 발생하지 않는다.

  

### 3.  Second Normal Form (2NF)

2NF는 1NF의 속성을 만족하면서, 테이블에 존재하는 모든 함수 종속 관계가 완전 함수 종속이어야 한다. 2NF를 정의할 때 이용되는 완전 함수 종속의 정의는 다음과 같다.

어떤 테이블 RR의 필드 YY가 필드의 집합 XX에 함수 종속이면서, XX 자신을 제외한 XX의 어떤 부분 집합에도 함수 종속이 아니면, YY는 XX에 완전 함수 종속이라고 한다.

예를 들어, [그림 1]의 테이블에서 primary key는 {S#, P#}이지만, CITY라는 필드는 {S#, P#}이 아니라 S#에 대해 함수 종속적이다. 따라서, [그림 1]의 테이블에는 완전 함수 종속이 아닌 함수 종속 관계가 존재하므로 2NF가 아니다. 위의 [그림 1]의 테이블을 2NF의 정의를 만족하도록 변형하면, 아래의 [그림 3]과 같이 SSC와 SPQ로 표현되는 두 개의 테이블로 분해할 수 있다.

![image-20191218214801303](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20191218214801303.png)

그러나 2NF의 정의를 만족하는 SSC와 SPQ 테이블에서도 다음과 같은 이상 현상이 발생한다.



#### (1) INSERT anomaly

SSC 테이블에는 "Paris라는 CITY의 STATUS는 40이다"라는 정보를 저장할 수 없다. SSC 테이블의 primary key는 S#이기 때문에 어떠한 도시의 상태에 대한 정보를 SSC 테이블에 저장할 수 없다. 또는, 해당 정보를 저장하기 위해서 S#에 dirty data를 추가해야 한다.

#### (2) DELETE anomaly

만약, SSC 테이블에서 두 공급자 S2와 S3가 제거되면, "Busan이라는 CITY의 STATUS는 20이다"라는 정보도 같이 손실된다.

#### (3) UPDATE anomlay

만약, Seoul이라는 CITY의 STATUS가 10에서 30으로 변경되면, SSC 테이블에서는 Seoul의 STATUS를 30으로 변경하는 작업을 1번이 아니라, 총 2번 수행해야 한다.



### 4. Third Normal Form (3NF)

2NF의 정의를 만족하면서, 어떠한 테이블에 존재하는 key가 아닌 필드들이 서로 독립적일 때 3NF라고 한다. 예를 들어, [그림 3]의 SSC 테이블에서 STATUS 필드는 테이블의 key가 아닌 CITY 필드에 함수 종속적이기 때문에 SSC 테이블은 3NF의 정의를 만족하지 못한다. 3NF의 정의를 만족하도록 [그림 3]의 SSC 테이블을 분해하면, 아래의 [그림 4]와 같다.

![image-20191218214940133](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20191218214940133.png)

위의 [그림 3]의 SSC 테이블에서는 key가 아닌 CITY에 STATUS가 종속적이었지만, [그림 4]의 SC와 CS 테이블에서는 key가 아닌 필드 사이에 어떠한 종속 관계도 존재하지 않는 것을 볼 수 있다.

### 5. Boyce-Codd Normal Form (BCNF)

![image-20191218215023018](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20191218215023018.png)

위의 [그림 5]는 BCNF의 정의를 만족하지 않는 테이블을 보여준다. [그림 5]의 테이블에서 candidate key는 {STD#, COURSE}이다. 따라서, {STD#, COURSE}를 통해 하나의 레코드를 유일하게 구별할 수 있다.

그러나 테이블 SCT에는 TEACHER에 의해 COURSE가 결정되는 함수 종속 관계가 존재한다. 즉, determinant가 candidate key에 해당하지 않는 함수 종속 관계가 존재하기 때문에 테이블 SCT는 BCNF의 정의를 만족하지 않는다. 이러한 테이블 SCT를 BCNF의 정의를 만족하도록 변경하면, 테이블 SCT는 아래의 [그림 6]과 같은 두 개의 테이블로 변환된다.

![image-20191218215045120](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20191218215045120.png)

위의 [그림 6]에서 함수 종속 관계는 테이블 TC에서만 존재하며, determinant에 해당하는 것은 TEACHER로써, 테이블 TC의 candidate key에 해당한다. 따라서, [그림 6]의 두 테이블은 BCNF의 정의를 만족한다.



### 6. Fourth Normal Form (4NF)

4NF는 MVD (multivalued dependency)라는 개념을 통해 정의된다. MVD는 functional dependency의 일반화된 개념으로써, functional dependency에서는 determinant X에 의해 Y의 값이 하나만 결정되었다면, MVD에서는 determinant X에 의해 다수의 Y값이 결정된다. 위와 같은 MVD 관계는 X →→ Y로 표기한다.

MVD는 trivial MVD와 nontrivial MVD로 구분된다. 각각의 정의는 아래와 같다. 또한, 이 글에서 4NF를 정의하기 위해 언급되는 MVD는 모두 아래의 nontrivial MVD를 의미한다.

* **trivial MVD**: Y가 X의 부분집합이거나, X와 Y를 합한 것이 테이블 그 자체인 경우 (X ∪ Y = R)
* **nontrivial MVD**: 위에서 정의된 trivial MVD가 아닌 모든 MVD



만약, 어떠한 테이블 R에 존재하는 필드 A와 B가 A →→ B이면, R에 존재하는 다른 모든 필드가 A에 의해 functional dependent하게 값이 결정될 때, 4NF라고 한다. 예를 들어, 테이블 R(A, B, C, D)에 대해 A →→ B일 때, A → C 이고 A → D이면 R은 4NF의 정의를 만족한다고 할 수 있다.

아래의 [그림 7]과 같이 COURSE와 MVD 관계를 갖는 두 개의 필드를 포함하는 정보가 있다. 두 개의 필드는 각각 COURSE 필드의 값에 의해 값이 결정되며, 하나의 COURSE 값에 대해 다수의 TEACHER와 TEXT 값이 존재할 수 있다.

![image-20191218215153706](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20191218215153706.png)

위의 [그림 8]의 테이블 CTT에서 Data Structure를 가르치는 사람이 변경되면, 하나가 아니라, 총 세 개의 레코드를 변경해야 하는 UPDATE anomaly가 발생한다. 이러한 UPDATE anomaly를 해결하기 위해서는 [그림 8]의 테이블을 4NF의 정의를 만족하도록 변경하는 것이 필요하다. 테이블 CTT를 4NF의 정의에 맞도록 분할하면, [그림 9]의 두 테이블, CT1과 CT2로 변경된다.

![image-20191218215219745](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20191218215219745.png)

위의 [그림 8]의 테이블 CTT를 [그림 9]의 두 테이블 CT1과 CT2로 분할하면, Data Structure를 가르치는 사람을 변경할 때, 더는 UPDATE anomaly가 발생하지 않는다.



## 1. SQL

> 저장된 데이터(정형화)를 사용하는 언어가 SQL이다.

1. (몇개 테이블을 쓸 것인가) - 조인
2. 어떤 것을 조회할 것인가? = 무엇을 추출할 것인지
3. 어떤 조건이 있는가?

### 1. 초기 환경설정

* server - setwork - admin - ( listerner.ora , tnsnameora ) - 모두 영문 내용이어야함

* 오류 발생시
  * 시스템관리도구 - 서비스 - OracleTNSListener 다시시작
* scott 계정생성과 권한부여하기
* set linesize 300; -> 접속할때마다 해줘야함

### 2. 기본문법

#### 1. SQL 개요

##### 1. DDL(데이터 정의 언어)

1. CREATE : 데이터베이스나 테이블 등을 작성한다.

2. DROP : 데이터베이스나 테이블 등을 삭제한다.

3. ALTER : 데이터베이스나 테이블 등의 구성을 변경한다.

4. 제약조건 

   1. NOT NULL
   2. UNIQUE : 중복 되지 않는 키
   3. PRIMARY KEY : NOT NULL + UNIQUE
      * 구분해주는 키이기때문에 중복 불가능
   4. FOREIGN KEY : PRIMARY KEY 이외의 값은 사용할 수 없다.
      * 참조하는 키
   5. CHECK : 컬럼에 입력되는 값에 제한을 두는 것

   

   * 테이블정규화에 의해 중복되어 들어가는 값들을 따로 데이터로 
   * 중복되지않는 유일한 값들을 갖고는 테이블의 기본키

      참조하는 키가 foreign key 

   기본키가 설정된 테이블을 parent table 

   참조하는게 child table

   제약조건을 제거하는게 가장 좋은 방법이다.

   

##### 2. DML(데이터 조작 언어)

> 직접 데이터를 조작해서 원본을 변경

1. SELECT : 테이블에서 행을 검색한다.(따로 쿼리로 빼기도 한다.)

2. INSERT : 테이블에 신규 행을 등록한다.

   * 게시물등록? 댓글작성? 회원가입? 등등 DB에 새로운 내용 저장
   * 저장을 하기 위해서 commit; 해주어야 한다

   ```bash
   insert (all) into <테이블명> values('', '', ....);
   commit;
   ```

3. DELETE : 테이블에서 행을 삭제한다

   ```bash
   1. delete member;
   2. delete from member;
   3. delete from member
   	where id = 'jjang';
   4. SQL> delete
       from member
       where addr = (select addr
                     from member
                     where id='jang');
   ```

4. UPDATE : 테이블에서 데이터를 변경(갱신)

   ```bash
   update member
   set addr =(select addr
   		from member
   		where id = 'jang')
   where id = 'lee';
   ```

##### 3.  DCL(데이터 제어 언어)

> DBA할 거 아니면 집중적으로 하지 않는다.

1. COMMIT : 데이터베이스 변경 내용을 확정한다.
2. ROLLBACK : 데이터베이스 변경 내용을 취소한다.
3. GRANT : 사용자에게 처리 권한을 부여한다.
4. REVOKE : 사용자 처리 권한을 제거한다.

##### **4. Query**

###### < SELECT>

1. 기본

2. GROUP BY , HAVING

3. 조인( JOIN )

4. 서브쿼리

   => 전체 쿼리안에 또 다른 쿼리가 포함 되있는 것

   ​    (Main Query)	   (Sub Query)

5. 함수

##### **5. 서브쿼리**

* SQL문 안에 삽입된 QUERY
* SELECT문에서 주로 사용하고 SELECT문안에 삽입된 SELECT문.
* 바깥쪽의 QUERY를 MAIN QUERY, 안쪽에 삽입된 QUERY를 SUB QUERY
* SUB QUERY는 괄호로 묶어 주어야 한다.
* SUB QUERY는 메인쿼리가 실행되기 전에 한 번 실행되며 그 실행결과를 메인쿼리에서 사용한다. 

###### [서브쿼리의 종류]

1. 단일행서브쿼리 - 결과가 1행 1열인 서브쿼리

2. 다중행서브쿼리 - 서브쿼리의 실행결과가 열 하나에 행이 여러개 인 경우

   * ' = ' 연산자와 같은 비교연산자를 사용할 수 없다.
* in : 다중에서 쓰는 = 이다.
   * < any : 서브쿼리 결과의 최대값보다 작은 값을 구하는 경우 사용
* ) any : 서브쿼리 결과의 최솟값보다 큰 값을 구하는 경우
   * < all : 서브쿼리 결과의 최솟값보다 작은 값을 구하는 경우
* ) all : 서크붜리 결과의 최대값보다 큰 값을 구하는 경우
```bash
   select ename, sal
   from emp
   where sal > any(select sal
   			from emp
   			where deptno =10);
<<<<<<< HEAD
```
```
>>>>>>> d7b64bb14e6cf0a250fc1284aec1675b9cd4777a

3. 다중컬럼 서브쿼리 - 두개 이상의 컬럼과 다중행을 반환하는 서브쿼리

   * 메인쿼리 비교 컬럼의 갯수, 종류가 서브쿼리의 반환 결과와 동일

   ```bash
   where (컬럼1, 컬럼2) in (select 컬럼1, 컬럼2
   						...)
```

4. **상관형 서브쿼리(상호연관 서브쿼리) - 메인쿼리의 값이 서브쿼리에서 사용되는 경우**

   * 메인쿼리 한 row에 대해 서브쿼리가 한 번씩 실행된다.
   * 메인쿼리의 값이 어떤 값이냐에 따라 서브쿼리의 결과가 달라진다.

   ```bash
   " 소속부서의 급여 평균보다 급여가 많은 사원들의 정보를 출력 "
   select ename, deptno, sal
   from emp outer
   where sal > (select avg(sal)
   	from emp e
   	where e.deptno = outer.deptno)
   ```

   *[실행 흐름]*

   1. 메인쿼리에서 비교할 값을 가져온다
   2. 메인쿼리에서 받은 값을 이용해서 서브쿼리가 실행된다.
   3. 서브쿼리의 실행결과로 메인쿼리가 실행된다.
   4. 메인쿼리의 레코드수만큼 반복된다.

5.  **from 절에서 사용하는 서브쿼리(inline view)**

   * from절에 서브쿼리를 추가해서 사용
   * 서브쿼리 결과를 가상 테이블로 사용하겠다는 의미
   * from절에 추가되는 서브쿼리는 alias를 정의해야 한다.
   * from절에 추가되는 서브쿼리 내부의 컬럼은 실제 컬럼처럼 메인쿼리에서 사용해야 하므로 컬럼도 컬럼명이 존재하거나 alias를 정의해야 한다.

   ```bash
   select 컬럼명1,....
   from ( select 컬럼
   		from 테이블명
   		where 테이블명
   		group by ....) alias
   ```

   ```bash
   select deptcode, countdata
   from (select deptno as deptcode, count(empno) as countdata
   	from emp
   	group by deptno) mytable; // 반드시 이름을 정의해줘야 한다
   ```

   ```bash
   " 소속부서의 급여 평균보다 급여가 많은 사원들의 정보를 출력 " + "조인과 from절에 추가하는 서브쿼리를 이용"
   select e.ename, e.deptno, e.sal, d.avgsal
   from emp e, (select deptno, avg(sal) avgsal
   			from emp
   			group by deptno) d
   where e.deptno = d.deptno
   		and e.sal > d.avgsal;
   ```

   

   

##### 6. 뷰

* (selec문이 저장 되있는) 실행결과로 보여지는 가상테이블

```bash
CREATE VIEW 뷰명 alias
AS
SELECT문
```



##### 6. 기본적인 작성 규칙

* SQL 문 마지막에 세미콜론(;)을 붙인다.
* 대문자, 소문자 구분이 없다.
* 상수(리터럴) 작성은 작은따옴표(')를 이용한다.
* 단어는 공백 문자나 줄바꿈 문자로 구분한다.
* **1) from --> 2) where --> 3) group by --> 4) having --> 5) select --> 6)order by순으로 인식된다.**

#### 2. 테이블 작성

1. 데이터베이스 작성
   * 테이블을 저장할 데이터베이스

```bash
CREATE DATABASE <데이터베이스명>
```

2. 테이블 작성

```bash
CREATE TABLE <테이블명>
( 
<열명1> <데이터형> <이 열의 제약>,
<열명2> <데이터형> <이 열의 제약>,
<열명3> <데이터형> <이 열의 제약>,
			.
			.
			.
<이 테이블의 제약1>,<이 테이블의 제약2>,...);
```

3. 데이터형 지정
   * INTEGER형(정수형)
   * CHAR형(고정 문자열)
   * VARCHAR형(가변 문자열)
4. 제약 설정

#### 3. 테이블 삭제와 변경

1. 

### 3. SELECT문의 기본

#### 1. 기본 SELECT문

```bash
SELECT <열명1>, <컬럼명2>, ...
	FROM <테이블명>;
```

* sql은 대소문자 구분하지 않는다.
* ; 은 sql문의 종료를 의미한다.
* ; 을 입력하기 전에 여러줄로 sql문을 작성할 수 있다.
* *는 모든 컬럼을 조회하겠다는 의미
* 컬럼에 null을 저장할 수 있다.
* null은 ()이나 space만 입력해 놓은 값과 다른 값
  * oracle에서의 null은 아무 값도 없는 것을 의미
  * -> 사용할 수 없고 정의될 수 없음.
* 컬럼명 대신 alias를 정의해서 사용할 수 있다.

```bash
select 컬럼명 alias명 / 컬럼명 as alias명 / 컬럼명 "alias명"
										=> alias명에 공백이 있는 경우 사용
```

* 여러 컬럼을 합쳐서 하나의 컬럼으로 조회할 수 있다. (string의 concat과 비슷한 기능)
  * || 연산자 이용
* 오라클의 문자열, 날짜 데이터는 ' ' 로 표현
* 연산의 결과로 컬럼을 생성할 수 있다.
  * ( +, -, *, / ...함수...) 단, null이 포함되어 있는 컬럼은 연산할 수 없다.
* 중복이 있는 경우 중복을 제거하기 위해 select문에 distinct를 추가할 수 있다.

#### 2. SELECT절에 조건 추가하기

```bash
SELECT[distinct] 컬럼명, 컬럼명,...[alias명]  ( [ ]는 줘도 되고 안줘도 되는 것 )
	FROM 테이블명
	WHERE 조건;
```

* 검색 결과를 제한(조건에 만족하는 데이터만 조회하겠다는 의미)
* where절은 반드시 from절 다음에 정의

* where절은 조건식이 true가 되도록 정의
*  where절에 사용할 수 있는 비교연산자
  
*   ( >, >=, <, <=, =(같다), <>(같지않다), !=(같지않다) )
  
* where 절에서 조건과 함께 비교하는 값을 추가해야 하는 경우 문자,날짜는 작은따옴표(')로 묶어주어야 한다. 
* SQL은 대소문자를 구분하지 않는다. 값을 비교하는 경우 정확하게 대소문자까지 일치해야 한다.

* 두 개 이상의 조건이 있는 경우 사용할 수 있는 연산자

  * and연산자 : 모든 조건이 일치

  * or연산자 : 모든 조건 중 한개만 일치(조건이 모두 다른 컬럼인 경우)

  *  between A and B : and연산과 동일 (같은 컬럼에서 조건을 비교하는 경우)

  *  in연산자 : or연산자의 의미와 동일 (같은 컬럼에서 값을 여러 개 비교해야 하는 경우)

    => 컬렴명 in (비교값1, 비교값2, ...)

  * not연산자 : 부정

* null 값에 대한 비교

  *  is null : null인 데이터를 조회
  *  is not null : null이 아닌 데이터를 조회


#### 3. SQL-PLUS에서 사용할 수 있는 명령어

* 컬럼명 like 값 % ( 값으로만 시작하면 글자수 상관 x)
* 컬럼명 like % 값 ( 값으로 끝나는 글자)
* 컬럼명 like % 값 % (값이 있는건 다 조회)
* 컬럼명 like __A_ _ _ : 두번째에 A가 들어간 거
* like 연산자 : 대표문자와 함게 사용
  	=> 조건 비교를 위해 입력한 값이 문자열에 포함되어 있는 것을 찾는 경우
    	=> % : 모든 문자열
    	 _ ; 한 자리 문자를 의미
  
* cl scr : 전체화면 클리어
* conn : 접속

#### 4. 데이터 정렬

```bash
SELECT[distinct] 컬럼명1, 컬럼명2, ...[alias명]
	FROM 테이블명
	WHERE 조건
	ORDER BY 컬럼명 정렬기준
```

* 정렬기준	
  * asc : 오름차순 정렬
  * desc : 내림차순 정렬
  * 정렬기준을 생략하면 기본은 오름차순
  * 정렬기준을 여러개 설정할 수 있다.( , 를 이용해서)



### 4. 함수

#### 1. 단일행 함수

>  select, where, order by절에 모두 사용할 수 있다.

>  테이블의 모든 행에 각각 함수가 적용된다.

##### (1) 문자함수

* *lower* (문자열 or 컬럼명) : 값을 소문자로 변환

* *upper* (문자열 or 컬럼명) : 값을 대문자로 변환

* *initcap* (문자열 or 컬럼명) : 전달된 값의 첫글자만 대문자로 변환

* *substr* (문자열 or 컬럼명, 시작위치, 문자열의 갯수) : 

  * oracle은 index가 1부터 시작한다고 생각한다.

  ```bash
  select substr('oracle', 2, 2) from dual;
  
  > ra
  ```

  

* *length* (문자열 or 컬럼명) : 문자열의 길이를 반환

* *instr* (문자열 or 컬럼명**, **찾을 문자**, **찾을 위치**,** n번째 문자) :

  * 특정 컬럼이나 문자열에서 문자 위치를 찾을 때 사용하는 함수.(indexof)
  * 찾을 위치나 n번째 문자에 대한 매개변수는 생략이 가능
  * 찾을 위치를 -1로 정의하면 문자열의 오른쪽 끝에서 문자를 찾는다.(lastindexof)

  ```bash 
  select instr('oracle oracle oracle', 'a', 5, 2) 
  from dual;
  
  > 17
  => 해당 문자열의 5번 위치부터 a를 찾아 위치를 반환.
  => 단, 2번째 a위치를 반환
  ```

* *concat* (문자열 or 컬럼명**,** 문자열 or 컴럼명) : || 연산자와 동일 => 문자열 연결

* *LPAD* (문자열 or 컬럼명**,** 출력할 문자열의길이**,** 출력할 문자열(채움문자))

  * 전체 출력할 문자열의 길이에 문자열을 출력한 후 남는 공간에 정의한 문자를 채워 출력해주는 함수(왼쪽)

* *RPAD*(문자열 or 컬럼명**,** 출력할 문자열의 길이**,** 출력할 문자열(채움문자))

  * 전체 출력한 문자열의 길이에 문자열을 출력한 후 남는공간에 정의한 문자를 채워 출력해주는 함수(오른)

  ```bash
  select rapd('oracle', 10, '*') from dual;
  
  > oracle****
  ```

* *ltrim *(문자열 or 컬럼명**,** 문자)

  * 컬럼에서 매개변수로 정의한 문자를 왼쪽에서 찾아 모두 제거
  * 연속된 문자만 제거

* *rtrim*(문자열 or 컬럼명**,** 문자)

  * 컬럼에서 매개변수로 정의한 문자를 오른쪽에서 찾아 모두 제거
  * 연속된 문자만 제거

  ```bash
  select rtrim('oracleaaaaaaaaaaa', 'a') from dual;
  
  > oracle
  ```

  

##### (2) 숫자 함수

* *round*(숫자, 반올림한 위치) : 반올림

```bash
select round(125.8888, -1) from dual;
> 130

select round(125,8888, 1) from dual;
>125.9
```

* *floor* (숫자, 반올림한 위치): 버림
* *trunc* (숫자, 반올림한 위치): 버림
* *ceil* (숫자, 반올림한 위치): 올림

##### (3) 변환함수

* 데이터의 타입을 변환하기 위한 함수

* 또 다른 함수의 매개변수로 사용하게될 경우 타입이 컬럼의 타입과 일치해야 하므로

* *cast* (값 or 컬럼명 as 타입)

  * 타입 : date(날짜) / integer (숫자)

* *to_char* (변환할데이터, 표시할format)

  * 숫자를 문자로 변환 : 세 자리마다 **,**를 출력하고 싶은 경우
    * 숫자의 한자리를 표시 => 9, 0
    * 콤마 => ,
    * 소수점 => .
    * 통화기호 => \, $, L(지역의 통화기호를 출력) 
  * 날짜를 문자로 변환 : 년 원 일 각각의 데이터를 추출하고 싶은 경우
    * 년도 => YYYY(2019)
    * 월 => MM(12)
    * 일 => DD(19)

  ```bash
  select ename, sal, to_char(sal, 'L9.999') from emp;
  >￦2,975
  select ename, hiredate, to_char(hiredate, 'YYYY')
  >1996
  ```

##### (4) 날짜함수

* sysdate : 오늘 날짜
  * 연산이 가능하다.

##### (5) null처리함수

* *nvl* (컬럼, null인 경우 처리할 식이나 값) : null인 경우 대신할 식이나 값을 명시
* *nvl2* (컬럼, 표현값1, 표현값2)
  * 표현값 1 ; null이 아닌 경우 
  * 표현값 2 ;  null인 경우

##### (6) *****언어 변환

```bash
alter session set nls_launguage = 'american';
=> oracle에서 사용하는 언어를 바꿀 수가 있다.
```



#### 2. 그룹행 함수

> GROUP  BY를 적용한 후에 사용할 함수

> sum(총합), avg(평균), max(최대값), min(최솟값), count(카운트) 등

* 그룹함수는 그룹으로 묶인 데이터에 적용되므로 where절에 그룹함수를 사용할 수 없다.
  * where절은 한행 한행 검사하기 때문.

### 5. 그룹화

```bash
SELECT 컬럼...
FROM 테이블...
WHERE 조건
GROUP BY 그룹화할 컬럼명(함수를 포함한 식도 가능)
HAVING 그룹바이한 결과에 적용할 조건
ORDER BY 정렬할 컬럼명
```

* 테이블에 저장된 레코드를 그룹화하여 분류하고 싶은 경우 사용

* 내가 갖고 있는 데이터들을 다 표시할 것이 아니라, 내가 보고싶은 컬럼만 볼 것이다!

* select절에는 group by절에 명시한 컬럼명과 그룹함수만 사용할 수 있다.

* 데이터가 복잡한 경우 group by절에 두 개 이상의 컬럼을 명시할 수 있다.

* group by하기 전에 적용해야 하는 조건은 where 절에 정의

* group by한 결과에 조건을 적용해야 하는 경우 having절을 이용
  
  * **조건에 그룹함수를 써야 하면 having에 추가!**
  
* 앞에 명시한 게 대그룹 - 뒤에 있는 게 소그룹.

  => 먼저 대그룹으로 묶고 난 후 그 후에 다시 소분류로 분류하겠다!

* **1) from --> 2) where --> 3) group by --> 4) having --> 5) select --> 6)order by순으로 인식된다.**

### 6. 조인(JOIN)

* PK와 FK관계인 테이블에서만 조인이 가능하다.
* 어떤 테이블을쓸지 명시 - 조인조건
* 테이블과 테이블의 연관성을 명시.
* 2개 이상의 테이블에서 어떤 값을 뽑아서 하나의 결과를 만들고 싶을 때.
* 정규화된 테이블이나 혹은 일반적으로 작성된 여러 테이블의 컬럼을 이용해서 데이터를 조회하는 것을 조인.
* 조인은 관계형 데이터베이스(RDBMS)에서 반드시 알아야 하는 개념
* 기본키와 외래키의 관계를 이용해서 테이블을 조인
  * 외래키를 가지고 기본키 테이블에서 값을 비교하여 작업이 진행된다.
* 조인을 하는 경우 반드시 **where절**에 조인조건을 정의해야 한다.
* 테이블을 여러개 사용하는 경우 모든 테이블들의 조인조건을 정의해야 하며 select절에서 사용하지 않고 조건으로만 사용한다고 하더라도 조인조건은 정의해야 한다.

#### [ 조인 작성 방법 ]

1. from절에 조회하고 싶은 데이터가 저장된 테이블들을 모두 명시

2. 조인을 하는 경우 컬럼이 어떤 테이블의 컬럼인지 명확하게 정의하기 위해 **"테이블명.컬럼명"**으로 액세스를 한다.

3. from절에 테이블명을 정의하면서 alias를 함께 추가하여 alias를 통해 액세스하도록 한다.

   ```bash
   SELECT alias1.컬럼명 , alias2.컬럼명....
   FROM 테이블1 alias1, 테이블2 alias2
   ```

4. where절에는 반드시 조인조건을 추가하며 조인조건에는 두 테이블의 값을 비교하기 위해 정의하는 것이므로 외래키(FK)와 기본키(PK)를 정의한다.

   * 외래키테이블(child 테이블)에 정의된 컬럼값을 기본키테이블(parent 테이블)에서 비교하여 정확하게 일치하는 경우 값을 가져온다.

     (테이블이 두개 - 조인조건 한 개  ,  테이블이 세 개 -  조인조건 두 개, 테이블이 네 개 - 조인조건 세 개)

* 여러 테이블에서 조인을 하기 위해 기본키의 기준을 적절히 정의해줘야 한다!!

#### [ 조인의 종류 ]

##### (1) equi join -내부조인

- 두 테이블에서 정확하게 일치하는 컬럼에 대한 데이터만

##### (2) outer join -외부조인

- 두 개 이상의 테이블에 조인을 적용했을 때 join조건을 만족하지 않아도 데이터를 조회하고 싶은 경우 사용
- 조인조건에 (+)를 추가한다.
- 조인조건을 만족하지 않아도 한 쪽 테이블의 모든 데이터를 출력하고 싶을 때 사용하는 조인방식으로 정보가 부족한 테이블의 컬럼에 (+)를 추가한다.
  - (+)기호는 한쪽에만 사용한다
  - 데이터가 확장되어야 하는 곳에 추가한다.

```bash
SELECT 테이블alias.컬럼명..
FROM 테이블 alias
WHERE 테이블alias.컬렴명 = 테이블alias.컬렴명(+)
WHERE 테이블alias.컬렴명(+) = 테이블alias.컬렴명
```

##### (3) self join

* 두 개 이상의 테이블에서 조인하지 않고 같은 테이블의 컬럼을 이용해서 조인.

  (하나의 가상 테이블 생성)
<<<<<<< HEAD


=======

  

### 7. 시퀀스(SEQUENCE)

#### 1. 시퀀스 개념 이해와 시퀀스 생성

\- 오라클에서는 행을 구분하기 위해서 기본 키를 두고 있습니다. 기본 키는 중복된 값을 가질 수 있으므로 항상 유일한 값을 가져야 합니다. 

\- 기본 키가 유일한 값을 갖도록 사용가가 직접 값을 생성해내려면 부담이 클 것입니다. 

\- 시퀀스는 테이블 내의 유일한 숫자를 자동으로 생성하는 자동 번호 발생기이므로 시퀀스를 기본 키로 사용하게 되면 사용자의 부담을 줄일 수 있습니다.

#### 2. 뷰의 기본 테이블

다음은 시퀀스를 생성하기 위한 기본 형식입니다. 

CREATE SEQUENCE sequence_name 

​        [START WITH n]               ① 

​        [INCREMENT BY n]             ② 

​        [{MAXVALUE n | NOMAXVALUE}]   ③

​        [{MINVALUE n | NOMINVALUE}]    ④

​        [{CYCLE | NOCYCLE}]           ⑤

​        [{CACHE n | NOCACHE}]         ⑥ 

① START WITH 

시퀀스 번호의 시작값을 지정할 때 사용됩니다. 만일 1부터 시작되는 시퀀스를 생성하려면 START WITH 1이라고 기술하면 됩니다. 

② INCREMENT BY 

연속적인 시퀀스 번호의 증가치를 지정할 때 사용됩니다. 만일 1씩 증가하는 시퀀스를 생성하려면 INCREMENT BY 1이라고 기술하면 됩니다. 

③ MAXVALUE n | NOMAXVALUE 

MAXVALUE 은 시퀀스가 가질 수 있는 최대값을 지정합니다. 만일 NOMAXVALUE를 지정하게 되면 ASCENDING 순서일 경우에는 1027승이고 DESCENDING 순서일 경우에는 -1로 설정됩니다.

④ MINVALUE n | NOMINVALUE

MINVALUE 은 시퀀스가 가질수 있는 최소값을 지정합니다. 만일 NOMINVALUE을 지정하게 되면 ASCENDING 순서일 경우에는 1이고 DESCENDING 순서일 경우에는 1026승으로 설정됩니다.

⑤ CYCLE | NOCYCLE

CYCLE 은 지정된 시퀀스 값이 최대값까지 증가가 완료되게 되면 다시 START WITH 옵션에 지정한 시작 값에서 다시 시퀀스를 시작하도록 합니다. NOCYCLE은 증가가 완료되게 되면 에러를 유발시킵니다. 

⑥ CACHE n | NOCACHE 

CACHE 은 메모리상의 시퀀스 값을 관리하도록 하는 것인데 기본 값은 20입니다. NOCACHE는 원칙적으로 메모리 상에서 시퀀스를 관리하지 않습니다.
>>>>>>> d7b64bb14e6cf0a250fc1284aec1675b9cd4777a







# SQLD 시험 - 2020/05/31(일)

