# [ 경력 관련 ]

> *내가 했던 특별한 업무 -> 어떻게 모니터링 솔루션에 적용이 될 수 있는지 고민한다.*
>
> *호기심있게, 또는 깊게 파고들었던 경험.*
>
> *창조적으로, 창의적으로 개발할 수 있는 능력*
>
> *소통과 협업 능력*



**RTOS 제공하는 타이머 핸들러를 커스터마이징 해서 사용 하였는데, 내가 만든 task의 Prioroity가 이벤트 녹화 등 메인 핸들러에서 작업하는 Priority보다 낮아서, 내 Task의 Message Queue에 데이터가 쌓이게 되고 이로 인해 LinkedList의 데이터 수집이 밀리면서 저장 데이터의 누락이 발생**

1. 데이터를 SD카드에 곧바로 저장해서 SD카드가 성능적으로 부담이 되어 그런 것이 아니야? nand에 저장해놓았다가 필요할 때마다 SD카드에 저장해볼까? -> 달라진점 없음
2. LinkedList 내에서 메모리 free를 해주지 않은 곳을 찾기 위해 -> 실제 SQLITE 데이터베이스와 맵핑 되는 메소드 안에서, 메모리 사용량을 체크 -> 정상동작 확인
3. 여러 타이머 핸들러가 멀티 태스킹 구조로 되어 있어서 공유자원 문제가 생길 수 있는 것 같다. -> 공유자원 문제를 해결하기 위해서 RTOS에서 제공하는 mutex를 사용해봄
   - mutex_retry를 10번씩 찍으면서.

**그렇다면 커스텀 핸들러를 쓰지말고, 하나의 핸들러로 합쳐보자! -> 데이터 누락 문제는 해결됨.**
**하지만 각기 다른 이벤트 녹화 시 두 가 지 에러가 발생함**
**1) 하나는 ARM DATA ABORT EXCEPTION(메모리 접근에러)**
**2) 다른 하나는 데이터를 저장하는 (free method)에서 계속 되는 WDT TIMEOUT !!**

1. 메모리 접근 에러는 메모리 맵의 주소를 통해 program counter가 타이머핸들러를 가리키는 것을 확인했고, 두 번째 와치독 에러에 의해서 동시에 RTOS 와치독에 대해서 공부해보았다.
2. WDT이 의심스러워 WDT TIMEOUT의 주기를 12초에서 22초로 늘려보았는데 반응 X
3. 결국, 데이터 저장 기능을 timer_handler가 아니라 method로 분리함. WDT timer handler와 같은 핸들러를 사용중이어서, WDT KICK 처리가 밀려버림 -> 해결!



**기획 쪽의 각종 요구사항에 맞게 여러 비즈니스로직을 처리**

- 최소 360시간동안 데이터 저장되어야 하고. 그 시간이 지난 파일은 자동으로 삭제되도록 기능 추가.
 - 특정 녹화시에는 파일을 새로 만들지 않도록하고,
 - 파일의 생성 날짜계산에 유의



# [ 스프링부트 ]

---

![image-20210913160550307](../tmpImg/image-20210913160550307.png)



## 도메인 분석 설계

![image-20210913164213569](../tmpImg/image-20210913164213569.png)

- 요구사항 분석
- 도메인모델과 테이블 설계
  - 엔티티 분석
  - 연관관계 매핑 분석
- 엔티티 클래스 개발
  - 회원, 주문, 주문상태, 주문상품, 상품, 배송, 배송상태, 카테고리 엔티티
  - `@ManyToMany`는 편리한 것 같지만, 중간 테이블에 컬럼을 추가할 수 없고 세밀하게 쿼리를 실행하기 어렵기 때문에, 실무에서는 중간엔티티(`CategoryItem`)을 만들고 `@ManyToOne`이나 `@OneToMany`로 매핑하자
  - **엔티티에는 가급적 Setter 사용하지 말자**
    - Setter가 모두 열려 있으면 변경 포인트가 많아서, 유지보수가 어렵다.
  - **모든 연관관계는 지연로딩으로 설정하자.**
    - 즉시로딩은(`EAGER`)은 예측이 어렵고, 어떤 SQL이 실행될지 추적하기 어렵다.
    - `@XToOne` 관계는 즉시로딩이 디폴트이므로, 직접 지연로딩으로 설정해야 한다.
  - **컬렉션을 필드에서 초기화 하자.**
    - 컬렉션은 필드에서 초기화 하는 것이 `null`문제에서 안전하다
    - 하이버네이트는 엔티티를 영속화 할때, 컬렉션을 감싸서 하이버네이트가 제공하는 내장 컬렉션으로 변경하기 때문에 필드레벨에서 생성하는 것이 안전하고, 코드도 간결하다.

---

## 애플리케이션 구현

- 회원 기능

  - 회원 등록, 조회

- 상품 기능

  - 상품 등록, 수정, 조회

- 주문 기능

  - 상품 주문, 주문 내역 조회, 주문 취소

- 계층형 구조 사용

  ![image-20210913154001516](../tmpImg/image-20210913154001516-1631515252922.png)

  - Controller : 웹 계층
  - Service : 비즈니스 로직, 트랜잭션 처리
  - Repository : JPA를 직접 사용하는 계층, 엔티티 매니저 사용
  - Domain : 엔티티가 모여 있는 계층, 모든 계층에서 사용

- **개발 순서는 서비스와 레포지토리 계층을 개발하고, 테스트케이스를 작성해서 검증한 뒤에 마지막으로 웹 계층을 적용한다.(도메인은 요구사항을 분석하며 엔티티 클래스의 뼈대을 먼저 진행했다.)**

---

## 도메인 개발

- 회원 도메인
  - 회원 엔티티
  - 회원 레포지토리
  - 회원 서비스
  - 회원 기능 테스트
- 상품 도메인
  - 상품 엔티티
  - 상품 레포지토리
  - 상품 서비스
  - 상품 테스트
- 주문 도메인
  - 주문 엔티티
  - 주문상품 엔티티
  - 주문 레포지토리
  - 주문 서비스
  - 주문 기능 테스트

*++ 주문 검색기능 개발 (JPA에서는 동적쿼리를 어떻게? -> `QueryDSL`)*

---

## 웹 계층 개발

- 홈 컨트롤러
- 회원 등록 컨트롤러
- 회원 목록 컨트롤러
- 상품 등록 컨트롤러
- 상품 목록 컨트롤러
- 상품 수정 컨트롤러
- 상품 주문 컨트롤러
- 주문 목록 검색, 취소 컨트롤러



## > 엔티티를 변경하는 방법

- 변경감지를 사용하라.
  - 컨트롤러에서 어설프게 엔티티를 생성하지 마라
  - 트랜잭션이 있는 서비스 계층에 식별자(`id`)와 변경할 데이터를 명확하게 전달하라.(파라미터 or DTO)
  - 트랜잭션이 있는 서비스 계층에서 영속상태의 엔티티를 조회하고, 엔티티의 데이터를 직접 변경하라.
  - 트랜잭션 커밋 시점에 변경 감지가 실행된다.

## > 질답

---

@Autowired 를 통하여 여러개의 Repository 를 하나의 메소드에서 처리해도되나요?

```bash
@RequiredArgsConstructor 는 final 키워드 혹은 @NonNull 붙은 필드의 생성자를 만들어주는 역할을 하는데요

생성자를 직접 만들어주셨으니 @RequiredArgsConstructor 없이 생성자 주입이 가능합니다.

또한 스프링 4.3부터 생성자가 하나일 때 @Autowired를 생략이 가능하며 올리신 코드에서 @Autowired를 생략해도 정상적으로 빈 주입이 됩니다.
```

---

[Controller와 Service 로직 구분에 대한 질문과 답변 1](https://www.inflearn.com/questions/55208)

안녕하세요 강사님! 강의 잘듣고 있습니다ㅎㅎ

비지니스 로직을 제가 Controller에 많이 넣는것 같습니다ㅜ

controller와 service의 구분이 잘 안되는것 같아서

혹시 Controller와 Service에 넣는 코드들은 어떤 기준이 있는지 여쭤봐도 될까요?!

(객체에 set해주는 부분들은 보통 controller에서 처리를 하나요 아니면 view에서 값을 controller에서 받아온후 service로 넘겨서 처리를 해주는건가요?)

```bash
안녕하세요. BeomJun Lee님^^

Controller는 사용자의 입력을 분석하고 사용자에게 제공될 뷰에 데이터를 전달하는 역할을 합니다.

좀 극단적이기는 한데요. 이렇게 딱 생각하시면 좋습니다!

컨트롤러같은 웹 계층이 없어도 애플리케이션이 동작해야 합니다.

컨트롤러는 웹 계층을 처리하기 위한 코드만 존재하는 것이 좋습니다. 예를 들어서 웹 계층이 없이 단순히 메인 메서드를 통해서 콘솔에서만 동작하는 애플리케이션을 추가로 개발해야 해도 대부분의 서비스 로직을 재사용할 수 있다면 좋겠지요?

반대로 이야기하면 웹 계층을 위한 폼 데이터를 처리하고, 화면에 뿌릴 데이터를 모아서 넘겨주고 이런 웹 계층 관련 일들은 모두 컨트롤러에서 담당해야겠지요?

이런 관점을 접근하시면 어느정도 고민을 덜 수 있을 거에요.
```

---

[Controller와 Service 로직 구분에 대한 질문과 답변 2](https://www.inflearn.com/questions/224823/)

안녕하세요 강사님! 항상 강의 잘보고 있습니다.

정확히 강의 관련된 질문은 아니지만 헷갈리는 부분이 있어서요.

spring에서 말하는 model이라는 개념이 domain, repository 등등을 포함하여 말하는 것인지 

아니면 controller에서 view에 값을 넘겨줄 때 쓰는 Model 클래스를 말하는 것인지 헷갈립니다!

찾아보니 블로그마다  다르게 명시가 되어있더라구요

java beans들을 model이라고 하는 사람도 있던데 뭐가 맞는것일까요??.. 

```bash
안녕하세요. 효진님

모델이라는 의미는 문맥에 따라서 다르게 사용됩니다.

mvc에서는 controller에서 view에 값을 넘겨줄 때 쓰는 Model 클래스를 말하고,

설계에서는 domain 모델등을 뜻합니다.

감사합니다.
```

---

setMember() 내부에서 member.getOrders().add(this)를 해주는 이유

```bash
Member에서 본인이 주문한 Order에 대해 접근하려면 Order에 대한 참조를 가지고 있어야 합니다. 그 참조가 Member의 orders입니다.

반대로 Order에서 주문자를 찾아가려면 Member에 대한 참조가 있어야 합니다. 그 참조가 Order의 member입니다.

DB상에서는 Order의 foreign key인 Member_id로 member를 찾아갈 수 있지만

객체상에서는 Member에서 order를 찾아갈 방법이 없습니다.

따라서 주문할 때 Member에는 order를, Order에는 member를 넣어줘서 서로 참조할 수 있게 하는 것입니다.

 

값이 들어가는 것은

1. DB상으로는 Order의 외래키로 Member_Id가 저장됩니다.

2. 객체상으로는 Member의 orders에 order가 추가되고, Order의 member에 member가 지정됩니다.
```

---

왜 JPA의 Entity는 기본 생성자를 가져야 하는가요?

https://hyeonic.tistory.com/191

```bash
정리하면 JPA의 구현체인 hibernate에서 제공하는 다양한 기능을 활용하기 위해서는 public이나 protected 기본 생성자가 필요하다. private로 생성자를 만들게 되면 이러한 기능들을 사용하는데 제약이 되기 때문이다. 

다만 안정성 측면에서 좀 더 작은 scope 가진 protected 기본 생성자를 주로 사용해야 겠다. 더 나아가 혼자가 아닌 다른 팀원들과 협업을 진행하게 된다면 객체 생성을 어떤 식으로 해결해야 할지 고민하고 관련 내용들을 공유하여 무분별한 생성을 막아야 겠다는 생각이 들었다.
```

https://flashy-toucan-1ed.notion.site/Builder-7b7077515d674958b76076485dc0117d

```bash
객체에 값을 초기화 하는 방법은 3가지 정도가 있습니다.  수정자를 이용하는것과, 생성자를 이용하는 것, 그리고 빌더 패턴을 이용하는 방법입니다. (객체를 생성하면 프로퍼티는 각각 0에 대응하는 값 또는 null로 초기화 됩니다. 이런 초기화는 논의에서 제외합니다)

- 프로퍼티는 불변으로 사용하는것이 좋습니다.
- 프로퍼티가 3개 이하면 생성자 초기화를 합니다.
- 프로퍼티가 4개 이상이면 빌더 패턴을 고려합니다.
```

