# Graph :fist_oncoming:

# **> Graph Algorithm - 개념과 표현**

---

## Graph

- (무방향) 그래프 G = (V, E)
  - V : 노드 혹은 정점(vertex)
  - E : 노드쌍을 연결하는 Edge 혹은 Link(간선)
  - Object들 간의 이진관계를 표현
  - n = |V|, m = |E|

![image-20200828143623650](https://user-images.githubusercontent.com/58545240/91525664-f8d15780-e93c-11ea-9dd3-c75da58350a4.png)

- 방향 그래프와 가중치 그래프
  - 방향그래프(Directed Graph) G = (V, E)
  - Edge (u, v)는 u로부터 v로의 방향을 가짐
- 가중치 그래프
  - Edge마다 가중치(weight)가 존재

### 그래프의 표현

- 인접행렬(adjacency matrix)

![image-20200828143638892](https://user-images.githubusercontent.com/58545240/91525670-fcfd7500-e93c-11ea-94c9-2bf4e7295fcb.png)

- 인접리스트(adjacency list)

  - 정점 집합을 표현하는 하나의 배열과
  - 각 정점마다 인접한 정점들의 연결 리스트

  ![image-20200828143658731](https://user-images.githubusercontent.com/58545240/91525679-0090fc00-e93d-11ea-895c-ffb31e63dda2.png)

  - 저장 공간 : O(n + m)
  - 어떤 노드 v에 인접한 모든 노드 찾기 : O(degree(v)) 시간
  - 어떤 Edge (u, v)가 존재하는지 검사 : O(degree(u)) 시간

- 방향그래프(directed graph)

  - 인접행렬은 비대칭
  - 인접 리스트는 m개의 노드를 가진다

  ![image-20200828143716749](https://user-images.githubusercontent.com/58545240/91525687-04bd1980-e93d-11ea-8c14-909aa0dbb0c4.png)

- 가중치 그래프의 인접행렬 표현

  - 엣지의 존재를 나타내는 값으로 1대신 엣지의 가중치를 저장
  - 엣지가 없을 때 혹은 대각선
    - 그때마다 상황에 따라 정의 가능
    - 특별히 정해진 규칙은 없으며, 그래프와 가중치가 의마하는 바에 따라서
    - Ex) 가중치가 거리 혹은 비용을 의미하는 경우라면 엣지가 없으면 oo(무한대), 대각선은 0
    - Ex) 만약 가중치가 용량을 의미한다면 엣지가 없을때 0, 대각선은 oo(무한대)

### 경로와 연결성

- 인접하다라는 것은 해당 경로를 거쳐서 그 노드에 도달할 수 있다라는 것이고, 연결되어 있다라는 것은 노드와 노드를 연결하는 경로가 존재할 때를 말한다.
- 무방향 그래프 G = (V, E)에서 노드 u와 노드 v를 연결하는 경로(path)가 존재할 때 v와 u는 서로 연결되어 있다고 말함
- 모든 노드 쌍들이 서로 연결된 그래프를 연결된(connected) 그래프라고 한다.
- 연결요소(connected component)

![image-20200828143739748](https://user-images.githubusercontent.com/58545240/91525707-0f77ae80-e93d-11ea-8ead-4230a975452b.png)



# **> BFS(Breadth-First Search, 너비우선탐색)**

---

## 그래프 순회

- 순회(traversal)
  - 그래프의 모든 노드들을 방문하는 일
- 대표적 두 가지 방법
  - BFS (Breadth-First Search, 너비우선순회)
  - DFS (Depth-First Search, 깊이우선순회)

### 너비우선탐색(BFS)

- BFS 알고리즘은 다음 순서로 노드들을 방문

  - L0 = {s}, 여기서 s는 출발 노드
  - L1 = L0의 모든 이웃 노드들
  - L2 = L1의 이웃들 중 L0에 속하지 않는 노드들
  - ...
  - Li = Li-1의 이웃들 중 Li-2에 속하지 않는 노드들
  - 한마디로 그래프에서 노드들을 동심원의 형태로 순회하는 방법

  ![image-20200828143917671](https://user-images.githubusercontent.com/58545240/91525714-17cfe980-e93d-11ea-9364-06bf8287dfab.png)

### 큐를 이용한 너비우선탐색

- 출발노드를 check하고 시작한다.
- 큐에 스타트 노드(1번노드)를 삽입한다.

![image-20200828143929375](https://user-images.githubusercontent.com/58545240/91525727-1dc5ca80-e93d-11ea-8cb4-646a6d314c30.png)

- whil문을 돌면서 큐가 비어있을 때까지 반복한다.
  - 큐에서 노드(v)를 하나 꺼내고
  - 꺼낸 노드의 인접노드 중, 아직 방문되지 않은(unchecked) 노드들(w)을 체크하고 큐에 넣는다.
  - 이 때, 큐에 넣는 순서는 중요하지 않다.

![image-20200828143943051](https://user-images.githubusercontent.com/58545240/91525736-23bbab80-e93d-11ea-9048-b90852d6cd2f.png)

- 다시 큐에서 노드를 하나 꺼내고(2번 노드)
- 2번 노드의 체크되지 않은 인접 노드들(4, 5번 노드)을 체크상태로 변경하고 큐에 넣는다.

![image-20200828143954255](https://user-images.githubusercontent.com/58545240/91525756-2c13e680-e93d-11ea-87d3-0eecfc835ad7.png)

- 이런 방법으로 큐가 비어있는 상태가 될때까지 반복한다.
- 최종적으로 노드를 방문한 순서는 1, 2, 3, 4, 5, 7, 8, 6 이 된다. 하지만, 이 방문 순서는 유일하지 않다. 큐에 인접노드를 삽입하는 순서에 따라 달라지기 때문이다.

### BFS pesudo code

- 그래프 G, 출발 노드 S

```java
00 BFS(G, s)
01   Q <- null;
02   Enqueue(Q, s);
03   while Q != null do
04     u <- Dequeue(Q);
05     for each v adjacent to u do
06       if v is unvisited then
07         mark v as visited;
08         Enqueue(Q, v);
```

### BFS와 최단경로

- BFS는 단순히 그래프의 모든 노드를 방문하는 것 이상의 추가적인 중요한 일을 할 수 있다. 최단 경로를 구하는 일이다.
- s에서 Li에 속한 노드까지 최대 경로의 길이는 i이다.
  - 여기서 경로의 길이는 경로에 속한 엣지의 수를 의미한다.
- BFS를 하면서 각 노드에 대해서 최단 경로의 길이를 구할 수 있다.
- 입력
  - 방향 혹은 무방향 그래프 G = (V, E), 그리고 출발노드 s
- 출력
  - 모든 노드 v에 대해서
  - d[v] = s로 부터 v까지의 최단 경로의 길이(엣지의 개수)
  - π[V] = s로 부터 v까지의 최단경로상에서 v의 직전 노드(predecessor)
- Pseudo code
  - 02 - 04 : 모든 노드 u에 대해서 d[], π[]를 초기화
  - 05 - 06 : 스타트 노드의 d[], π[]를 설정
  - 11 : d[v] 가 -1인가를 체크하여 unvisited 체크를 구현
  - 12 - 13 : unvisited 노드에 대하여 d[v], π[v]를 저장
    - 최단경로 길이 d[v]는 u까지의 최단경로길이 d[u]를 지나오는 것이므로 d[u] + 1이 될 것이고,
    - v노드의 최단경로상에서 v의 직전노드는 u가 된다.
  - 14 : unchecked 노드만 큐에 들어갈 수 있으므로 어떤 노드도 큐에 두번 들어가지는 않는다.

```java
00 BFS(G, s)
01   Q <- null;
02   for each node u do
03     d[u] <- -1;
04     π[u] <- null;
05   d[s] <- 0;     //distance from s to s is 0
06   π[s] <- null;  //no predecessor of s
07   Enqueue(Q, s);
08   while Q != null do
09     u <- Dequeue(Q);
10     for each v adjacent to u do
11       if (d[v] == -1) then
12         d[v] <- d[u] + 1;    //distance to v
13         π[v] <- u;           //u is the predecessor of v
14         Enqueue(Q, v);
```

### 시간복잡도

- 02라인 for 의해 기본적으로 O(n)이다.
- 실제로는 08라인의 while문이 알고리즘의 시간복잡도를 결정한다.
- 기본적으로 while문이 한번 돌 때마다 큐에서 노드 하나씩 꺼내므로 while문은 최대 n번 돈다.
- 10라인의 for문은 u의 degree() 만큼 돈다. 리스트를 인접 행렬로 구현하느냐, 인접리스트로 구현하느냐에 따라 for문의 시간복잡도가 달라진다.
  - degree(v)는 어떤 한 노드 v에 실제로 인접한 노드의 수
- 그래프를 **인접 행렬로 구현할 경우** degree(v)를 찾으려면 O(n)이 든다. 따라서 인접행렬로 구현했을 떄의 while문의 시간복잡도는 O(n^2)이 된다.
- **인접 리스트로 구현할 경우**  전체 그래프에서 보면, for 문은 결국 모든 노드들의 degree() 만큼 돌 것이다. 인접리스트에서 그것은 2m이다.(무방향 그래프에서 총 엣지의 수) 시간복잡도는 O(m). 따라서, while문의 시간복잡도는 O(n + m)이 된다.
- 결과적으로 인접 리스트의 최악의경우 m이 n이 되므로 최악의 경우가 아닌 이상 인접 리스트로 구현하는 것이 좀 더 효율적이다.

### BFS로 구현한 d[]와 π[] 예시

![image-20200828144013107](https://user-images.githubusercontent.com/58545240/91525770-333af480-e93d-11ea-9e76-1cc6c00867d1.png)

### BFS 트리

- 각 노드 v와 π[v]를 연결하는 엣지들로 구성되는 트리
- BFS 트리에서 s에서 v까지의 경로는 s에서 v까지 가는 최단 경로
- 어떤 엣지도 동심원의 2개의 layer(L0에서 L2로 가지 않는다)를 건너가지 않는다.(동일 레이어의 노드를 연결하거나, 혹은 1개의 layer를 건너간다.)

![image-20200828144024810](https://user-images.githubusercontent.com/58545240/91525788-3b932f80-e93d-11ea-981b-c8c9e759cb31.png)

### 너비우선탐색: 최단 경로 출력하기

- 출발점 s에서 노드 v까지의 경로 출력하기
  - resursion으로 해결한다.
  - s에서 v까지 가는 최단 경로는 먼저 s에서 π[v]까지 가는 경로를 출력하고, v를 추가로 출력하면 된다.

```java
00 PRINT-PATH(G, s, v)
01   if v = s then
02    print s;
03  else if π[v] = null then    // 실제로 s에서 v까지 가는 경로가 없을 경우(최단경로도 없음)
04    print "no path from s to v exists";
05  else
06    PRINT-PATH(G, s, π[v]);
07    print v;
```

### 너비우선탐색(BFS) 정리

- 그래프가 connected 라면 모든 노드를 방문하게 된다. 하지만, 그래프가 **disconnected** 이거나 혹은 방향 그래프라면 BFS에 의해서 모든 노드가 방문되지 않을 수도 있다.
- disconnected 그래프의 모든 노드를 방문하려면 BFS를 반복하여 모든 노드 방문
  - 전체 노드중 unvisited 노드가 없을 때까지 BFS를 반복한다.

```java
BFS-ALL(G)
  while there exists unvisited node v
    BFS(G, V)
```

# **> DFS(Depth-First Search, 깊이우선탐색)**

---

- 이진트리의 순회 방법인 inorder, preorder, postorder 순회방법이 DFS의 이진트리 버전에 해당한다.
- lever order는 BFS의 이진트리 순회 버전이다.

## 깊이우선탐색(DFS)

- 출발점 s에서 시작한다.
- 현재 노드를 visited로 mark하고 인접한 노드들 중 unvisited 노드가 존재하면 그 노드로 간다.
- 2번을 계속 반복한다.
- 노드 8에 도달했을 때처럼 인접한 노드들중 invisited 노드가 존재하지 않는다면, unvisited인 이웃 노드가 존재하지 않는 동안 계속해서 직전 노드로 되돌아간다.
- 다시 2번을 계속 반복한다.
- 시작노드 s로 돌아오고 더 이상 갈 곳이 없으면 종료한다.

![image-20200828144256618](https://user-images.githubusercontent.com/58545240/91525796-41891080-e93d-11ea-935d-d054d8dde058.png)

- 다음과 같은 흐름으로 깊이우선순회가 이루어 진다.

![image-20200828144312828](https://user-images.githubusercontent.com/58545240/91525804-451c9780-e93d-11ea-93aa-9d4b21ebbcef.png)

### DFS, 깊이우선탐색

- 이진트리의 순회를 recursion으로 구현한 것처럼, 깊이우선탐색도 resursion으로 구현하는 것이 간명하다.
- 01 : 먼저 방문한 노드 v에 대해서 visited 체크를 하고
- 02 : v와 인접한 노드 x들에 대해서
- 03 : visited[x]가 No 이면,
- 04 : DFS(G, x)를 recursive하게 호출한다.
- 순회를 위해서 직전의 노드로 돌아가는 행동이 recursion으로 간명하게 구현된다.

```java
00 DFS(G, v)
01   visited[v] <- YES;
02   for each node x adjacent to v do
03     if visited[x] = No then
04       DFS(G, x);
```

- 그래프가 **disconnected 그래프 이거나 혹은 방향 그래프**라면 DFS에 의해서 모든 노드가 방문되지 않을 수도 있음
- DFS를 반복하여 모든 노드 방문
  - 모든 노드의 visited를 NO로 설정하고,
  - 해당 노드들을 출발노드로 하여 DFS를 호출, 연결되지 않은 그래프에 해당하는 노드는 visited가 NO로 유지되어서 DFS를 호출하게됨
- 시간복잡도
  - 첫번째 for문에 의해서 시간복잡도 O(n)은 피할 수 없고,
  - 두번째 for문에 의해서 v노드와 엣지로 이어진 노드가 visited인지를 체크한다. 따라서, 인접리스트로 표현했다면 시간복잡도는 엣지의 갯수에 비례하게 된다. O(m)
  - 최종적으로 O(n + m)의 시간복잡도를 갖는다.
  - 만약, 인접행렬로 표현했다면 인접노드의 여부를 알기위해서 전체 노드의 수 만큼 검색해야 하므로 O(n)이므로, O(n^2)의 시간복잡도를 갖는다.

```java
DFS-ALL(G)
  for each v in V
    visited[v] <- NO;
  for each v in V
    if (visited[v] = no) then
      DFS(G, v)
```



# **> 위상정렬(Topological Sort)**

---

> **어떤 일을 하는 순서를 찾는 알고리즘**
>
> => 즉, 방향 그래프에 존재하는 각 정점들의 선행 순서를 위배하지 않으면서 모든 정점을 나열하는 것

## 위상정렬의 특징

![image-20200911102426695](https://user-images.githubusercontent.com/58545240/92840886-9daf6280-f41c-11ea-99cd-f2b586831c2d.png)

- 하나의 방향 그래프에는 여러 위상 정렬이 가능하다.
- 위상 정렬의 과정에서 선택되는 정점의 순서를 위상 순서(Toplogical Order)라 한다.
- 위상 정렬의 과정에서 그래프에 남아 있는 정점 중에 진입 차수가 0인 정점이 없다면, 위상 정렬 알고리즘은 중단되고 이러한 그래프로 표현된 문제는 실행이 불가능한 문제가 된다.

=> 위상정렬이 가능하려면 ***DAG(Directed Acyclic Graph, 방향성이 있으며 사이클이 없는 그래프)***여야 한다.

1. 말 그대로 두 노드 `A`, `B` 사이에 A->B 같은 관계가 성립되어야 하며
2. A->B, B<-A 처럼 그래프들 사이에 사이클이 없어야 한다.

=> 위상정렬은 DFS를 사용하여 구현하거나 `indegree`배열을 사용하여 구현할 수 있다.(**indegree**가 가장 많이 쓰이고 간단하다)

- `List<List<Integer>> array` : 그래프의 관계를 표현하기 위한 2차원 인접 리스트
- `int[] indegree` : 해당 노드를 가리키는 간선 갯수를 담기 위한 배열
- `Queue<Integer> q` : `indegree` 값이 0이 된 노드들을 담기 위한 `Queue`
- `Queue<Integer> result` : `Queue`에서 꺼내져 결과로 출력하기 위해 담는 결과 `Queue`

## 위상정렬의 동작방식

![image-20200911104241195](https://user-images.githubusercontent.com/58545240/92840908-a4d67080-f41c-11ea-9f6e-861b6abf33da.png)

1. 진입차수가 0인 정점(즉, 들어오는 간선의 수가 0)을 선택
   - 진입차수가 0인 정점이 여러개 존재할 경우 어느 정점을 선택해도 무방하다.
   - 초기에 간선의 수가 0인 모든 정점을 큐에 삽입
2. 선택된 정점과 여기에 부속된 모든 간선을 삭제
   - 선택된 정점을 큐에서 삭제
   - 선택된 정점에 부속된 모든 간선에 대해 간선의 수를 감소
3. 위의 과정을 반복해서 모든 정점이 선택, 삭제되면 알고리즘 종료



- 위상 정렬은 정해진 결과 값이 없다. **중요한 점은 화살표가 가리키는 순서는 꼭 지켜져야 한다는 것!**

```bash
1 - 2 - 5 - 4 - 6
1 - 2 - 4 - 6
1 - 3 - 4 - 6
1 - 3 - 7
```

이 순서는 어떤 정렬 결과가 나오더라도 변하지 않을 것이다.

## 코드

```java
import java.util.*;
public class TopologicalSort{
    static int n;
    static int e;
    
    public static void main(String[] args){
        n = 7;	// 정점 갯수
        e = 9;	// 간선 갯수
        int[] indegree = new int[n+1];
        List<List<Integer>> array = new ArrayList<List<Integer>>();
        
        for(int i=0; i<n+1; i++){
            array.add(new ArrayList<Intger>());
        }
        
        // 간선목록 v1 -> v2
        int[] v1 = {1, 1, 2, 4, 3, 3, 5, 2, 5};
        int[] v2 = {2, 3, 5, 6, 4, 7, 6, 4, 4};
        
        /*
        1. v1 -> v2 인접리스트 생성
        2. v2를 가리키는 노드 갯수 indegree 증가
        */
        for(int i=0; i<e; i++){
            int c1 = v1[i];
            int c2 = v2[i];
            
            array.get(c1).add(c2);
            indegree[c2]++;
        }
        topologicalSort(indegree, array);
    }
    
    public static void topologicalSort(int[] indegree, List<List<Integer>> graph){
        Queue<Integer> q = new LinkedList<Integer>();
        Queue<Integer> result = new LinkedList<Integer>();
        
        // 큐에 indegree가 0인 노드 담기
        for(int i=1; i<n; i++){
            if(indegree[i]==0){
                q.offer(i);
            }
        }
        
        /*
        1. 큐에서 값을 꺼내며 해당 노드가 가리키는 노드의 indegree를 1 감소
        2. 만약 indegree가 0이 된다면 큐에 넣기
        3. 큐가 빌때까지 반복
        */
        while(!q.isEmpty()){
            int node = q.poll();
            result.offer(node);
            for(Integer i : graph.get(node)){
                indegree[i]--;
                
                if(indegree[i] == 0){
                    q.offer(i);
                }
            }
        }
        System.out.println(result);
    }
}
```

## 위상정렬 관련 문제

1. 각각의 작업이 완료되어야만 끝나는 프로젝트

2. 선수 과목

   - 큐를 이용한 위상정렬

     [줄 세우기 - 백준 2252번](https://www.acmicpc.net/problem/2252)

   - 우선순위 큐를 이용한 위상정렬

     [문제집 - 백준 1766번](https://www.acmicpc.net/problem/1766)

   - 여러 위상순서 중 가장 짧게 걸리는 위상 정렬 방법 구하기

     [작업 - 백준 2056번](https://www.acmicpc.net/problem/2056)

     [게임개발 - 백준 1516번](https://www.acmicpc.net/problem/1516)

## 참고

https://bcp0109.tistory.com/entry/%EC%9C%84%EC%83%81%EC%A0%95%EB%A0%AC-Topological-Sort-Java?category=848939

https://gmlwjd9405.github.io/2018/08/27/algorithm-topological-sort.html



# **> 유니온 파인드(Union-Find)**

---

> 그래프 알고리즘으로 **합집합 찾기 알고리즘**이다.
>
> **상호 배타적 집합(Disjoint-set)**이라고도 한다.

*Disjoint Set이란 서로 중복되지 않는 부분집합들로 나눠진 원소들에 대한 정보를 저장하고 조작하는 자료구조이다.*

## 유니온파인드의 특징

**Union-Find**란 Disjoint Set을 표현할 때 사용하는 알고리즘이다.

- 집합을 구현하는 데는 비트 벡터, 배열, 연결 리스트를 이용할 수 있으나 그중 가장 효율적인 **트리 구조**를 이용하여 구현한다.
- **`make-set(x)`**
  - 초기화
  - x를 유일한 원소로 하는 새로운 집합을 만든다.
- **`union(x,y)`**
  - 합하기
  - x가 속한 집합과 y가 속한 집합을 합친다.
- **`find(x)`**
  - 찾기
  - x가 속한 집합의 대표값(루트 노드값)을 반환한다. 즉 x가 어떤 집합에 속해 있는지 찾는 연산



여러 노드가 존재 할 때 두 개의 노드를 선택해서, 현재 두 노드가 서로 같은 그래프에 속하는지 판별하는 알고리즘이다.

총 2가지의 연산으로 이루어져 있다.

- **Find** : x가 어떤 집합에 포함되어 있는지 찾는 연산
- **Union** : x와 y가 포함되어 있는 집합을 합치는 연산

## 유니온 파인드의 동작방식

![image-20200911110302450](https://user-images.githubusercontent.com/58545240/92844373-bde12080-f420-11ea-8fc9-3855c3cf3399.png)

위와 같이 모두 연결되지 않고 각자 자기 자신만을 집합의 원소로 가지고 있을 때, 모든 값이 자기 자신을 가리키도록 만든다.

**`i` : 노드번호, `P[i]`: 부모 노드 번호**를 의미하며, 즉 자기 자신이 어떤 부모에 포함되어 있는지를 의미한다.

정리하면 **`Parent[i] = i`**

![image-20200911110501896](https://user-images.githubusercontent.com/58545240/92844392-c3d70180-f420-11ea-8789-6ec6c622624c.png)

**`Union(1,2), Union(3,4)`**를 해주어 위와 같이 노드를 연결해준다.

![image-20200911110550615](https://user-images.githubusercontent.com/58545240/92844412-c8031f00-f420-11ea-9f4e-68a91a05871d.png)

위와 같이 표로 표현이 된다. 2번째 인덱스에 '1'이 들어가고, 4번인덱스에 '3'이 들어간다.

**이와 같이 부모를 합칠 때는 일반적으로 더 작은 값 쪽으로 합친다.** 이것을 **합칩(Union) 과정**이라고 한다.

![image-20200911110639947](https://user-images.githubusercontent.com/58545240/92844427-cc2f3c80-f420-11ea-903e-2c60e02518a4.png)

![image-20200911110704352](https://user-images.githubusercontent.com/58545240/92844438-d05b5a00-f420-11ea-8154-8b330530555e.png)

1,2,3이 연결될 때는 위와 같은 표로 표현이 된다.

1과 3은 부모가 다르기 때문에 1과 3이 연결되었는지 파악하기 힘들다. 따라서 **재귀함수**가 사용된다.

3인 부모인 2를 먼저 찾고, 2인 부모인 1을 찾아 결과적으로 3의 부모는 1이되는 것을 파악하는 것이다.

**Union**의 과정이 수행된 후에는 다음과 같은 표로 바뀌게 된다.

![image-20200911110828805](https://user-images.githubusercontent.com/58545240/92844456-d6e9d180-f420-11ea-8b72-6d6ca2dc68e9.png)

결국 1,2,3의 부모는 모두 1이기 때문에 이 세가지 노드는 모두 같은 그래프에 속한다는 것을 알 수 있다.

해당 경로를 바꿔주는 과정은 아래와 같은 그림으로 변하게 된다.

![image-20200911110902955](https://user-images.githubusercontent.com/58545240/92844470-db15ef00-f420-11ea-8c16-644d71962d64.png)

## 유니온파인드의 최적화

### -최악의 상황

![image-20200911112959528](https://user-images.githubusercontent.com/58545240/92856933-fdaf0480-f42e-11ea-9fe9-9b83690f09a3.png)

- **트리구조가 완전 비대칭인 경우**
- 연결 리스트 형태
- 트리의 높이가 최대가 된다
- 원소의 개수가 N일 때, 트리의 높이가 N-1이므로 union과 find(x)의 시간 복잡도가 모두 O(N)이 된다.
- 배열로 구현하는 것 보다 비효율적이다.

### - find 연산 최적화

![image-20200911113107274](https://user-images.githubusercontent.com/58545240/92856954-01db2200-f42f-11ea-9091-eaf36fca95ec.png)

- **경로 압축(Path Compression)**
- 시간 복잡도 : O(logN)

```java
// 초기화
int root[MAX_SIZE];
for(int i=0; i<MAX_SIZE; i++){
    root[i]= i;
}

// find(x) : 재귀 이용
int find(int x){
    if(root[x] == x)
        return x;
    else P
        // 경로 압축
        // find하면서 만난 모든 값의 부모 노드를 root로 만든다.
        return root[x] = find(root[x]);
}
```

### - union 연산 최적화

- **union-by-rank(union-by-height)**
- rank에 트리의 높이를 저장한다.
- 항상 높이가 더 낮은 트리를 높은 트리 밑에 넣는다.

```java
//초기화
int root[MAX_SIZE];
int rank[MAX_SIZE];	// 트리의 높이를 저장할 배열
for(int i=0; i<MAX_SIZE; i++){
    root[i] = i;
    rank[i] = 0;	// 트리의 높이 초기화
}

// find(x): 재귀이용
int find(int x){
    // 위와 동일
}

// union1(x, y) : union-by-rank 최적화
void union(int x, int y){
    int x = find(x);
    int y = find(y);
    
    // 두 값의 root가 같으면(이미 같은 트리) 합치지 않는다.
    if(x == y)
        return;
    
    // "union-by-rank 최적화"
    // 항상 높이가 더 낮은 트리를 높이가 높은 트리 밑에 넣는다. 즉 높이가 더 높은 쪽을 rank로 삼음
    if(rank[x] < rank[y]){
        root[x] = y;	// x의 root를 y로 변경
    } else {
        root[y] = x;	// y의 root를 x로 변경
        
        if(rank[x] == rank[y])
            rank[x] ++;	// 만약 높이가 같다면 합친 후 (x의 높이 + 1)
    }
}
```

**두 원소가 속한 트리의 전체 노드의 수를 구하는 경우**

```java
// union2(x, y): 두원소가 속한 트리의 전체 노드의 수 구하기
int nodeCount[MAX_SIZE];
for(int i=0; i<MAX_SIZE; i++){
    nodeCount[i] = i;
}

int union2(int x, int y) {
    int x = find(x);
    int y = find(y);
    
    // 두 값의 root가 같지 않으면
    if(x != y){
        root[y] = x;	// y의 root를 x로 변경
        nodeCount[x] += nodeCount[y];	// x의 node 수에 y의 node 수를 더한다.
        nodeCount[y] = 1;	// x에 붙은 y의 node 수는 1로 초기화
    }
    return nodeCount[x];	// 가장 root의 node 수 반환
}
```



## 코드

```java
public class UnionFind{
    public static int[] parent = new int[1000001];
    
    public static int find(int x){
        if(x == parent[x])
            return x;
        else
            return parent[x] = find(parent[x]);
    }
    
    public static void union(int x, int y){
        int x = find(x);
        int y = find(y);
        //같은 부모를 가지고 있지 않을 때
        if(x != y){
            //y가 x보다 크다는 것을 가정하면
            parent[y] = x;
            // 더 작은 값으로 넣어 줄 때 다음과 같이 표현
            /*
            if(x < y) parent[y] = x;
            else parent[x] = y;
            */
        }
    }
    
    //같은 부모 노드를 가지는지 확인
    public static boolean isSameParent(int x, int y){
        x = find(x);
        y = find(y);
        if(x == y)
            return true;
        else
            return false;
    }
    
    public static void main(String[] args){
        for(int i=1; i<=8; i++){
            parent[i] = i;
        }
        union(1,2);
        union(2,3);
        System.out.println("1과 3은 연결되어 있나요? -> "+isSameParent(1,3));
    }
}
```

## 유니온파인드 관련 문제

1. 전체 집합이 있을 때 구성원소들이 겹치지 않도록 **분할하는 데** 자주 사용된다.

   - **Kruskal MST 알고리즘**에서 새로 추가할 간선의 양끝 정점이 같은 집합에 속해 있는지(사이클 형성 여부 확인)에 대해 검사하는 경우

   - 초기에 {0}, {1}, {2}, ... {n}이 각각 n+1개의 집합을 이루고 있다. 여기에 합집합 연산과, 두 원소가 같은 집합에 포함되어 있는지를 확인하는 연산을 수행하는 경우

     [집합의 표현 - 백준 1717번](**[https://www.acmicpc.net/problem/](https://www.acmicpc.net/problem/1717)1717**)

   - 어떤 사이트의 친구 관계가 생긴 순서대로 주어졌을 때, 가입한 두 사람의 친구 네트워크에 몇 명이 있는지 구하는 프로그램을 작성하는 경우

     [친구 네트워크 - 백준 4195번](https://www.acmicpc.net/problem/4195)

그외

[바이러스 - 백준 2606번](https://www.acmicpc.net/problem/2606)

[섬 연결하기 - 프로그래머스 42861번](https://programmers.co.kr/learn/courses/30/lessons/42861)

## 참고

https://brenden.tistory.com/33

# **> 스패닝 트리(ST)**

---

> **그래프 내의 모든 정점을 포함하는 트리**

- **Spanning Tree = 신장 트리 = 스패닝 트리**
- Spanning Tree는 그래프의 최소 연결 부분 그래프이다.
  - 최소 연결 = 간선의 수가 가장 적다.
  - n개의 정점을 가지는 그래프의 최소 간선 수는 (n-1)개이고, (n-1)개의 간선으로 연결되어 있으면 필연적으로 트리 형태가 되고 이것이 바로 Spanning Tree가 된다.
- 즉, 그래프에서 일부 간선을 선택해서 만든 트리

## 스패닝 트리의 특징

![image-20200911140355155](https://user-images.githubusercontent.com/58545240/92866780-e2e28d00-f43a-11ea-90c1-646b51f53c81.png)

- DFS, BFS를 이용하여 그래프에서 신장 트리를 찾을 수 있다.
  - 탐색 도중에 사용된 간선만 모으면 만들 수 있다.
- 하나의 그래프에는 많은 신장 트리가 존재할 수 있다.
- Spanning Tree는 트리의 특수한 형태이므로 **모든 정점들이 연결**되어 있어야 하고 **사이클을 포함해서는 안된다.**
- 따라서 Spanning Tree는 그래프에 있는 **n개의 정점을 정확히 (n-1)개의 간선으로 연결**한다.

## 스패닝 트리의 사용 사례

*통신 네트워크 구축*

![image-20200911140530755](https://user-images.githubusercontent.com/58545240/92866800-e70eaa80-f43a-11ea-9a87-534613ba6c65.png)

- 예를 들어, 회사 내의 모든 전화기를 가장 적은 수의 케이블을 사용하여 연결하고자 하는 경우
- n개의 위치를 연결하는 통신 네트워크를 최소의 링크(간선)를 이용하여 구축하고자 하는 경우, 최소 링크의 수는 `(n-1)`개가 되고, 따라서 Spanning Tree가 가능해진다.

# **> 최소 신장 트리(MST)**

---

> **Minimum Spanning Tree**
>
> **Spanning Tree 중에서 사용된 간선들의 가중치 합이 최소인 트리**

- 각 간선의 가중치가 동일하지 않을 때 단순히 가장 적은 간선을 사용한다고 해서 최소 비용이 얻어지는 것은 아니다.
- MST는 간선에 가중치를 고려하여 최소 비용의 Spanning Tree를 선택하는 것이다.
- 즉, 네트워크(가중치를 간선에 할당한 그래프)에 있는 모든 정점들을 가장 적은 수의 간선과 비용으로 연결하는 것이다.

## MST의 특징

1. 간선의 가중치의 합이 최소여야 한다.
2. `n`개의 정점을 가지는 그래프에 대해 반드시 `(n-1)`개의 간선만을 사용해야 한다.
3. 사이클이 포함되어서는 안된다.

## MST의 사용사례

*통신망, 도로망, 유통망에서 길이, 구축비용, 전송시간 등을 최소로 구축하려는 경우*

- 도로건설
  - 도시들을 모두 연결하면서 도로의 길이가 최소가 되도록 하는 문제
- 전기회로
  - 단자들을 모두 연결하면서 전선의 길이가 가장 최소가 되도록 하는 문제
- 통신
  - 전화선의 길이가 최소가 되도록 전화 케이블 망을 구성하는 문제
- 배관
  - 파이프를 모두 연결하면서 파이프의 총 길이가 최소가 되도록 하는 문제

## MST의 구현방법

### 1. Kruskal MST 알고리즘

> **탐욕적인 방법(greedy method)**을 이용하여 네트워크(가중치를 간선에 할당한 그래프)의 모든 정점을 최소 비용으로 연결하는 최적해를 구하는 것.

- MST가

  1. 최소 비용의 간선으로 구성되고
  2. 사이클을 포함하지 않음의 조건에 근거하여

  - **각 단계에서 사이클을 이루지 않는 최소 비용 간선을 선택** 하는 것이다.

- 간선 선택을 기반으로 하는 알고리즘

- 이전단계에서 만들어진 신장트리와는 상관없이 무조건 최소 간선만을 선택

- *그래프 내에 적은 숫자의 간선만을 가지는 '희소 그래프'에서 사용하기 적합하다*



***과정***

1. 그래프의 간선들을 가중치의 오름차순으로 정렬
2. 정렬된 간선 리스트에서 순서대로 사이클을 형성하지 않는 간선을 선택
   1. 즉, 가장 낮은 가중치를 먼저 선택
   2. 사이클을 형성하는 간선을 제외
3. 해당 간선을 현재의 MST의 집합에 추가



***주의!***

- 다음 간선을 이미 선택된 간선들의 집합에 추가할 때 **사이클을 생성하는지를 체크해야한다.**
  - 새로운 간선이 이미 다른 경로에 의해 연결되어 있는 정점들을 연결할 때 사이클이 형성된다.
  - 즉, 추가할 새로운 간선의 양끝 정점이 같은 집합에 속해 있으면 사이클이 형성된다.
- 사이클 생성 여부를 확인하는 방법은
  - 추가하고자 하는 간선의 양끝 정점이 같은 집합에 속해있는지를 먼저 검사해야한다.( **union-find 알고리즘 이용!** )

### 2. Prim MST 알고리즘

> **시작 정점에서부터 출발하여 신장트리 집합을 단계적으로 확장 해나가는 방법**

- 정점 선택을 기반으로 하는 알고리즘
- 이전 단계에서 만들어진 신장 트리를 확장하는 방법
- *그래프 간선이 많이 존재하는 '밀집 그래프'에서 사용하기 적합하다*



***과정***

1. 시작 단계에서는 시작 정점만이 MST 집합에 포함된다.
2. 앞 단계에서 만들어진 MST집합에 인접한 정점들 중에서 최소 간선으로 연결된 정점을 선택하여 트리를 확장한다.
   1. 즉, 가장 낮은 가중치를 먼저 선택한다.
3. 위의 과정을 트리가 `(n-1)`개의 간선을 가질 때까지 반복한다.

## MST 관련 문제

- [최소 스패닝 트리 - 백준 1197번](https://www.acmicpc.net/problem/1197)
- [네트워크 연결 - 백준 1922번](https://www.acmicpc.net/problem/1922)



# **> 다익스트라 알고리즘**

---

이제부터 그래프에 대한 글만 엄청 쓸 겁니다. 한 11~12개 정도 예정되어 있네요.

그래프... 정말 어렵고, 답없고, 온갖 문제가 많기로 유명합니다.

그 중에서도 처음을 장식할 최단 경로 알고리즘은 그 종류부터 3개나 됩니다.

그 중 첫 번째 알고리즘인 **다익스트라 알고리즘**(Dijkstra's algorithm)에 대해서 알아보겠습니다.



이 알고리즘이 하는 일은 그래프의 어떤 정점 하나를 시작점으로 선택하고,

나머지 정점들로의 최단거리를 모두 구합니다. 시작점 자신이야 뭐 그냥 0입니다.

정점 개수가 V, 간선 개수가 E일 때 기본적인 최적화를 거치면 **O(ElogV)**의 시간복잡도를 갖습니다.

그래프는 무향이거나 유향인데 대체로 유향인 경우가 많고, 간선마다 이동거리가 존재합니다.

또한 모든 거리값이 음수가 아닐 때만 사용할 수 있습니다.

이 이동거리가 거리 대신 비용(cost)이라는 용어로 대체되고서 최소비용을 구하라고 할 수도 있는데 같은 표현입니다.

![image-20200913210309128](https://user-images.githubusercontent.com/58545240/93018057-26d6bd00-f608-11ea-8adc-4b680477e8ae.png)

이런 무향 그래프를 예로 들어 설명하겠습니다. 영문 위키 예제를 퍼온 겁니다.

0번 정점을 시작점으로 하여, 0번에서 다른 정점으로 가는 최단 경로를 다 구할 겁니다.



다익스트라 알고리즘은 이렇게 작동합니다.

**① 아직 방문하지 않은 정점들 중 거리가 가장 짧은 정점을 하나 선택해 방문한다.**

**② 해당 정점에서 인접하고 아직 방문하지 않은 정점들의 거리를 갱신한다.**

맨 처음에는 시작점으로의 거리만 0이고 나머지는 다 거리가 무한입니다.

정점 i, j 사이의 거리를 d, 거리 테이블을 dist라고 부르겠습니다.



![image-20200913210333216](https://user-images.githubusercontent.com/58545240/93018094-42da5e80-f608-11ea-9e1a-2e9bb5e76b20.png)

dist가 제일 작은 것이 시작점이므로(나머지는 다 무한), 시작점인 0번 정점을 방문하고 이런 일을 합니다.

0번에서 바로 갈 수 있는 인접한 정점은 1, 2, 5번 정점이고,

0번을 통해 k번 정점으로 가는 거리는 dist[0] + d[0][k]이고, 이게 만약 dist[k]보다 작다면 dist[k]가 갱신됩니다.

지금은 0번을 제외한 모든 정점으로의 dist 값이 무한대이므로 무조건 갱신됩니다.

![image-20200913210354291](https://user-images.githubusercontent.com/58545240/93018097-48d03f80-f608-11ea-8a45-bdb6f4dffca2.png)

그 다음, 아직 방문하지 않은 정점 중 dist가 제일 작은 곳이 1번이므로

1번 정점을 방문하여 인접한 2, 3번 정점의 거리 갱신을 시도합니다.

0번 정점 또한 인접하지만, 0번 정점은 이미 방문한 상태이므로 아무것도 하지 않습니다.

여기서 2번 정점의 경우는 거리가 갱신되지 않습니다. dist[2]가 이미 dist[1] + d[1][2]보다 작거나 같기 때문.



![image-20200913210413878](https://user-images.githubusercontent.com/58545240/93018104-52f23e00-f608-11ea-92ad-6b9f35a68c96.png)

아... 여기부터는 아래의 간선에 실수로 방향을 안 없애놨네요. 무시해주시기 바랍니다.

여튼 이번엔 dist[2]가 제일 작으므로 2번 정점을 방문하여 3, 5번 정점으로의 거리를 갱신합니다.

![image-20200913210433148](https://user-images.githubusercontent.com/58545240/93018106-57b6f200-f608-11ea-846a-609787978b87.png)

그 다음은 5번 정점을 방문합니다.

![image-20200913210449644](https://user-images.githubusercontent.com/58545240/93018114-64d3e100-f608-11ea-8bb0-925bb72fd246.png)

3, 4번 정점이 남았는데 둘의 dist가 같네요. 이럴 때는 아무거나 방문해도 됩니다.

3번 정점에서 4번 정점의 거리 갱신을 시도했으나 먹히지 않았습니다.

![image-20200913210505798](https://user-images.githubusercontent.com/58545240/93018117-6a312b80-f608-11ea-8783-12ba0856544c.png)

마지막으로 4번 정점만 남았을 때는 나머지 정점을 다 방문한 상태이므로 아무것도 하지 않습니다.



여기까지가 다익스트라 알고리즘 작동의 과정인데, 이게 끝나고 나면 각 dist 값이 0번 정점으로부터의 실제 최단 거리가 됩니다.

즉 매 루프에서 방문된 상태의 정점의 dist값은 이미 최단거리고, 앞으로 절대 안 바뀐다는 겁니다.



왜일까요? 만약 이렇게 했는데 최단거리가 구해지지 않는 경우도 있을까요?

아직 방문하지 않은 정점들 중 가장 dist 값이 작은 정점이 u고, 사실 dist[u]는 최단거리보다는 아직 크다고 해 봅시다. 이때 u를 방문하면 dist[u] 값은 최단거리가 아니게 되겠죠.

또한 dist[u]가 아직 최단거리가 아니라는 말은, 다른 임의의 정점 v를 거치는 경로를 통해 최단거리로 갱신될 수 있다는 말입니다. 즉 dist[u] > dist[v] + d[v][u]인 어떤 정점 v가 존재할 겁니다.

그런데 **아직 방문하지 않은 정점 중에서** dist 값이 제일 작은 게 u라고 했으니까 v는 방문한 상태일 겁니다.

그런데 v를 방문했을 때 dist[u]는 이미 dist[v] + d[v][u]로 갱신되고 말았을 겁니다.

따라서 저렇게 될 수 있는 경우는... 없습니다..

런데 위 증명에서 중요하게 작용하는 성질이 바로 **d 값이 항상 0 이상**이라는 사실입니다.

만약 d 값이 음수인 경우도 있다면 이 과정이 성립하지 않아서, 진짜로 최단 경로를 못 구할 수도 있습니다.

이때는 조금 더 느리지만 전용 알고리즘인 **벨만 포드 알고리즘**을 써야 하고 이건 다음 글에서 쓸게요.



그럼 이제 이걸 구현해야 합니다.

가장 문제인 부분은 아직 방문하지 않은 정점들 중에서 dist 값이 제일 작은 정점을 찾아 방문하는 부분.

이걸 그냥 dist 값들을 다 비교해서 찾다가는 매번 O(V)고, 루프는 V-1번 실행되니까 O(V^2)의 시간복잡도가 발생하고 말아서 너무 큽니다.

따라서 이걸 영리하게 찾아야 하는데요, 여기에 사용되는 게 바로 **우선순위 큐**입니다!



최소 힙을 하나 마련합니다. 그리고 정점 u를 방문해서 인접한 정점 v의 거리를 갱신할 때마다 최소 힙에 **(dist[v], v) 쌍**을 넣습니다.

pair는 첫 번째 인자의 대소 비교를 먼저 하므로, dist 값이 작으면 작을수록 우선순위 큐에서 먼저 나오겠죠.

dist 값이 제일 작은 걸 뽑아서, 그 두 번째 인자인 정점 번호를 사용하면 됩니다.

또한 v를 방문하기 전에 값이 여러 번 갱신될 수도 있고, 그럼 서로 다른 (d, v) 값들이 우선순위 큐 안에 존재할 수 있는데 이땐 쿨하게 그냥 제일 작은 d 값 하나만 뽑아서 쓰면 되고 우선순위 큐가 이걸 자동으로 해결해 줍니다.

다만 아직 우선순위 큐에 남아있는 v 정점에 관한 쌍은 어떻게 하느냐? 이건 그냥 놔뒀다가 추후 top에서 나타나면 무시합니다. 즉, 꺼낸 정점이 이미 방문한 곳이면 무시하고 다음 top을 꺼내면 됩니다.



이렇게 하면, 한 정점에 최대한 많은 갱신이 이루어진다고 해도 넉넉잡아 V^2번 갱신이 이루어져서 PQ에 한 순간에 V^2개의 정보가 들어있다고 해도

원래 연산에 O(logN)의 시간이 드는 우선순위 큐 입장에서는 O(log(V^2)) = O(2logV) = O(logV).

즉, 최대 O(E)번 우선순위 큐에서 top을 꺼내는 연산 O(logV),

루프 전체를 통틀어서 인접한 정점으로의 거리를 갱신하는 부분도 최대 O(E)번 이루어질 것이므로

총 시간복잡도 합은 **O(ElogV)**입니다.

아, 여기서 O(E)라는 시간복잡도 또한 그래프를 **인접 리스트**로 구현했을 때의 말입니다.

인접행렬로 구현했다면 매번 인접한 정점을 찾아야 하니 루프마다 O(V)의 시간이 소요되어서 총합 O(V^2)가 될 것입니다...



한 가지 예외처리를 해야 하는 경우가 있습니다.

그래프 자체가 연결 그래프가 아니거나, 아니면 유향 그래프에서 시작점에서 어떤 정점으로 못 갈 때는 루프를 꼭 V-1번 돌지 못합니다. 중간에 우선순위 큐가 텅텅 비어버리게 되고 이때는 그냥 나와야 합니다.

아직 방문하지 못한 정점들의 경우는 거리가 무한으로 남아 있고, 이는 시작점에서 그 정점으로 갈 수 없다는 뜻이겠지요.



## 다익스트라 관련 문제

**1753번: 최단경로**

위에서 설명한 문제입니다.



**1916번: 최소비용 구하기**

역시 기본적인 다익스트라 알고리즘 연습 문제이며,

시작점과 도착점이 정해지는 데다가 항상 이동 가능해서 오히려 더 쉬울지도?

간선이 최대 10만 개고 각 비용이 최대 10만이어서 10만*10만은 int 범위를 넘어가지만,

도시 개수가 최대 1,000인지라 가능한 최단거리는 100,000*999라서 int 범위 안에 있습니다.



**1504번: 특정한 최단 경로**

반드시 거쳐야 하는 정점이 a, b일 때 가능한 경로는 1->a->b->N, 1->b->a->N 두 가지이고 둘 중 더 작은 경로가 답입니다.

1->a->b->N으로 가는 최단 경로는 그냥 1->a, a->b, b->N 최단 경로 3개를 더하면 되고, 이 중 하나라도 경로가 없는 경우 전체 경로가 존재하지 않습니다.

따라서 1, a, b 세 개의 정점을 시작점으로 하여 각각 다익스트라 알고리즘을 돌려 다른 모든 정점으로의 거리 정보를 얻고, 이들을 조합해서 문제를 풀면 될 것입니다.



**4485번: Obstacle Course**

이번엔 간선이 아니라 각 칸에 비용이 있네요.

이때는 인접한 두 칸 u, v가 있을 때 u에서 v로 가는 비용을 cost[v]로 두면 됩니다.

그러면 어떤 방을 여러 번 방문하면 cost가 중첩되어서 쌓이는 게 아니겠느냐...? 사실 한 방을 두 번 이상 방문한 시점에서 그건 이미 최단경로가 아니라서 신경쓰실 필요 없습니다.

시작점 S의 dist 값이 0이 아니라 cost[S]인 상태로 시작하여 dist[E]를 구하거나, 아니면 마지막에 dist[E]에 cost[S]를 더해서 출력하면 됩니다.



**1238번: 파티**

1~N번을 각각 시작점으로 해서 다익스트라 알고리즘을 한 번씩 돌려야 합니다.

각각 X번 마을로의 최단경로를 구해야 하고, X번 마을에서는 나머지 다른 마을로의 모든 최단경로를 구해야 하죠.

이 모든 정보를 조합해서 가장 긴 왕복거리 값을 찾으면 됩니다.

X번이 아닌 다른 마을에서 다익스트라 알고리즘을 시도할 때는 **X번 마을을 방문하면 바로 알고리즘을 종료**해버리는 게 시간 절약에 도움이 됩니다.

이론상의 시간복잡도는 **O(N^2logN + NM)**이네요.



**1261번: 알고스팟 (★)**

Obstacle Course 문제와 똑같이 풀면 됩니다.

벽인 방으로 이동하려면 벽을 뚫어야 하고 이건 cost 1이 들어감을 의미하죠.

뚫어야 하는 최소 벽 개수가 즉 최소 비용이 되겠습니다.



**10473번: 인간 대포 (★)**

기하 문제인데요. 시작점, 목적지, 그 외 모든 대포를 정점으로 두고

각 정점 사이의 최단 이동 **시간**을 죄다 구하는 것을 시작으로 다익스트라 알고리즘을 사용합니다.

시작점에서는 도착점이나 다른 모든 대포로 그냥 걸어가는 직선 거리를 구해서 시간을 구하고,

각 대포에서는 다른 대포나 도착점으로 가는 최단시간을 구해야 하는데, 일단 대포로 갔다는 건 발사는 했다는 말이므로 착지한 후 그대로 걸어가야 하는데 경우에 따라 발사하면서 목적지를 지나쳐 갈 수도 있는 등 여러 가지 케이스를 다 처리해 주셔야 합니다.



**2211번: 네트워크 복구 (★)**

prev 배열의 저력을 보여줄 때입니다.

1번 정점이 슈퍼컴퓨터이고, 간선들 중 일부만 골라서 모든 정점을 잇게 하되, 최소 개수의 간선만 고르라고 하네요.

이때는 정점 개수가 N인 그래프가 연결 그래프일 때 반드시 **N-1개의 간선**만 골라서 정점이 N개인 트리를 만들어서 조건을 만족시킬 수 있습니다. 이걸 **신장 트리**(spanning tree)라고 하는데 바로 다음 글에서 자세히 다루도록 하죠.



그러나 다른 조건이 있는데, 복구한 간선들만을 통해 도달할 수 있는, 1번 정점으로부터 다른 정점까지의 최단 경로가 원래와 같아야 한다네요(줄어들 수는 없습니다).

이때는 놀랍게도, 1번을 시작점으로 하여 다익스트라 알고리즘을 돌린 후 1번 정점을 제외한 각 정점 u에 대해 prev[v] = u라고 할 때, 간선 (u, v)들만 모아서 복구하면 문제가 해결됩니다.

특정 정점에서 prev 배열만 역으로 계속 따라가다 보면 시작점에서 도착점으로 가는 최단 경로를 역순으로 얻을 수 있다는 점에서 착안한 것입니다.



**16681번: 등산** 

각 마을마다, 1번 마을로부터의 거리와 N번 마을로부터의 거리를 구하면 됩니다. 1번과 N번을 각각 시작점으로 하여 다익스트라를 2번 돌리면 해결됩니다. 물론 높이가 높아지는 정점으로만 이동하게 해야겠죠.



**5719번: 거의 최단 경로 (★)**

어렵습니다. 한 번 최단 경로가 얼마인지 구한 후, 최단 경로로 가능한 모든 경로의 간선을 다 없애는 짓을 해야 합니다.

일단 시작점 S와 도착점 E가 있고 각 정점의 시작점으로부터의 거리 dist 값들이 있을 때, dist 값들을 다 구하고 나서 이런 행동을 해서 최단경로의 간선을 모두 체크할 수 있습니다.



① 큐에 시작점을 넣고 시작합니다.

② 큐의 맨 위에 있는 정점을 꺼내서 u라 하면, 인접한 정점 v 중 dist[u]+d[u][v] = dist[v]인 모든 v를 찾아 큐에 넣고, 그러한 v에 대해 간선 (u, v)를 가능한 최단 경로에 속한다고 판별합니다.



일종의 **BFS** 형태입니다. 이렇게 경로를 다 구하고 삭제하는 과정을 거친 후 한 번 더 다익스트라 알고리즘을 돌려야 하네요.

처음부터 S에서 E로 갈 수 없거나, 간선 삭제 후 갈 수 없게 되거나 하는 경우를 잘 처리해 주셔야 합니다.



**15422번: Bumped!**

BFS 글에서 응용 문제들을 유심히 보셨다면, 비슷하게 응용해서 이런 문제도 풀 수 있습니다.

이 문제의 경우 그래프가 주어짐과 동시에, 최대 하나만 골라서 공짜로 이용할 수 있는 비행권들이 있습니다.

벽 부수고 이동하기 문제와 비슷하게, 제공된 비행권들 중 하나를 사용했느냐 아니냐로 각 정점을 이등분해서 거기에 대해 다익스트라 알고리즘을 돌리면 풀 수 있습니다. 비행권은 양방향 간선이 아님에 주의하세요.



**1162번: 도로포장 (★)**

K가 최대 20밖에 안 돼서 이런 걸 시도할 수 있습니다.

정점 번호와 앞으로 더 포장할 수 있는 도로 개수를 갖고 있는 새로운 형태의 정점 (u, k)들을 생각해 봅시다. 그렇다면 시작점은 (1, K)이며 답은 (N, 0) ~ (N, K) 중 최솟값일 겁니다.

그냥 있던 도로를 따라간다면 (u, k)에서 (v, k)로 이동하게 되고 이때의 거리는 그냥 d[u][v]입니다.

그러나 k > 0일 때는 도로 하나를 포장할 수 있고, (u, k)에서 (v, k-1)로 cost 0을 들여서 이동할 수 있습니다.

이런 식으로 그래프를 모델링해서 다익스트라 알고리즘을 적용하면 됩니다.



**10217번: KCM Travel (★)**

도로포장 문제와 상당히 유사합니다.

이번엔 금액이라는 또다른 제한이 주어지는데, 공항 수 N이 최대 100이고 금액도 최대 10,000이라서

각 정점에다 현재 가지고 있는 돈의 정보를 묶어 (n, m) 형태의 정점을 새로 모델링할 수 있고, 시작점 (1, M)에서 도착점 (N, ?)으로 가는 최단시간이 되겠네요. 도착점에서 가지고 있을 돈의 액수는 아무래도 좋고 일단 도착만 가능하면 됩니다.

물론, 이번에도 돈이 부족하면 해당 간선은 못 지나갑니다. (u, v) 방향 간선이(u->v) 시간 d, 비용 c가 든다면 (u, 15)에서는 (v, 15-c) 정점으로 시간 d를 들여서 갈 수 있는 것이고, 비용 c만큼도 부족하다면 아예 갈 수 없습니다.

총 정점 개수가 O(NM)으로 약 백만 개지만 시간제한도 10초나 되어서 다익스트라 알고리즘으로 무리없이 풀 수 있습니다.

그리고 이 문제의 경우 항상 어떤 간선을 지날 때마다 최소 1의 비용이 소모되어서 **DP**로도 푸는 게 가능합니다.



# **> 벨만포드 알고리즘**

---

이어서 소개해드릴 것은 또다른 최단경로 알고리즘입니다.

**벨만 포드 알고리즘**(Bellman-Ford algorithm)인데요, 알고리즘을 개발한 두 학자의 성을 따서 붙인 이름이라고 합니다.

동시에 독자적으로 알고리즘을 개발했던 또다른 학자의 이름까지 붙여서 벨만 포드 무어 알고리즘이라 명명할 때도 있다는군요.



다익스트라 알고리즘과 마찬가지로 시작점을 정해 주면 다른 모든 정점으로의 최단 경로를 구하는데,

다익스트라 알고리즘보다는 시간이 오래 걸려서 **O(VE)**의 시간이 걸리지만

이 알고리즘은 **간선 cost가 음수일 때**도 사용할 수가 있습니다!!

아니 도대체 거리가 음수라니 무슨 소리냐, 뭐 그런 거 다 떼어놓고 그냥 최단거리가 정말 작으면 작을수록 좋다고 친다면, 설령 그게 음수가 되더라도 정확히 구해버린다는 거죠.

그나마 말이 되는 예시를 들자면 거리 대신 이동시간이라 생각하고, 타임머신을 타서 과거로 간다고 생각하는 겁니다. 이때는 시간을 역행했으므로 소요시간이 음수가 될 겁니다.

![image-20200913211046788](https://user-images.githubusercontent.com/58545240/93018125-761ced80-f608-11ea-9b05-918b5401a6e5.png)

예를 들어 이런 그래프가 있다고 합시다. 시작점이 0번 정점인데, 2번 정점까지의 최단거리를 구하려고 합니다.

이제부터는 간선 비용 자체가 음수일 수도 있어서, 그냥 최단거리 자체의 정의를 최소의 cost(음수가 되어도 상관없음)를 들여서 오는 경로의 cost 합이라 보는 게 좋겠죠.

여튼 2번 정점까지 가는 최단거리는 0->1->2를 거쳐서 12+(-7)=5여야 합니다.

그러나 다익스트라 알고리즘은 1, 2번 정점 중에서 dist[1]=12 > dist[2]=8이라 해서 2번 정점을 방문해버리게 되고, 실제 2번 정점까지의 최단 경로는 8보다 작기 때문에 이는 잘못되었으며

결국 다익스트라 알고리즘으로는 음의 간선이 존재하는 그래프에서 최단경로를 제대로 못 구할 수 있다는 사실을 보여줍니다.



따라서 벨만 포드 알고리즘은 2중 for문을 통해 철저하게 가능한 모든 경우를 다 체크하기로 합니다.

일단, 최단 경로라는 말은 **같은 정점을 두 번 지날 일이 없기 때문에** 가능한 최단 경로의 간선 개수는 많아봐야 **V-1**개입니다.

(뭔가 이상한 점을 느끼셨을지도 모릅니다. 그건 있다가 설명하겠습니다.)

따라서 루프를 V-1번 돌리는데, k번째 루프에서는 시작점으로부터 각 정점으로 k개의 간선을 거쳐서 도달할 수 있는 최단경로를 다 갱신해주자는 게 기본 아이디어입니다.

k-1번째 루프까지는 최대 k-1개 간선을 거치는 최단경로를 다 구해놓았다고 믿고(???) k번째 루프에서 그 정보들을 사용해 또다른 최단경로를 구해보는 것이죠.

## - BOJ[11657]:타임머신

https://www.acmicpc.net/problem/11657

이 문제를 벨만 포드 알고리즘으로 풀어버리려고 하는데요.

```c++
#include <cstdio>
#include <vector>
#include <utility>
#include <algorithm>
using namespace std;
typedef pair<int, int> P;
const long long INF = 1e18; // 절대 나올 수 없는 경로값
 
int main(){
    int N, M;
    long long dist[500];
    scanf("%d %d", &N, &M);
    vector<P> adj[500];
    for(int i=0; i<M; i++){
        int A, B, C;
        scanf("%d %d %d", &A, &B, &C);
        adj[A-1].push_back(P(B-1, C));
    }
    fill(dist, dist+N, INF);
    dist[0] = 0;
    for(int i=0; i<N-1; i++){ // (N-1)번의 루프
        for(int j=0; j<N; j++){
            // N-1번의 루프에 걸쳐 각 정점이 i+1개 정점을 거쳐오는 최단경로 갱신
            for(auto &p: adj[j]){
                int next = p.first, d = p.second;
                if(dist[j] != INF && dist[next] > dist[j] + d){
                    dist[next] = dist[j] + d;
                }
            }
        }
    }
    for(int i=1; i<N; i++)
        printf("%lld\n", dist[i]!=INF ? dist[i] : -1);
}
```


일단 코드는 이렇습니다. 다익스트라 알고리즘과 큰 구조가 다른데요.

일단 말씀드린 대로 V-1번의 루프를 돕니다. 이 문제에서는 V = N이죠.

그리고 안쪽의 구조는 사람마다 판이하게 다를 수 있는데, 다 하는 건 똑같습니다.

**존재하는 모든 간선을 돌아보면서** 이 간선을 통할 수도 있는 최단경로들의 거리를 갱신하는 것.



이때, **음의 간선이 존재하기 때문에** 간선 (u, v)를 볼 때 먼저 dist[u]가 아직 INF인지 확인을 해야 합니다.

구현에 따라서 둘 다 시작점에서 도달 불가능한 정점 u, v가 존재하고 (u, v) 가중치가 음수일 때

dist[u] = INF, dist[v] = INF-cost 꼴이 나올 수도 있고, 이러면 골치 아파집니다.

![image-20200913211244972](https://user-images.githubusercontent.com/58545240/93018138-8f259e80-f608-11ea-8c0b-952436a284c4.png)

가장 간단한 그래프를 하나 예로 들어봅시다. u가 시작점이고 처음엔 이 상태로 시작하죠.

![image-20200913211321205](https://user-images.githubusercontent.com/58545240/93018139-9056cb80-f608-11ea-9273-a6b17f5d95a0.png)

첫 번째 루프가 돌기 전에는 dist[v] = INF이기 때문에 간선 (v, w)는 의미가 없습니다.

의미가 있는 것은 dist[u] ≠ INF인 u이고, u에서 시작한 간선들이 인접한 정점의 dist를 갱신해주죠.



사실, **방문 순서에 따라 우연히도** (u, v)를 먼저 방문하고 dist[v]를 갱신하고 나서 (v, w)를 방문하면 한 번에 dist[w]까지 구해질 것이지만,

그 적절한 방문 순서를 알 방도가 없죠. 모르니까 우린 무식하게 가능한 경우를 다 따져보고 있는 것이구요.

따라서 최악의 사태를 대비하여 루프를 V-1번 돌리는 것이고, V-1번의 루프를 돌리면 아무리 운 나쁘게 갱신이 지연되어도 반드시 dist 값들이 모두 최단 거리를 담고 있게 됩니다.

![image-20200913211338679](https://user-images.githubusercontent.com/58545240/93018140-90ef6200-f608-11ea-9dc2-a8b4ec037b1b.png)

그 다음 루프에 제일 먼 정점인 w의 거리도 비로소 구해지게 됩니다.

이때, 정점이 3개고 루프 2개로 모든 게 끝났죠.

![image-20200913211354113](https://user-images.githubusercontent.com/58545240/93018141-92b92580-f608-11ea-9e72-3af3b6536256.png)

이번엔 다른 경우를 살펴볼 겁니다.

전체 그래프의 일부만 살펴볼 건데, 이런 경우도 존재할 수 있습니다.

v, w가 어쩌다 보니 시작점과 좀 가까워서 미리 저런 dist 값을 갖고 있고,

뒤늦게 정점 u의 dist 값이 갱신되어서 이런 형태를 마주할 수 있는데요.

지금 보면 dist[u] = 2기 때문에 정점 u를 거쳐가면 **dist[v]가 갱신됩니다.**

dist[v]가 갱신된다면, 그 뒤에 계단식으로 dist[w]까지 갱신되어야 할 겁니다.

![image-20200913211410831](https://user-images.githubusercontent.com/58545240/93018166-b41a1180-f608-11ea-8427-f5646579fdee.png)

그래서 이번 루프에서 먼저 dist[v]가 갱신됩니다.

아직 dist[w]는 갱신되지 않**을 수도 있**습니다.

![image-20200913211426138](https://user-images.githubusercontent.com/58545240/93018167-b4b2a800-f608-11ea-852e-e1d4a29f5e80.png)

그러나 다음 번 루프에서는 dist[w] 역시 반드시 갱신될 수밖에 없습니다.

이때, 아직 루프가 많이 남았다면 동시에 dist[u]가 더 줄어들 수도 있습니다.

그럼 뭐, 똑같이 연쇄적으로 계속 dist[v], dist[w]도 줄어들고... 그런 겁니다.

그런데, 음의 가중치가 있는 그래프에서 최단경로를 구할 때 항상 염두에 두어야 하는 것이 있습니다.

![image-20200913211446585](https://user-images.githubusercontent.com/58545240/93018168-b54b3e80-f608-11ea-9874-5ffe207e4e39.png)


이 그래프에서, 0번 정점에서 4번 정점으로 가는 최단거리가 얼마라고 생각하시나요?

저 빨간색 정점들을 잘 보세요. 일단 싸이클이긴 한데,

평소엔, 아니 지금까지는 최단거리는 같은 정점을 두 번 이상 지나지 않는다고 철석같이 믿고 살아왔건만,

저 싸이클을 보세요. 1->2->3->1을 순회하면 오히려 처음 1번 정점을 방문했을 때보다 **시간이 줄어듭니다!!!!**

3+(-4)+(-1)=(-2)만큼 시간이 역행해버리는 거죠.

문제는 이게 싸이클이라, 이 싸이클을 계속해서 돌면 시간이 언제까지고 줄어들 수가 있습니다.

게다가 이러한 싸이클에서 지금 4번 정점으로 갈 수가 있기 때문에, dist[4]는... 그렇습니다. **-∞**가 됩니다...

빨간색 싸이클 안에 속해있는 놈들도 말할 것이 없이 다 -∞입니다.

시작점인 0번 정점만이... 싸이클에서 도달할 수 없으므로 최단거리가 실수 범위에서 정해지게 됩니다.



이렇게 가중치 합이 0보다 작은 싸이클을 **음수 싸이클** 혹은 **음의 싸이클**(negative cycle)이라고 하며, 벨만 포드 관련 문제에서 반드시 등장하는 요소입니다.

다행히도 이 문제에서는 음의 싸이클이 하나라도 존재하면 그냥 다 필요없고 "-1" 하나만 출력하라고 명시해 주었으므로, 그냥 그걸 찾기만 하면 되는데요.

그럼 어떻게 찾을까요? 우리가 V-1번만 루프를 돌았고 이 이상 루프를 돌아봐야 최단거리들이 갱신되지 않으리라고 했죠.

그러나 만약 음의 싸이클이 존재한다면, **그 이후에 루프를 돌면 최단거리가 갱신되는 일이 발생합니다.**

싸이클에 속하는 정점들부터, 그 싸이클의 인접한 정점들로까지.

따라서 음의 싸이클의 존재여부만 판단한다면 맨 마지막에 확인차 루프를 한 번 더 돌아서 최단거리가 갱신되는 일이 있는지 보면 됩니다.

```c++
#include <cstdio>
#include <vector>
#include <utility>
#include <algorithm>
using namespace std;
typedef pair<int, int> P;
const long long INF = 1e18; // 절대 나올 수 없는 경로값
 
int main(){
    int N, M;
    long long dist[500];
    scanf("%d %d", &N, &M);
    vector<P> adj[500];
    for(int i=0; i<M; i++){
        int A, B, C;
        scanf("%d %d %d", &A, &B, &C);
        adj[A-1].push_back(P(B-1, C));
    }
    bool minusCycle = false;
    fill(dist, dist+N, INF);
    dist[0] = 0;
    for(int i=0; i<N; i++){ // (N-1) + 1번의 루프. 마지막은 음의 싸이클 존재 여부 확인용
        for(int j=0; j<N; j++){
            // N-1번의 루프에 걸쳐 각 정점이 i+1개 정점을 거쳐오는 최단경로 갱신
            for(auto &p: adj[j]){
                int next = p.first, d = p.second;
                if(dist[j] != INF && dist[next] > dist[j] + d){
                    dist[next] = dist[j] + d;
                    // N번째 루프에 값이 갱신되면 음의 싸이클이 존재한다.
                    if(i == N-1) minusCycle = true;
                }
            }
        }
    }
    if(minusCycle) puts("-1");
    else{
        for(int i=1; i<N; i++)
            printf("%lld\n", dist[i]!=INF ? dist[i] : -1);
    }
}
```

아아아아주 조금 달라졌습니다. 일단 루프 도는 횟수가 한 번 늘었고,

마지막 루프에 뭔가 갱신되면 minusCycle이란 flag 변수를 set하여 음의 싸이클이 존재함을 판정합니다.



여튼, 이렇게 큰 루프가 V번이고 안쪽에서 하는 일은 형태는 다양할지언정 동일하게 모든 간선을 순회하는 것이므로 총 시간복잡도는 **O(VE)**가 됩니다.



여기서 상당한 맹점이 있는데, 무한 루프가 없을 때 가능한 "최단 경로"의 최댓값은 (정점 수 - 1) * (최대 거리값)이라 4byte 정수형 값의 범위 안에 들어오지만, **이 문제에서는 안전하게 8byte 정수형 값을 사용해야 합니다.**

왜냐면 모든 간선이 절댓값 최대인 음의 가중치(이 문제에서는 -10000)를 가지고 있다면, N번의 루프 안에 계산 중간값의 절댓값이 4byte 정수형 값을 넘어가버릴 수 있게 됩니다.



다음과 같은 그래프를 생각해 봅시다. 정점이 1부터 N까지 있고, 간선도 N개 존재하는데 1->2, 2->3, ... -> (N-1)->N, N->1 을 이어주며, 각각의 비용이 -C(C > 0)라고 하겠습니다.

그렇다면 위 코드의 경우 첫 번째 루프에서 쭉쭉쭉 따라와서 dist[N-1] = -C*(N-1)이 계산되고, 이어서 dist[0] = -C*N 이 됩니다.

다음 루프에서는 최종적으로 dist[0] = -2*C*N이 됩니다.

그 다음 루프에서는 최종적으로 dist[0] = -3*C*N이 됩니다.

이 과정을 쭉 따라오면 마지막 루프에서 dist[0] = -C*N^2가 되는데요, 이 값에 문제의 최대 범위 값을 모두 투입해 보면 절댓값이 21억을 넘어가버리고 맙니다.

즉 양의 값들이 아니라 반대쪽에서 오버플로우가 일어날 가능성이 존재한다는 것입니다. 음의 비용이 있는 그래프 최단 경로 문제에서 항상 신경써야 할 어려운 점 같네요...







벨만 포드 알고리즘은 나머지 2개, 다익스트라와 플로이드에 비해 실제로 보기가 조금 어려운 유형에 속합니다.

그러나 나왔다 하면 항상 타임머신이나 블랙홀 등 과거로 가는 행동과 연관이 많습니다.

사실 그게 아니고서야 우리에게 뜬금없이 "봐봐 이 경로를 거치면 음수의 거리다."라고 하는것도 무리지만요...



또한 벨만 포드 알고리즘의 변형으로 시간복잡도는 그대로지만 실전에서 더 빠르게 돌아간다고 하는 **SPFA**(shortest path faster algorithm)이라는 게 있고, 다익스트라와 비슷한 코드인데 우선순위 큐가 아닌 큐를 사용한다는 점이 다릅니다.

물론 음의 가중치가 있는 그래프에 사용 가능하며, 훗날 MCMF 문제를 풀 때 애용되는 알고리즘입니다.

우선순위 큐(->다익스트라)나 유니온 파인드(->크루스칼)가 그러했듯이, 벨만 포드만 쓰는 문제보다도 MCMF 때문에 필요한 문제가 압도적으로 많습니다.

## 벨만포드 관련 문제

**11657번: 타임머신**

위에서 설명한 문제입니다.



**1738번: 골목길**

이 문제는 한때 도대체 출처와 정체와 지문의 뜻과 데이터의 상태 중 알 수 있는 게 한 개도 없는 정체불명의 정답률 0% 저주받은 문제였으나, 언젠가 정상적인 문제로 리메이크되었습니다.

타임머신 문제와는 좀 다르게, 음의 싸이클이 있기만 하면 끝이 아니라, 그 음의 싸이클에서 도착점으로 도달 가능해야 답이 -1입니다. 역방향 간선 리스트를 만들고 도착점으로부터 BFS를 해서 각 정점이 도착점으로 도달 가능한가 파악해 놓는 전처리가 가능합니다. 물론, 그냥 시작점에서 도착점에 도달 불가능해도 답이 -1입니다.



**1865번: 웜홀 (★)**

문제 자체는 상당히 간단합니다. 시작점조차 주어지지 않고, 그냥 N개 정점이 있는데 이 중 아무거나 시작점을 자신으로 했을때 자신으로 돌아오는 최단거리가 0보다 작은 경우가 하나라도 있냐고 물어보는데, 이 말을 잘 풀이해 보면 **음의 싸이클이 존재하냐**는 겁니다.

음의 싸이클이 시작점과 다른 먼 곳에 존재하고 음의 싸이클에서 시작점으로 못 돌아올 수도 있겠으나, 그때는 그냥 음의 싸이클 안의 정점들이 이미 문제에서 찾는 정점이기 때문에 이미 YES.



다만 이번에는 그래프를 이루는 **컴포넌트가 여러 개일 수도 있다**는 점을 조심하셔야 하고, 각 컴포넌트를 각 그래프로 취급하여 일일이 벨만 포드를 돌려보는 수밖에 없습니다.

물론 시간 초과의 위험이 있으니 너무 무식하게 짜지는 마시고,

상위의 visited 배열을 준비해서 방문 안 한 정점이 나타나면 그 정점을 시작점으로 하여 벨만 포드를 한 번씩 돌려주면 그 컴포넌트 안에 존재하는 음의 싸이클은 찾을 수 있을 겁니다.

이렇게 모든 정점을 순회하시면 됩니다.



**10360번: The Mountain of Gold?**

시작점의 과거로 돌아갈 수 있는지를 묻는 문제입니다.

N번째 루프에서 시작점으로부터의 거리가 확실히 작아지는 정점들 중 시작점으로 가는 길이 있는 정점이 있다면 가능합니다. 시작점이 그 음의 싸이클에 포함되더라도 이 성질은 성립합니다.



**1219번: 오민식의 고민 (★)**



정점을 지날 때마다 돈을 벌어들이는데, 돈을 벌어들이는 것은 소비하는 것과 반대되므로 음의 가중치로 부여합니다. 마침 문제에서 구하라는 것도 돈의 최댓값인데, 소지금 자체를 음수로 본다면 최소의 음수가 되겠죠.

저번에 정점에 가중치가 있는 문제를 풀었을 때처럼, 그냥 정점을 방문할 때마다 그 정점의 가중치까지 cost에 넣어주면 됩니다. 맨 처음엔 dist[S]는 -(S에서 벌 수 있는 돈)으로 시작합니다.



단, 음의 싸이클이 존재는 하더라도 도착 도시로 못 가는 경우도 존재할 수 있습니다. 따라서 음의 싸이클 안에 속해있다고 판정되는 정점이 나타날 경우, 꼭 거기서 도착점으로 도달 가능한지도 체크해 주어야 Gee 여부를 정확히 판정할 수 있습니다.

또한 결과인 최단거리는 int 범위 안이지만 도중의 연산 과정에서 이 한도를 벗어날 수 있기에 long long형 배열을 사용하셔야 합니다.

# **> 플로이드 와샬 알고리즘**

> **Floyd-Warshall algorithm**
>
> **앞의 두 최단거리 알고리즘과는 다르게 정점 V개가 있고 거리가 다 주어져 있을 때, 단 한번의 시행으로 모든 정점 쌍 사이의 거리를 다 구해낸다.**

코드는 굉장히 짧은데, 아주 전형적인 3중 for문의 형태를 하고 있고 **O(V^3)**입니다.

음의 가중치가 있는 간선 그래프에서도 제대로 동작합니다.

## - BOJ[11404] : 플로이드

https://www.acmicpc.net/problem/11404

이 문제를 풀 겁니다. 아니 제목부터 대놓고 플로이드입니다. 그러므로 플로이드를 씁시다.

각 정점 u, v 쌍에 대해 u에서 v로 가는 최단 경로를 한 번에 다 구할 것이고, 이를 위해 먼저 2차원 배열 dist를 준비합니다.

초기에는 자기 자신으로 가는 dist[i][i] 꼴은 다 0이고, 나머지는 ∞으로 설정해놓고 시작합니다.

이때, `dist[i][i]=0`이라는 것은 자기 자신으로 이동이 가능하다는 의미인데, 문제에 따라 기본적으로 이게 안 될 수도 있고 그때는 `dist[i][i]도 ∞`로 초기화합니다.

그리고 간선 정보를 받아서 u->v로 가는 거리가 w라면 `dist[u][v] = w`로 갱신합니다.

혹시라도 똑같은 u, v 쌍에 대해 서로 다른 w가 두 번 이상 들어올 수 있는데 이때는 그 중 가장 작은 것으로 갱신해야 합니다.

여기까지가 전처리에 해당하는 그래프 모델링이고, 이제 이 dist 배열만을 갖고 플로이드 알고리즘을 적용할 겁니다.



플로이드는 최단경로를 **DP** 형태의 문제로 정의하고 풀어냅니다.

**shortestPath(i, j, k)**라는 문제는 i번 정점에서 j번 정점까지, 1~k번 정점만 사용할 때의 최단 거리를 구하라는 의미입니다.

k단계 문제를 풀려면 k-1단계의 정보가 필요한데, 그래서 k=1~N까지 시도하며 정보를 계속해서 갱신하게 됩니다.

이때, k-1단계 이전의 정보는 더이상 필요하지 않아서 3차원 배열을 쓰지 않고 **슬라이딩 윈도우** 기법을 적용하여 덮어써서 2차원 배열 dist만 가지고도 해결이 됩니다.

이걸 저번의 벨만 포드 알고리즘과 비슷하게 k번의 루프를 돌려보면 마지막엔 더 이상 갱신되지 않는 최단 경로 배열 dist가 완성되는 겁니다.



매 단계마다 하는 일은 이러합니다.

이번이 k단계, 즉 1~k번 정점을 사용하여 도달가능한 최단거리를 구해야 하는 단계라 합시다.

그렇다면 지금까지 dist 배열에는 1~k-1번 정점만 사용해서 나올 수 있는 최단거리가 남아있죠.

이걸 사용해서 갱신합니다.



*어떤 두 정점 i, j에 대해, k번 정점을 사용해 우회하면 지금까지보다 최단거리가 짧아지는가?*



이 질문을 모든 i, j 쌍에 대해 던져보고 만약 그렇다면 갱신하는 것인데요. 이 쿼리의 형태는

**`if( dist[i][j] > dist[i][k] + dist[k][j] )`**

이런 형태가 됩니다. 현재 dist[i][j]는 지금까지 찾은 최단거리를 담고 있는데,

여기서 `dist[i][k]+dist[k][j]`, 즉 k번 정점을 새로 우회하여 가는 경로가 더 빠를 수도 있는데 그걸 묻고 있는 겁니다.

만약 더 빠르다면, 이제 `dist[i][j]는 dist[i][k]+dist[k][j]` 값으로 갱신되어 더 작아집니다.

```c++
#include <cstdio>
#include <algorithm>
using namespace std;
const int INF = 1000000000; // 절대 나올 수 없는 경로값
 
int main(){
    int N, M, dist[100][100];
    scanf("%d %d", &N, &M);
    // dist 배열 초기화
    for(int i=0; i<N; i++)
        for(int j=0; j<N; j++)
            dist[i][j] = i==j ? 0 : INF;
    // 간선 정보 입력받음
    for(int i=0; i<M; i++){
        int a, b, c;
        scanf("%d %d %d", &a, &b, &c);
        dist[a-1][b-1] = min(dist[a-1][b-1], c);
    
    // 플로이드 와샬 알고리즘 적용
    for(int k=0; k<N; k++)
        for(int i=0; i<N; i++)
            for(int j=0; j<N; j++)
                dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]);
    
    // 이제 dist 배열은 실제 최단 경로를 담고 있음
    for(int i=0; i<N; i++){
        for(int j=0; j<N; j++)
            printf("%d ", dist[i][j]);
        puts("");
    }
}
```

이게 위 문제를 푸는 소스 코드인데...

실제로 그래프가 마련되어 있을 때 플로이드 알고리즘은 20~23번 줄, 단 4줄밖에 안됩니다...

엄청 짧죠. 외워지기도 제일 빨리 외워지는 알고리즘입니다.

이게 끝나면 dist 배열의 i행 j열엔 말 그대로, i->j로 가는 최단 거리가 남게 됩니다!!



정점 V개에 대해 모든 정점에서 다익스트라 알고리즘을 돌리면 **O(V(E+VlogV))**일 것이고

만약 간선 개수가 V^2보다 많이 작다면 다익스트라 알고리즘이 약간 우위지만

음의 가중치를 가진 그래프에서는 이건 사용이 불가능하고,

벨만 포드 알고리즘을 모든 정점에 대해 돌리면 **O(V^2\*E)**이니 이쪽은 플로이드가 거의 무조건 우위입니다.

모든 정점 간의 거리를 빠르게 구해야 할 땐 플로이드가 최고지요.

또한 그 코드의 간단함과 목적의 명확함 때문에, 어려운 문제들은 이게 최단경로 문제인가조차 처음엔 알 수 없게 포장되어 나오기도 합니다.

## 플로이드 관련 문제

**추천 문제**



**11404번: 플로이드**

위에서 설명한 문제입니다.



**11403번: 경로 찾기**

위에서 설명한 문제입니다.



**1389번: 케빈 베이컨의 6단계 법칙**

문제 설명이 좀 길지만, 그냥 자기 자신으로부터 다른 모든 정점으로의 각 최단거리 합이 가장 작은 애를 하나 찾으라는 문제입니다.



**1613번: 역사**

a가 b보다 먼저 일어났다고 할 때 `dist[a][b] = 1`, 나머지는 ∞인 상태로 플로이드를 돌립니다.

이러면 끝나고 나서도 `dist[u][v] = ∞, dist[v][u] = ∞`이면 u, v는 서로 전후관계를 알 수 없다는 말입니다.

만약 `dist[u][v]`가 무한대가 아니라면 u에서 v로 가는 경로가 존재한다는 것이고, 따라서 u가 v보다 먼저 일어났다는 걸 알 수 있습니다.

u가 v보다 나중에 일어났다는 것을 확인하려면 반대로 `dist[v][u]`를 확인하면 됩니다.



**2610번: 회의준비**

위원회의 수는 컴포넌트의 수이고, 각 컴포넌트마다 안에서 대표를 뽑아야 하는데 이 대표는 컴포넌트 안의 다른 정점들로의 최단거리 중 최댓값이 가장 작은 사람이겠죠.

따라서 각 정점을 컴포넌트별로 분리하는 작업도 필요합니다.



**1956번: 운동**

간단하죠. dist[i][i]도 다 ∞인 상태로 시작하여 플로이드를 돌리고

마지막에 dist[i][i]가 최소인 i를 찾고 그 값을 출력하면 됩니다.



**13168번: 내일로 여행 (★)**

입력 데이터만으로도 책을 쓸 정도로 입력이 길지만, 시크하게 map 등으로 문자열을 정점 번호로 대응시킨 후 넘어갑시다.

그럼 이 문제는 a->b->c->...->a 형태의 고정된 경로의 최단비용이므로, 각 경로의 최단비용을 다 답해야 하니까 아예 모든 경로의 최단비용을 구해놓는 플로이드가 매우 적합하지요.

티켓을 샀을 때와 사지 않았을 때 몇몇 간선의 cost를 달리하면서, 둘 중 어느 쪽이 좋은지 결과를 놓고 비교하면 됩니다.



**9205번: 맥주 마시면서 걸어가기 (★)**

각 편의점에 들를 때마다 무조건 맥주를 풀로 조달해간다면, 출발해서 다른 정점까지 1000미터 이하의 거리라면 그 정점으로는 갈 수 있습니다.

따라서 출발점, 도착점 정점을 추가로 만들고, 거리가 1000 이하인 정점들 사이에만 간선을 놓고, 출발점에서 도착점까지 이동 가능한지를 판별하면 됩니다.



**2458번: 키 순서 (★)**

u보다 v가 키가 클 때 `dist[u][v]` = 1이고 나머지는 ∞인 상태로 시작해서,

마지막에 자신을 제외한 모든 정점에 대해 자신이 그 정점으로 갈 수 있거나 그 정점에서 자신으로 갈 수 있는 정점 수를 세면 됩니다.

u에서 v로 갈 수 있다면 u보다 v가 확실히 크다는 것이고, 반대방향은 v보다 u가 확실히 키가 작다는 정보를 주기 때문입니다.

둘 다 아니라면 u, v의 키 관계를 알 수 없게 됩니다.



**11562번: 백양로 브레이크 (★)**

알고스팟 등의 문제를 풀어봤다면 이 문제도 쉽게 풀 수 있습니다. 아마...

건물 s에서 건물 e로 갈 때 양방향으로 바꿔야 하는 길의 최소 개수란, 현재 그래프에서 거쳐야 하는 역방향 간선의 최소 개수를 말하겠죠.

따라서 (u->v)로 가는 길이 존재하고 그 길이 양방향이라면 `dist[u][v] = dist[v][u] = 0`, 아니라면 `dist[u][v]`만 0이고 `dist[v][u]`는 1로 두면 됩니다. 역방향으로 v에서 u로 가려면 이 길을 양방향으로 바꿔야 하니까요.



**1507번: 궁금한 민호 (★)**

플로이드가 최단경로를 갱신하는 방법을 반대로 이용하면 됩니다.

만약 `dist[i][j] = dist[i][k] + dist[k][j]`라면, 어차피 i->k->j로 우회해 간 거리가 원래의 최단거리이므로 i->j로 바로 가는 간선을 지워버려도 됩니다.

이렇게 해서 간선을 지울 수 있는 만큼 모두 지우는데, 만약 중간에 `dist[i][j]보다 dist[i][k] + dist[k][j]`가 더 작은 경우가 존재할 경우 모순입니다.



# **> 오일러 경로, 오일러 회로**

이번에 소개할 내용은 **오일러 경로**(Eulerian trail) 및 **오일러 회로**(Eulerian circuit)입니다.

위상수학, 이산구조 시간의 그래프 이론 챕터에서 한 번쯤 보셨을 내용입니다.

무향이나 유향 그래프가 있을 때, **그래프에 존재하는 모든 간선을 정확히 1번씩만 방문하는 연속된 경로**가 바로 이것들입니다.

이때 시작점과 도착점이 같으면 오일러 회로가 되고, 아닐 경우 그냥 오일러 경로가 됩니다.

![image-20200916160134708](https://user-images.githubusercontent.com/58545240/93306572-080c3c80-f83b-11ea-81a0-e68e5b06c103.png)

이와 같은 무향 그래프가 있을 때, 경로 [A, B, C, D, A]는 시작점으로 돌아오기는 했으나 모든 간선을 사용하지는 않으므로 오일러 회로가 아니지만(물론, 오일러 경로조차 아닙니다),

경로 [A, B, C, E, F, C, D, A]는 오일러 회로입니다. 모든 간선을 정확히 한 번씩 거쳤기 때문이죠.



이걸 사용하는 응용문제는 정말 가뭄에 콩 나듯 드문 편이고, 그냥 어떻게 오일러 경로를 찾는가 정도만 알려드리려 합니다.

정말 가끔씩 응용문제가 대회에 출제될 때가 있는데, 하나같이 다 개막장 난이도를 자랑하기에 이 글에 함부로 싣지를 못하겠습니다.



먼저 오일러 경로의 존재여부를 판단하는 방법은 너무 유명해서 다들 아실 겁니다.

무향 그래프의 경우, 차수(degree)가 홀수인 정점이 2개일 때 오일러 경로(회로가 아닌)가, 0개일 때 오일러 회로가 존재하고

오일러 경로는 시작점과 끝점을 차수가 홀수인 정점 2개로 하며, 오일러 회로는 존재만 한다면 그 어떤 정점을 시작점으로 뽑아도 만드는 것이 가능합니다.

당장 위 그래프를 보면 각 정점의 차수가 다 짝수이고, 따라서 오일러 회로가 존재합니다.

이건 시작점과 끝점을 제외하고서는 들어오는 간선이 있다면 반드시 나가는 간선이 하나 더 마련되어 있어야 하기 때문이죠. 항상 차수가 2의 배수꼴로 붙게 됩니다.



유향 그래프에서 오일러 회로가 존재하려면 모든 정점에 대해 indegree와 outdegree가 일치해야 합니다. 위와 같은 맥락이죠.

회로가 아닌 오일러 경로라면 indegree가 1 적은 정점 하나가 시작점, outdegree가 1 적은 정점 하나가 끝점으로 정해지며 다른 indegree와 outdegree가 불일치하는 정점이 더 있으면 안 됩니다. 물론 1씩 차이가 나지 않아도 안됩니다.

또한 유향/무향 관계없이, 서로 다른 컴포넌트에 각각 간선이 존재해도 오일러 경로는 존재할 수 없습니다. 두 컴포넌트 자체가 떨어져 있어서 절대 경로를 이을 수 없기 때문.

그러나 간선만 없다면 떨어져 있는 정점이 있어도 오일러 경로는 존재합니다! 이게 무진장 큰 함정이었습니다...

그럼 이제 오일러 **회로**를 구해볼 것인데요. 위키에 실려 있는 현재 가장 널리 알려졌고 효율적인 알고리즘은 **Hierholzer's Algorithm**입니다.

이 알고리즘은 말로 풀어쓰면 정말 너무나도 간단한데,

1. **아무 정점 v를 뽑고 v에서 출발해 v로 돌아오는 경로를 하나 뽑는다.**
2. **이때, 위 경로에 속해있는 정점 중 인접한 간선들 중에 경로에 쓰이지 않는, 즉 아직 방문되지 못한 간선이 있는 정점 u가 존재하면, u에서 시작해서 아직 쓰이지 않은 간선들만 사용해 u로 돌아오는 경로를 하나 더 찾아 원래의 경로에 끼워넣는다.**

그러니까..

![image-20200916160418025](https://user-images.githubusercontent.com/58545240/93306591-0e021d80-f83b-11ea-8a88-64ee54c4fd8d.png)

위 그래프에서 시작점을 A로 놓고 경로 [A, B, C, D, A]를 찾았다고 합니다.

그러나 이 중 정점 C는 아직 사용하지 않은 인접한 간선이 존재합니다.

![image-20200916160432583](https://user-images.githubusercontent.com/58545240/93306604-122e3b00-f83b-11ea-99bd-43fd10f15bbf.png)

따라서 C에서 또다른 경로 [C, E, F, C]를 찾아서 원래의 경로에서 C가 있던 자리에 대체해서 끼워 넣으면,

[A, B, **C, E, F, C**, D, A]가 되어 오일러 회로가 완성됩니다.

물론 여기서 항상 끝나지는 않고, 또 경로 [C, E, F, C]의 정점들 중에서 아직 사용하지 않은 인접간선이 남아있는 정점이 존재한다면 **재귀적으로** 또 경로를 구해 끼워넣어야 합니다.



말로 풀어쓰자니 진짜 지극히 간단한데, 도대체 이걸 어떻게 할 거냐는 게 문제.

해결방법은 "재귀적"이라는 표현에서 알 수 있듯이 **DFS**입니다.

방문을 하면서 해당 간선을 사용한 것으로 표시하거나 지우고 간선 양쪽의 차수를 1씩 줄여 나가는데,

해당 정점의 방문 함수가 끝나는 순간에 정점 번호를 출력하면 이걸 이어붙인 게 정답이 됩니다!



A->B->C 순으로 방문했다고 합시다. 만약 여기서 D를 먼저 택해도, D->A로 가서 A의 이웃이 더 없으므로 방문이 끝나 C로 돌아오면서 "A D"를 출력하게 됩니다.

그 다음 남은 정점 E를 선택해서 C->E->F->C로 가면 C도 더 이상 이웃이 없어서 그대로 돌아가며 "C F E C"를 출력하고,

C에서도 시작점인 A로 돌아가면서 "B A"를 출력하면...

이걸 다 이어붙이면 "A D C F E C B A"가 되고 이건 오일러 회로입니다.



만약 A->B->C를 방문하고 D가 아니라 E를 먼저 방문했다고 해도, C->E->F->C를 방문한 후 C에서 이제 유일하게 남은 D를 방문하는 순서를 거치게 되고

결과를 이으면 "A D C F E C B A"가 되어서 또 오일러 회로입니다.



## - BOJ[1199] : 오일러 회로

https://www.acmicpc.net/problem/1199

오일러 회로를 찍어봅시다.

참고로 자기 자신으로 돌아오는 간선은 없습니다!

```c++
#include <cstdio>
#include <vector>
using namespace std;
 
// 간선 구조체
struct Edge{
    int to, cnt; // to: 인접한 정점, cnt: 남은 사용 횟수
    Edge *dual; // dual: 역방향 간선을 가리키는 포인터
    Edge(): Edge(-1, 0){}
    Edge(int to1, int cnt1): to(to1), cnt(cnt1), dual(nullptr){}
};
 
int N, degree[1000];
vector<Edge*> adj[1000];
bool visited[1000];
 
// 컴포넌트별로 방문하는 dfs
int dfs(int curr){
    int result = 1;
    visited[curr] = true;
    for(Edge* e: adj[curr]){
        int next = e->to;
        if(!visited[next]) result += dfs(next);
    }
    return result;
}
 
// 오일러 회로를 출력하는 dfs
void Eulerian(int curr){
    for(Edge *e: adj[curr]){
        if(e->cnt > 0){
            // 순방향, 역방향 간선을 하나씩 지움
            e->cnt--;
            e->dual->cnt--;
            // dfs
            Eulerian(e->to);
        }
    }
    printf("%d ", curr+1);
}
 
 
 
int main(){
    scanf("%d", &N);
    for(int i=0; i<N; i++){
        for(int j=0; j<N; j++){
            int val;
            scanf("%d", &val);
            // 간선 추가
            if(j > i && val > 0){
                Edge *e1 = new Edge(j, val), *e2 = new Edge(i, val);
                e1->dual = e2;
                e2->dual = e1;
                adj[i].push_back(e1);
                adj[j].push_back(e2);
                degree[i] += val;
                degree[j] += val;
            }
        }
    }
    // 차수가 홀수인 정점이 존재하면 불가능
    for(int i=0; i<N; i++){
        if(degree[i]%2 == 1){
            puts("-1");
            return 0;
        }
    }
 
    bool flag = false;
    int start = -1;
    for(int i=0; i<N; i++){
        if(!visited[i]){
            int cSize = dfs(i);
            if(cSize > 1){
                if(flag){ // 크기가 2 이상인 컴포넌트가 2개 이상이면 불가능
                    puts("-1");
                    return 0;
                }
                else{
                    start = i;
                    flag = true;
                }
            }
        }
    }
    if(start == -1) start = 0;
 
    // 오일러 회로 찾기 시작
    Eulerian(start);
}
```

그냥 오일러 회로 하나만 찍으라는 비교적 간단한 문제인데 할 건 더럽게 많습니다.



오일러 회로가 아니라 오일러 경로를 찾아야 하는 문제의 경우, 즉 명확히 시작점과 끝점이 달라야 하는 경우, 차수가 홀수인 정점이 정확히 2개가 존재해야 합니다.

저걸 먼저 체크한 후, 두 홀수차수 정점 사이에 가상의 간선을 한 개 만든 후 오일러 회로를 찾은 뒤에 가상간선을 삭제하면 나머지가 오일러 경로가 됩니다.

또, 방향 그래프에서도 오일러 회로를 찾을 수 있는데 이때는 각 정점마다 indegree와 outdegree가 같아야 회로가 존재합니다. 이후는 비슷하게 하면 됩니다. 단, 위와 같이 재귀 호출이 끝나는 시점에 자신을 경로의 맨 끝에 붙이는 방식을 사용할 경우, 마지막에 경로 전체를 뒤집어 줘야 합니다.



오일러 회로나 경로는 정말 보기 힘든 문제인데, 주로 딱 보고 이게 오일러 회로 문제라는 걸 알 수가 없습니다. 나오는 족족 상당히 기상천외하고 신박한 발상을 요구합니다.

그 때문에 추천 문제의 목록 자체가 상당한 스포일러가 됩니다. 이 문제들은 오일러 회로와 엮여있음을 아는 순간 거의 90%는 도달한 것인 동시에, 엄청난 스포가 맞죠.

## 오일러 회로 관련 문제

**1199번: 오일러 회로**

위에서 설명한 문제입니다.



**1616번: 드럼통 굴리기 (★)**

갓문제 1. 문제를 다르게 표현하면 모든 M자리 K진수를 한 개씩 만드는 겁니다. (M-1)자리의 모든 K진수 K^(M-1)개가 각 정점입니다. 이제 정점 u에서 0~K-1 사이의 모든 수 k에 대해, u의 첫 한 자리를 지우고 마지막에 k를 붙여 새로 만들어진 M-1자리 K진수수 v로 가는 간선을 만들고 각각 k라 마킹합니다. 총 간선 수는 K^(M-1)*K = K^M개입니다. 이제 여기서 오일러 회로를 찾는 것이 곧 문제를 푸는 셈이 되겠죠!

단, 제한이 너무 빡빡하기 때문에 시간이든 메모리든 초과가 엄청나게 일어납니다. 최대한 정적 배열로 해결해야 합니다. 또한, M자리 K진수가 K^M개 있는 것은 맞고 각각 십진법으로 나타낼 시 0~K^M-1로 일대일 대응되는 것도 맞지만, 그냥 보이는 그대로 문자열로 저장한다던가 하면 오버헤드가 클 수 있습니다. 특히 5백만 자리 2진수 같은 걸 저장했다간...



**1591번: 수열 복원 (★)**

갓문제 2. 위의 드럼통 굴리기 문제와 유사합니다. 주어진 길이 M의 부분수열들마다, 2개의 길이 M-1인 부분수열이 중복 상관없이 등장하게 되는데, 이러한 각 부분수열을 정점으로 둡니다. 이때는 값 자체가 같으면 같은 정점입니다. 이제 i번째 M자리 부분수열에서 마지막 항을 제거한 부분수열 -> 첫 항을 제거한 부분수열로 가는 간선을 추가해 주고, 단방향 오일러 경로를 찾으면 됩니다.

역시 중복 간선이 존재할 수 있으니 주의해야 합니다. 또한 답이 회로일 수도, 아닐 수도 있으므로 주의해야 합니다.



# **> 네트워크 유량(Network Flow)**

---

안녕하세요. 그래프에 대해서 1차적으로 쓸 내용 중에서는 마지막 개념에 달했습니다.

그런데 마지막 개념이기는 한데, 이 개념 한 부류를 설명하는 데 또 글을 엄청 써야 할 것 같네요.

그만큼 중요한 개념입니다. 최단 경로만큼이나... 아니 어쩌면 더...



최단 경로 알고리즘의 경우는 자료구조 수업 때 먼저 접하는 것도 있고, 최단경로가 무엇인가 하는 개념도 기초적인 편이라서 그렇게 어렵지는 않은데(알고리즘 자체는)

이번에 소개하려 하는 **네트워크 유량**(network flow)이란 개념은 상대적으로 생소합니다.



그래프의 간선에 거리, 시간이나 가중치, 즉 cost 대신에 **용량**(capacity)이라는 개념이 추가됩니다.

이제 두 정점 u, v를 잇는 간선 (u, v)가 있을 때, 정점 u에서 v 방향으로 간선의 용량 이하만큼의 **유량**(flow)을 흘려보낼 수 있습니다.

또한 그래프에 서로 다른 두 정점인 **소스**(source), **싱크**(sink) 정점이 정해지고,

소스 정점에서 유량을 발생시켜서 간선들을 통해 싱크 정점에 도달시키는 것이 목표입니다.

유량을 발생시킬 수 있는 건 소스 정점 뿐이고, 그 외의 정점들은 자신이 받은 유량만큼만 다시 흘려보낼 수가 있습니다.

![image-20200916171513414](https://user-images.githubusercontent.com/58545240/93312859-ac45b180-f842-11ea-836e-19f5930e245c.png)

강의자료 예시 그래프를 하나 가져왔습니다. 보통 **유량 그래프**(flow network)는 방향 그래프인 경우가 많습니다. 물론, 무향 그래프일 수도 있습니다.

여기서 각 간선에 적힌 숫자는 거리라던가 가중치라던가 하는 게 아니라 용량입니다.

그리고 정점 S가 소스, 정점 T가 싱크입니다. 보통 소스와 싱크가 s, t로 많이 표현됩니다.

![image-20200916171529697](https://user-images.githubusercontent.com/58545240/93312871-b071cf00-f842-11ea-90fd-9bd8d492de96.png)


S에서 T로 유량 1을 하나 보내본 예시입니다. 각 간선의 p/q에서 p는 유량, q는 용량입니다.

일단 S에서 유량 1을 발생시켜서, 유량 1을 보낼 수 있을 정도로 용량이 충분히 남아있는 경로를 아무거나 찾아서 T까지 보낸 겁니다.

유량을 흘려보내는 것을 도중에 멈춰서는 안 되고, 반드시 T까지 도달해야만 유효합니다.

![image-20200916171542093](https://user-images.githubusercontent.com/58545240/93312970-d26b5180-f842-11ea-910a-1ca3022e6312.png)

한 번 더 보내본 것인데, 여기서 간선 (D, T)는 두 경로에 모두 포함되어 있어서

두 번 보낸 유량이 모두 지나가고 있습니다.

![image-20200916171554742](https://user-images.githubusercontent.com/58545240/93312989-d5fed880-f842-11ea-9720-7f2a76278f40.png)

한 번 더 다른 경로를 찾아봤는데 이번엔 간선의 용량이 넉넉해서 4를 한번에 보낼 수 있었습니다.

지금까지 S에서 T로 보낸 유량의 합은 1+1+4=6입니다.

이 상황에서 경로 [S, A, D, T]로 유량을 더 보낼 수 있을까요? 불가능합니다.

왜냐면 경로에 속한 간선 (D, T)에는 더이상 용량이 남아있지 않기 때문입니다.



여기서 유량 그래프에서 만족해야 하는 성질들을 짚고 넘어갑시다.



먼저, **각 간선에 흐르는 유량은 그 간선의 용량을 넘어서는 안 됩니다.** 즉 f(u, v) ≤ c(u, v)입니다.

f, c는 각각 flow, capacity의 앞글자를 딴 것으로, 유량과 용량입니다. 보통 이렇게 표현합니다.



두 번째로, S와 T를 제외한 정점에서는 **들어오는 유량 총합과 나가는 유량 총합이 같아야 합니다.**

즉, Σf(k, u) = Σf(u, l)입니다.

S에는 유량이 발생하고, T에서는 유량이 종착하여 더 이상 나가지 않으므로 S에서 흘리는 유량의 합 또한 T로 들어가는 유량의 합과 같습니다.

즉, Σf(S, k) = Σf(k, T)입니다.



세 번째로, 간선 (u, v) 방향으로 유량이 흐르고 있다면, **역방향으로는 음의 유량이 그만큼 흐르고 있는 것으로 취급합니다.**

즉, f(u, v) = -f(v, u)입니다.

위의 두 성질보다는 좀 덜 당연한데, 이 성질은 추후 최대 유량을 구해내는 알고리즘에서 유용하게 써먹습니다.



이제 유량이 뭔지, 유량 그래프가 뭔지 좀 감이 오시나요?

이렇게 보면, 이제 이 그래프는 S에서 T로 가는 최단 경로는 아니고, S에서 T로 동시에 보낼 수 있는 데이터라든가 사물이라든가의 양이 얼마나 될 것이냐를 묻는 것에 가깝습니다.

**대역폭**(bandwidth)의 개념과도 잘 맞아떨어지고, 그래서 네트워크라는 이름을 가졌을지도 모르지요.





그래서, 보통 이런 그래프가 주어지면 우리가 구해야 할 것은 이겁니다. **최대 유량**(maximum flow).

S에서 T로 성질들을 해치지 않고 보낼 수 있는 최대 유량입니다.

![image-20200916171615677](https://user-images.githubusercontent.com/58545240/93313086-f7f85b00-f842-11ea-8112-745deaec7b0e.png)

아까 그 그래프의 답은 7인데, 이렇게 유량을 흘리면 됩니다.



최대 유량을 구하는 알고리즘은 정말 미친듯이 많고 시간복잡도도 다양한데, 보통 짜기 쉬울수록 시간복잡도가 안 좋긴 하지만... 아직은 가장 쉬운 버젼으로도 충분히 거의 모든 플로우 문제를 풀 수는 있습니...다...

그러나, 최근들어 상급 알고리즘들이 있어야만 제한시간 안에 풀 수 있는 문제의 출제빈도가 높아지고 있어서(특히 이벤트성 대회에서), 그런 알고리즘들을 모아서 따로 글을 하나 쓸 겁니다.

여담이지만 위키를 가보면 무려 최근, 그것도 2013년에 더 상향된 시간복잡도를 가진 최대 유량 알고리즘을 누가 개발했다고... 여튼 꽤 발전이 늦은 분야라 지금도 매우 활발하게 연구가 진행 중입니다. 지금 보면 별 것 아닌 것 같은(?) 성질들도 하나하나가 구글링 도중 2000년대 논문으로 심심찮게 걸려나옵니다.



일단, 제일 처음으로 소개해드릴 알고리즘은 기초 중의 기초인~~플로우가 기초가 아닌데~~

**포드 풀커슨 알고리즘**(Ford-Fulkerson algorithm)입니다. 이 알고리즘의 동작원리는 간단합니다.



**①** S에서 T로 가는 **증가 경로**(augmenting path)를 아무거나 하나 찾는다. 이때, 증가 경로는 단순 경로이고, 경로상의 모든 간선에 아직 여유 용량(residual)이 남아있다. 즉, **c(u, v) - f(u, v) > 0**

**②** 증가 경로 중 **차단 간선**(blocking edge)을 찾는다. 이 간선은 경로상에서 c(u, v) - f(u, v) 값이 최소인 간선이다. 많아봐야 이만큼만 유량을 더 보낼 수 있을 것이다. 이 값을 F라 하자.

**③** 경로상의 모든 간선에 F만큼의 유량을 추가한다. 즉, S에서 T로 이 경로를 따라서 F만큼의 유량을 새로 흘려보낸 것이다. 경로상의 모든 간선에 대해 **f(u, v) += F**

그런데 세 번째 성질을 만족시키기 위해 **f(v, u) -= F** 또한 행해야 한다. 역방향으로는 상응하는 음의 유량을 흘려주는 것.



위 과정을 **더 이상 증가 경로가 없을 때까지** 반복합니다. 증가 경로를 찾고, 찾은 경로에 대해 가능한 한 많은 유량을 흘려보내는 것의 반복입니다.



도중에 blocking edge라는 용어는 그냥 제가 대충 이름붙인 겁니다. Augmenting path라는 말은 실제로 쓰입니다.

그리고 그래프에서 원래 존재하는 간선 (u, v)가 있더라도 그 역방향 간선 (v, u)는 없는데, 거기다 음의 유량을 보내는 게 대체 무엇인지 아직은 좀 감이 안 오실 수도 있습니다.

(v, u)를 있긴 하지만 쓸모없는, 용량이 0인 간선이라고 생각하시면 됩니다. 아래의 예제에서 자세히 이게 어떻게 돌아가는지 살펴봅시다.

![image-20200916171658454](https://user-images.githubusercontent.com/58545240/93313103-fb8be200-f842-11ea-87e2-b0c777de65a0.png)

이런 예제 그래프가 있습니다. 여기서 포드 풀커슨 알고리즘을 시행할 겁니다.

![image-20200916171709933](https://user-images.githubusercontent.com/58545240/93313134-047cb380-f843-11ea-92df-c0ddded939ff.png)

일단 아무 증가 경로를 하나 찾습니다. [S, A, E, T]를 골랐는데요.

경로가 여러 개일 때 그 중 하나를 고르는 기준은 아무것도 없습니다.

따라서 제일 고르고 싶게 생긴 [S, A, D, T]를 일부러 안 고르는 것도 가능한데, 제가 지금 이런 경로를 고른 건 앞으로 어떤 특수한 상황을 발생시키려는 의도입니다.



여튼, 여기서 차단 간선은 (S, A)이고 그 값이 3-0=3이므로 이 경로로 3의 유량을 흘려보냅니다.

![image-20200916171720607](https://user-images.githubusercontent.com/58545240/93313211-25dd9f80-f843-11ea-862a-2e9ad1f8e7c9.png)

그 다음, 또다른 경로 [S, B, E, T]를 찾았는데 차단 간선 (B, E)에 걸려 2의 유량을 보낼 수 있습니다.

![image-20200916171732291](https://user-images.githubusercontent.com/58545240/93313245-30983480-f843-11ea-9cbd-0bb03d80dc46.png)

그 다음, 경로 [S, C, F, T]를 찾아서 차단 간선 (F, T)에 의해 유량 4를 보냅니다.

그럼 이제... 겉보기에는 증가 경로를 더 찾을 수가 없는데요.

[S, C, F, E, T] 경로를 찾아보자니 간선 (E, T)가 이미 꽉 차 있고...



그런데, 정말 이게 끝일까요?

만약 맨 처음에 경로 [S, A, D, T]로 유량 1을 흘려보내고,

그 다음 경로 [S, A, E, T]로 유량 2를 흘려보내고,

경로 [S, B, E, T]로 유량 2, 경로 [S, C, F, T]로 유량 4를 흘려보냈다면

아직 간선 (E, T)로 흐르는 유량이 4밖에 안 되기 때문에

경로 [S, C, F, E, T]로 유량 1을 추가로 흘려보낼 수 있어서 **지금보다 답이 크게 나옵니다.**

그럼, 처음에 경로를 잘못 택한 것 때문에 답을 잘못 구하게 되었다는 말인데...



사실, 아닙니다. **아직 이 그래프에도 증가 경로가 존재합니다.** 

![image-20200916171745337](https://user-images.githubusercontent.com/58545240/93313270-3857d900-f843-11ea-86fa-69c5f6295965.png)

아까 세 번째 성질에서 f(u, v) = -f(v, u)라고 했습니다.

간선 (u, v)가 존재한다면 c(u, v)가 양수고 c(v, u)는 0으로 취급한다고도 했습니다.

따라서, 그래프에서는 없는 간선이지만 가상으로는 있는, 간선 (A, E)의 역방향 간선 (E, A)를 들춰봅시다.

이 간선의 용량은 0인데, 여기로 지금 -3만큼의 유량이 흐르고 있습니다.

따라서 c(E, A) - f(E, A) = 0 - (-3) = 3 **>0** 이 되는데요!!

따라서 이 가상의 간선 (E, A)로 유량을 흘려보내는 게 가능해지고,

![image-20200916171756172](https://user-images.githubusercontent.com/58545240/93313336-4f96c680-f843-11ea-91ee-230f7caf1d8e.png)

이렇게 경로 [S, C, F, E, A, D, T]를 찾는 것이 가능해지며 이때 유량 1을 추가로 흘려보낼 수 있습니다!!

간선 (E, A) 방향으로 유량이 1 흘렀기 때문에, 실제로 존재하던 간선 (A, E)로 흐르던 유량은 반대로 1 감소하는 효과가 생기는 것은 덤.



이게 도대체 무슨 일이냐...면, 이건 유량을 상쇄시키는 효과인데요.

**원래 정점 A에서 E로 흘려보내던 유량 3 중에서 1을 철수해서 다른 정점인 D로 흘려보내게 되었다**고 생각할 수가 있습니다. 이렇게 하면 원래 흐르던 유량에도 손실이 없습니다.

간선 (A, E) 방향으로 흐르던 유량 3 중에서 1만큼을 A로 다시 되돌려보내서 다른 경로로 흘려보내도록 유도한 것인데,

그 경로는 지금의 경우엔 마지막에 찾은 경로 [S, C, F, E, A, D, T] 중에서 정점 A 이후에 이어지는 부분 경로인 [A, D, T]가 됩니다.

이 경로는 맨 처음에 A에서 선택했던 경로 [A, E, T]와는 다른 방향의 경로이고, 이 경로를 뒤늦게 지나가도록 유량 일부를 돌려보낸 것이나 마찬가지가 된 겁니다.

또한 이번에 찾은 경로는 첫 번째로 찾은 경로에서 원래 사용하던 [E, T] 부분을 대신 사용하여 유량을 흘려보내는 것이나 마찬가지입니다. 즉, **서로 경로를 바꿔서 사용하고 있는 것.** 



첫 번째로 찾았던 경로 [S, A, E, T], 마지막 경로 [S, C, F, E, A, D, T]가 엇갈리면서

실제로는 처음부터 두 경로 [S, A, D, T]와 [S, C, F, E, T]로 각각 유량 1, 1을 보낸 것이나 마찬가지 상황으로 만들어놓은 것입니다.

이 두 경로는 원래의 경로들에서 **간선 (A, E), (E, A) 전후의 경로를 서로 스왑한 형태**죠. 그리고 서로가 간선 (A, E), (E, A)를 더 이상 사용하지 않게 되었고요.

간선 (A, E) 쪽으로 유량을 흘리다가 다시 (E, A) 쪽으로 유량을 흘려보내는 건 그냥 정점 A로 되돌아가는 것이나 마찬가지라 실제로 아무것도 안 한 것이나 마찬가지고 따라서 생략이 된 겁니다.



따라서, 이렇게 가능한 모든 경로를 찾은 채로 알고리즘이 종료되고, 최대 유량은 1+5+4(T로 들어가는 유량의 합)=**10**입니다.





이 알고리즘에서 증가 경로를 찾는 방법은 기본적으로 **DFS**인데요. DFS의 시간복잡도가 매번 O(V+E)입니다.

또한 이 문제의 답이 f이고, 모든 용량 단위가 정수라고 할 때 한 번 경로를 찾았을 때 유량이 최소 1씩은 보내지므로, 증가 경로를 찾는 루프는 최대 f번 실행됩니다.

따라서 포드 풀커슨 알고리즘의 시간복잡도는 최악의 경우 **O((V+E)f)**인데, 보통 V보다 E가 크므로 **O(Ef)**라 축약해서 씁니다. 보기에도 좋고.



여튼, 저 f라는 값 때문에 정말 최악의 경우엔 아주 어처구니없는 낭비 현상이 발생하기도 합니다.

![image-20200916171813394](https://user-images.githubusercontent.com/58545240/93313368-5a515b80-f843-11ea-883a-06cd67b3e2b0.png)

정말 유명한 그래프입니다. 이런 형태의 그래프가 있다고 합시다.

바로 경로 [S, A, T]와 [S, B, T] 2개만 찾으면 총합 2000의 답을 찾을 수 있으나,

답을 찾기 전까진 대체 어떤 경로를 먼저 찾아야 최적인지 모르기에...

![image-20200916171823077](https://user-images.githubusercontent.com/58545240/93313377-5de4e280-f843-11ea-9b84-0dfe6a5aada0.png)

우리의 DFS가 이렇게 경로 [S, A, B, T]를 찾았고 유량 1만 흘렸다고 합시다. 네 뭐 여기까진 봐주는데...

![image-20200916171833025](https://user-images.githubusercontent.com/58545240/93313400-650bf080-f843-11ea-9a22-63a3bf97314c.png)

그 다음에는 이번엔 [S, B, A, T]를 찾아서 또 유량을 1 흘립니다.

![image-20200916171843708](https://user-images.githubusercontent.com/58545240/93313422-6a693b00-f843-11ea-9491-bcab8ba274fc.png)

그러더니 다음엔 또 [S, A, B, T]로 1을 흘립니다.

![image-20200916171858806](https://user-images.githubusercontent.com/58545240/93313473-79e88400-f843-11ea-9013-37fa6066af19.png)

그 다음엔 또 [S, B, A, T]로 1을... **~~이... 이 멍청아!!~~**

이렇게 멍청하게 경로를 계속 찾으면 2000번 루프를 돌려야 합니다...

이 때문에 O(Ef)라는 시간복잡도가 나온 것이고요, 그나마 여기서야 E, f가 작아서 망정이지 만약...

![image-20200916171908464](https://user-images.githubusercontent.com/58545240/93313498-82d95580-f843-11ea-891f-577850f760e1.png)

![image-20200916171919484](https://user-images.githubusercontent.com/58545240/93313638-b320f400-f843-11ea-9295-3c080c140c21.png)

네 그렇습니다. 우리는 망한 겁니다.



아무래도 더 좋은 알고리즘이 필요합니다... 그런데 그게 은근히 간단한데요.

단지 증가 경로를 DFS가 아니라 **BFS**로 찾아서, S에서 T로 가는 그때그때의 가장 짧은 경로를 찾아내는 방식을 사용하면 시간복잡도가 최대 **O(VE^2)**로 줄어듭니다!

이것이 **에드몬드 카프 알고리즘**(Edmonds-Karp algorithm)입니다. 보통 많이들 사용하는 건 이쪽이라고 보시면 됩니다.

## - BOJ[6086] : Total Flow

https://www.acmicpc.net/problem/6086

이 문제를 풀어볼 건데요. 각 정점이 알파벳 대소문자 한 글자로 표현되므로 정점은 최대 52개고

언제나 소스는 'A', 싱크는 'Z'이며 간선 개수도 최대 700개. 또한 각 용량값도 최대 1,000.

최대 유량 알고리즘을 연습하기 딱 좋습니다.

그런데, 똑같은 간선 (a, b)가 짖궂게도 **여러 개** 존재할 수 있으므로 조심해야 합니다.

```c++
#include <cstdio>
#include <vector>
#include <queue>
#include <algorithm>
using namespace std;
const int MAX_V = 52;
const int INF = 1000000000;
 
// 정점 문자를 0~51 사이의 번호로 바꿔주는 간단한 함수
inline int CtoI(char c){
    if(c <= 'Z') return c - 'A';
    return c - 'a' + 26;
}
 
int main(){
    int N; // 간선 개수
    int c[MAX_V][MAX_V] = {0}; // c[i][j]: i에서 j로 가는 간선의 용량
    int f[MAX_V][MAX_V] = {0}; // f[i][j]: i에서 j로 현재 흐르는 유량
    vector<int> adj[MAX_V]; // 인접 리스트
 
    // 간선 정보 입력받기
    scanf("%d", &N);
    for(int i=0; i<N; i++){
        char u, v;
        int w;
        scanf(" %c %c %d", &u, &v, &w);
        u = CtoI(u); v = CtoI(v);
        c[u][v] = c[v][u] += w; // 같은 간선이 여러 번 들어올 수 있으므로 +=
        adj[u].push_back(v);
        adj[v].push_back(u); // 역방향 간선도 추가해줘야 함
    }
 
    // total: 총 유량, S: 소스, E: 싱크
    int total = 0, S = CtoI('A'), E = CtoI('Z');
    // 증가 경로를 못 찾을 때까지 루프
    while(1){
        // 증가 경로를 BFS로 찾음
        int prev[MAX_V];
        fill(prev, prev+MAX_V, -1);
        queue<int> Q;
        Q.push(S);
        while(!Q.empty() && prev[E] == -1){
            int curr = Q.front();
            Q.pop();
            for(int next: adj[curr]){
                // c[i][j]-f[i][j] > 0: i에서 j로 유량을 흘릴 여유가 남았는가?
                // prev[next] == -1: next 정점을 아직 방문하지 않았는가?
                if(c[curr][next]-f[curr][next] > 0 && prev[next] == -1){
                    Q.push(next);
                    prev[next] = curr; // 경로를 기억하기 위해 prev 배열 사용
                    if(next == E) break; // 싱크에 도달하면 나옴
                }
            }
        }
        // 싱크로 가는 경로가 더 없으면 루프 탈출
        if(prev[E] == -1) break;
 
        // 경로상에서 가장 허용치가 낮은 곳을 찾음
        int flow = INF;
        for(int i=E; i!=S; i=prev[i])
            flow = min(flow, c[prev[i]][i]-f[prev[i]][i]);
        // 찾은 flow만큼 해당 경로에 유량 흘려줌
        for(int i=E; i!=S; i=prev[i]){
            f[prev[i]][i] += flow;
            f[i][prev[i]] -= flow;
        }
        // 총 유량 값 증가
        total += flow;
    }
    // 결과 출력
    printf("%d\n", total);
}
```


코드가... 길죠. 하지만 큰 구조만 파악하시면 몇 번의 연습에 걸쳐 외우실 수 있을 겁니다.

큰 구조는 아까 말씀드렸듯이 매번 가능한 증가 경로를 찾고, 찾으면 가능한 만큼 유량을 흘려보내는 겁니다.

이때 증가 경로는 BFS로 찾습니다.

용량과 유량 값을 배열로 사용해도 좋은데, V 값이 너무 크면 O(V^2)의 공간이 부족할 수도 있습니다. 그때는 어쩔 수 없이 간선을 필요한 만큼만 만들어서 써야 합니다.



**초반에 가장 많이 하게 되는 실수는 역방향 간선을 추가하지 않는 겁니다.**

간선 (u, v)가 들어오면 반드시 v 쪽에서도 인접리스트에 u를 넣어서 역방향 간선을 만들어 주세요!

(이 문제에서는 간선이 양방향이기 때문에 그러기가 힘들지만)

대부분의 문제 예제가 간단한 편이라 이걸 안 해도 답이 나오는 경우가 많았어요... 경험담 ㅠㅠ

```c++
#include <cstdio>
#include <vector>
#include <queue>
#include <algorithm>
using namespace std;
const int MAX_V = 52;
const int INF = 1000000000;
 
// 간선 구조체
struct Edge{
    int to, c, f;
    Edge *dual; // 자신의 역방향 간선을 가리키는 포인터
    Edge(): Edge(-1, 0){}
    Edge(int to1, int c1): to(to1), c(c1), f(0), dual(nullptr){}
    int spare(){
        return c - f;
    }
    void addFlow(int f1){ // 자신과 역방향 간선에 f1만큼의 플로우 값을 갱신
        f += f1;
        dual->f -= f1;
    }
};
 
inline int CtoI(char c){
    if(c <= 'Z') return c - 'A';
    return c - 'a' + 26;
}
 
int main(){
    int N;
    vector<Edge*> adj[MAX_V]; // 존재하는 간선만을 인접 리스트로 저장
    // 간선 정보 입력받음
    scanf("%d", &N);
    for(int i=0; i<N; i++){
        char u, v;
        int w;
        scanf(" %c %c %d", &u, &v, &w);
        u = CtoI(u); v = CtoI(v);
        Edge *e1 = new Edge(v, w), *e2 = new Edge(u, 0);
        e1->dual = e2;
        e2->dual = e1;
        adj[u].push_back(e1);
        adj[v].push_back(e2);
    }
 
    int total = 0, S = CtoI('A'), E = CtoI('Z');
    while(1){
        int prev[MAX_V];
        Edge *path[MAX_V] = {0}; // 경로상의 간선들을 저장해두어 나중에 참조
        fill(prev, prev+MAX_V, -1);
        queue<int> Q;
        Q.push(S);
        while(!Q.empty() && prev[E] == -1){
            int curr = Q.front();
            Q.pop();
            for(Edge *e: adj[curr]){
                int next = e->to;
                if(e->spare() > 0 && prev[next] == -1){
                    Q.push(next);
                    prev[next] = curr;
                    path[next] = e;
                    if(next == E) break;
                }
            }
        }
        if(prev[E] == -1) break;
 
        int flow = INF;
        for(int i=E; i!=S; i=prev[i])
            flow = min(flow, path[i]->spare());
        for(int i=E; i!=S; i=prev[i])
            path[i]->addFlow(flow);
        total += flow;
    }
    printf("%d\n", total);
}
```

이것이 필요한 간선만을 구조체로 정의해서 저장하는 코드인데요.

이걸 구현하는 방법은 굉장히 많은데 가장 골치 아픈 건 역방향 간선을 가능한 한 빠르게 참조하는 겁니다.

제가 선호하는 방식은 처음부터 간선을 두 방향 모두 만들어서 서로를 가리키고 있게 만드는 것으로, dual 포인터가 그 역할을 하고 있습니다.





방향이 없는 그래프에서도 최대 유량을 찾는 건 가능합니다.

간선 (u, v)에 방향은 없지만, u에서 v로만 유량을 흘리거나 v에서 u로만 유량을 흘리는 게 가능한데요.

이건 놀랍게도 그냥 **양쪽 용량을 같은 값으로 초기화**해 두기만 하면 구현이 됩니다. 유량을 역방향에는 빼 주는 건 똑같이 해야 합니다.

무려 이 내용을 서술한 논문도 존재합니다...





그럼 이 어마무시한 플로우라는 개념을 활용할 수 있는 문제를 몇 개만 살펴봅시다.

## - BOJ[2188] : 축사배정

https://www.acmicpc.net/problem/2188


이 문제를 보면, 축사 하나엔 소 한 마리만 들어갈 수 있는데, 여기다 각 소는 들어갈 수 있는 축사의 번호들이 한정되어 있습니다.

이때, 소와 축사를 각각 정점으로 만들고 **소 정점 A에서 축사 정점 B로 유량 1을 흘려보내면, 소 A가 축사 B에 들어가는 것과 같은 효과**를 낼 수 있습니다.

또한 각 소는 하나의 축사에만 들어갈 수 있고, 각 축사에도 한 마리의 소까지만 들어갈 수 있다는 점을 용량으로 잘 해결하면 다음과 같은 그래프가 모델링됩니다.

![image-20200916172109123](https://user-images.githubusercontent.com/58545240/93313672-bcaa5c00-f843-11ea-9a99-a2273dddfa56.png)

예제에서 소 정점을 순서대로 A~E, 축사 정점을 1~5라고 하고

S에서 각 소 정점으로 갈 수 있고, 각 축사 정점에서 T로 갈 수 있다고 하며

각 소마다 들어가도 괜찮은 축사로만 간선을 연결해 주고, 모든 간선의 용량을 1이라 합시다.

![image-20200916172119739](https://user-images.githubusercontent.com/58545240/93313687-c0d67980-f843-11ea-9428-b0a5b42804ab.png)

여기서 다음과 같이 유량 1을 보낸다는 것은, 소 A가 2번 축사에 들어간다는 의미입니다!

또한 S에서 어떤 소로 가는 용량이 1이으모 소 A가 다른 축사에 한 번 더 동시에 들어가는 것은 불가능합니다. 즉, 소 한 마리는 축사 하나에만 들어간다는 조건을 지킵니다.

그리고 축사에서 T로 흐르는 유량도 최대 1이라는 점이, 축사 하나엔 최대 소 한 마리만 들어갈 수 있다는 조건을 지키게 해 줍니다.

이렇게 치면, 사실 가운데의 간선 용량들은 1 이상의 어떤 값이어도 상관없게 됩니다.

따라서 이 그래프에서 S에서 T로 유량을 1 흘려보내는 게 소 한 마리를 어떤 축사로 들인다는 의미이며, 흘려보낼 수 있는 최대 유량이 답이 됩니다.

```C++
#include <cstdio>
#include <vector>
#include <queue>
#include <algorithm>
using namespace std;
const int MAX_V = 800;
 
struct Edge{
    int to, c, f;
    Edge *dual;
    Edge(): Edge(-1, 0){}
    Edge(int to1, int c1): to(to1), c(c1), f(0), dual(nullptr){}
    int spare(){
        return c - f;
    }
    void addFlow(int f1){
        f += f1;
        dual->f -= f1;
    }
};
 
int main(){
    // 각 정점 n은 두 개의 정점 n*2-2, n*2-1로 나뉘어진다.
    int N, P;
    vector<Edge*> adj[MAX_V];
    scanf("%d %d", &N, &P);
    // 각 정점을 분리하고 사이에 용량 1인 간선 추가
    for(int i=0; i<N; i++){
        int u = i*2, v = u+1;
        Edge *e1 = new Edge(v, 1), *e2 = new Edge(u, 0);
        e1->dual = e2;
        e2->dual = e1;
        adj[u].push_back(e1);
        adj[v].push_back(e2);
    }
    // 간선을 입력받아 분리된 정점에 맞게 방향 간선 2개 추가
    for(int i=0; i<P; i++){
        int a, b;
        scanf("%d %d", &a, &b);
        a--; b--;
        // 순방향 간선 (나가는 정점 -> 들어가는 정점)
        Edge *e1 = new Edge(b*2, 1), *e2 = new Edge(a*2, 1);
        e1->dual = e2;
        e2->dual = e1;
        adj[a*2+1].push_back(e1);
        adj[b*2+1].push_back(e2);
        // 역방향 간선
        e1 = new Edge(a*2, 1); e2 = new Edge(b*2+1, 0);
        e1->dual = e2;
        e2->dual = e1;
        adj[b*2+1].push_back(e1);
        adj[a*2].push_back(e2);
    }
 
    // 최대 유량 구하기
    int total = 0, S = 1, E = 2;
    while(1){
        ...
    }
    // 결과 출력
    printf("%d\n", total);
}
```

에드몬드 카프 알고리즘으로 푸는 소스 코드입니다.

어때요, 최단 경로 알고리즘 때와는 다르게, 원래는 이게 유량을 흘리는 문제인가 하는 느낌이 잘 안 옵니다. 아니 소가 유량이라니요...

적절하고 영리한 모델링을 거쳐서 뜬금없이 플로우 그래프로 바꾸어야만 합니다...

플로우 챕터의 진입장벽이 좀 높은 이유. 척 보고 여기서 플로우를 발상하는 게 쉽지는 않습니다.



또한, 이 문제의 경우 수많은 유량 그래프 중에서도 좀 특이한 형태인데, 이런 형태의 그래프에 대해서 더 빠르게 최대 유량을 구하는 방법이 있고 이건 다음 글에 포스팅하겠습니다.

## - BOJ[17412] : 도시 왕복하기 1

https://www.acmicpc.net/problem/17412

이 문제는, 단방향 그래프이고 각 간선을 한 번씩만 써서 1, 2번 도시를 최대 왔다갔다할 수 있는 횟수를 구하라네요. 도대체 이게 뭐냐...

여기서 한 가지 팁을 드리자면, 플로우 그래프의 가장 큰 특징은 바로 **간선의 용량**입니다.

**어떤 길을 한 번만 지날 수 있다는 말은, 그 간선의 용량이 1이라는 것과 동치**입니다.

또한, 1->2->1->2... 식으로 왔다갔다하는 경로는, 바꿔 말하자면 1번 정점에서 2번 정점으로 경로가 하나도 겹치지 않게 하면서 갈 수 있는 서로 다른 경로의 개수입니다.

그렇습니다. 이건... 1번을 소스, 2번을 싱크로 하는 플로우 그래프이며 여기서 최대 유량이 답입니다.

![image-20200916172304262](https://user-images.githubusercontent.com/58545240/93313709-c7fd8780-f843-11ea-9d73-23a40be398d4.png)

왼쪽이 예제 그래프이고 오른쪽이 정답의 경우입니다. 총 2개의 경로가 존재하고 이건 최대 유량이 2였다는 겁니다.

## - BOJ[2316] : 도시 왕복하기 2

https://www.acmicpc.net/problem/2316

그런데 좀 더 발전한 문제가 있습니다. 여기서는 간선의 방향도 양방향으로 바뀐 것에 더해, 또 하나 고려해야 할 것이 있습니다. **각 정점도 한 번만 지날 수 있다**는 겁니다.

앞서 본 문제의 예제의 경우 다행히도 그냥 경로 두 개 찾았더니 이 조건도 만족했지만,

![image-20200916172340867](https://user-images.githubusercontent.com/58545240/93313731-cd5ad200-f843-11ea-9fcd-a2808eeaf309.png)

이런 형태의 그래프라면 답은 1인데, 간선 용량만 1로 둬서는 최대 유량이 2라고 판단해버립니다.

정점을 한 번만 지날 수 있다는 조건은 어떻게 구현할 수 있을까요?

그것은 **정점 하나를 2개의 정점으로 나눠서, 그 사이의 간선 용량을 1로 지정**해버리는 겁니다.

![image-20200916172353324](https://user-images.githubusercontent.com/58545240/93313764-d77cd080-f843-11ea-8376-709fdc902873.png)

각 정점이 이렇게 세포분열(?)을 해서, 하나는 들어오는 방향의 정점이고 하나는 나가는 방향의 정점이 되었습니다. 원래 정점 u에 대해 이들을 각각 u, u'라 칭한다면,

원래 양방향 간선 (u, v)가 있었다면 (u', v)와 (v', u) 이렇게 2개의 간선으로 분리시켜 주는 것입니다.

또한 (u, u') 간선도 추가시켜 주는데 이 간선의 용량이 반드시 1이어야 합니다. 이것이 이 u라는 정점을 한 번만 지날 수 있게 해 주는 역할을 합니다.

지금 추가되는 간선은 모두다 방향 간선입니다! 주의하세요.

또한, 시작점과 도착점에 한해서는 시작점으로 들어오는 간선이나 도착점에서 나가는 간선은 안 만들어도 됩니다. 만들어도 되지만요.

이 상태에서 최대 유량을 찾으면 중간의 (4, 4')를 항상 지나야 해서 1이 나옵니다.

```C++
#include <cstdio>
#include <vector>
#include <queue>
#include <algorithm>
using namespace std;
const int MAX_V = 800;
 
struct Edge{
    int to, c, f;
    Edge *dual;
    Edge(): Edge(-1, 0){}
    Edge(int to1, int c1): to(to1), c(c1), f(0), dual(nullptr){}
    int spare(){
        return c - f;
    }
    void addFlow(int f1){
        f += f1;
        dual->f -= f1;
    }
};
 
int main(){
    // 각 정점 n은 두 개의 정점 n*2-2, n*2-1로 나뉘어진다.
    int N, P;
    vector<Edge*> adj[MAX_V];
    scanf("%d %d", &N, &P);
    // 각 정점을 분리하고 사이에 용량 1인 간선 추가
    for(int i=0; i<N; i++){
        int u = i*2, v = u+1;
        Edge *e1 = new Edge(v, 1), *e2 = new Edge(u, 0);
        e1->dual = e2;
        e2->dual = e1;
        adj[u].push_back(e1);
        adj[v].push_back(e2);
    }
    // 간선을 입력받아 분리된 정점에 맞게 방향 간선 2개 추가
    for(int i=0; i<P; i++){
        int a, b;
        scanf("%d %d", &a, &b);
        a--; b--;
        Edge *e1 = new Edge(b*2, 1), *e2 = new Edge(a*2, 1);
        e1->dual = e2;
        e2->dual = e1;
        adj[a*2+1].push_back(e1);
        adj[b*2+1].push_back(e2);
    }
 
    // 최대 유량 구하기
    int total = 0, S = 1, E = 2;
    while(1){
        ...
    }
    // 결과 출력
    printf("%d\n", total);
}
```

소스 코드입니다.

정점 개수가 최대 800개이기 때문에, 2차원 배열로 c, f를 만들기에 무리가 있을 수 있습니다.

## - BOJ[5651] : Crucial Links

이 문제는 유량 그래프에서, **용량이 줄어들면 최대유량도 줄어들게 되는 간선**을 crucial link라 칭하고, 그러한 간선이 몇 개나 되는지를 찾으라는데요.

대체 이딴 걸 어떻게 풀까... 그런데 이 문제에서 은근히 친절한 제약이 많습니다. 총 용량 합이 20,000을 넘지 않는다던가...

일단 최대유량을 구하는 건 에드몬드 카프로 풀더라도, 시간복잡도는 O(VE^2)가 아니라 포드 풀커슨의 것이었던 **O(Ef)**가 됩니다. 네. 둘 중 작은 쪽이 시간복잡도가 되는 겁니다. 에드몬드 카프가 단순히 포드 풀커슨에서 경로만 빨리 찾는 변형이니까, 원래의 시간복잡도 O(Ef)보다는 나쁠 리가 없죠.



일단 최대유량을 찾은 후, 마지막 상태의 그래프에서 **포화 간선**을 찾습니다. 이건 가능한 한 많은 유량이 흐르고 있는, 즉 c[u][v] = f[u][v]인 간선 (u, v)를 말합니다.

그리고 각 포화 간선 (u, v)마다 용량을 1 줄여 보고, 그때 정점 u에서 다른 경로로 우회해서 v로 유량 1을 더 보낼 수 있는지 판단해 봅니다. 지금까지처럼 그냥 경로를 찾기만 하면 됩니다.

찾으면 그건 crucial link가 아니고, 못 찾으면 crucial link가 맞습니다. 이런 식으로 개수를 세면 됩니다.

## - BOJ[11495] : 격자 0 만들기

이 문제는 좀 어렵습니다. 그런데 이렇게 격자판 형태의 뭔가가 주어지면, 정점들을 체크판 무늬에 따라 양분해보는 아이디어를 시도할 수 있습니다.

![image-20200916172459829](https://user-images.githubusercontent.com/58545240/93313779-de0b4800-f843-11ea-8095-333ce7307712.png)


두 번째 예제에서 각 칸을 정점이라 하면 이렇게 양분할 수가 있는 겁니다.

이제 뭘 할까요? 일단 하는 연산이 인접한 두 칸을 고르는 것이므로, 여기서 항상 **파란색 정점 하나, 빨간색 정점 하나**를 고르는 꼴이 됩니다.

문제에서는 **최소 연산 횟수**를 구하라고 했고 이건 우리가 지금까지 구해온 **최댓값**과는 반대의 방향인데요.

근데 일단 그걸 무시하고, 인접한 정점 2개를 골랐을 때 **둘 다 1 이상인 한 최대 몇 번까지** 연산을 할 수 있는지를 구해봅시다. 그것은...

![image-20200916172510250](https://user-images.githubusercontent.com/58545240/93313792-e3689280-f843-11ea-97ca-ae23dbf9751e.png)

이렇게 표현할 수 있습니다. 아까 축사 배정 문제와 비슷한데, 이번엔 S, T와 이어진 간선 용량이 꼭 1은 아닙니다.

네. 그 용량은 바로, 반대편 정점의 위치에 적힌 값입니다!

그리고 가운데의 간선은 서로 인접할 때만 존재합니다. 각 정점의 두 값은 x, y좌표를 의미합니다. 열 번호, 행 번호 순입니다.

![image-20200916172519721](https://user-images.githubusercontent.com/58545240/93313818-e8c5dd00-f843-11ea-930d-1109e9a0ab24.png)

여기서 이런 경로로 유량을 1 보냈다는 말은?

좌표 (0, 0)과 (0, 1)을 묶어서 한 번 연산을 했다는 말입니다. 즉, **유량 1 당 한 번의 연산**입니다.

지금 구하려는 게, 연산을 할 때 둘 다 값이 1 이상 남아있어야 하는 것이므로 양쪽 정점과 S, T 사이에 여유가 있어야 하고 이건 맞습니다.



그럼 이 그래프에서 최대 유량을 구하면 그게 일단 답은 아니겠죠. 여기서 뭘 할 수 있을까요?

이런 식으로 유량을 흘려보내면서 그에 맞게 값을 감소시켜 갔다면, 격자판에 남아있는 0 초과의 값들은 절대 서로 인접하지 않은 상태일 겁니다.

따라서 이 남은 값들은 반드시 1 감소시키는 데 한 번의 연산을 해 줘야겠죠.



그렇습니다. 답은... **위 그래프의 최대 유량 + 남은 값들의 합**입니다.

최대 유량을 구한 행위가 쓸데없이 낭비하는 연산을 없게 하고 최대한 효율적으로 값들을 지워나갔을 때 몇 번의 연산이 필요한지를 구한 것이나 다름없어서, 그 횟수와 남은 수들을 처리하는 연산 횟수를 더하면 답이 되는 겁니다.

이 식을 변형하면, 원래 격자판에 있던 값들의 총합을 S라 하고 최대 유량을 F라 할 때 남은 값들의 합이 S-2*F이므로, F + S-2*F = **S - F** 또한 답이 됩니다.



어마무시하죠.

사실 플로우를 처음 배우고 응용문제를 푸는 건 정말 대단히 어렵고 불가능에 가까운 일입니다. 연습을 꽤 여러 번 하거나, 여러 번 공부하는 수밖에 없습니다.

저도 응용문제를 그나마 많이 풀게 되는 데 한 3번의 시도가 필요했고, 유명한 플로우 문제들은 구글링하면 풀이가 많이 나오므로 검색을 적극 활용합시다.

그나마 이게 플로우 문제일 확률이 높다는 단서를 던져주는 조건으로는 이런 게 있습니다.

"동시에 n명만 지날 수 있다", "n번까지만 쓸 수 있다"



일단, 대부분의 문제들은 최대한 단순히 생각해 봅시다. 정점이 좀 많아진다고 느껴도 의외로 빠른 시간 안에 답이 찾아질 수 있기 때문. 아래의 문제 중 상당수가 그러합니다.

물론 시간 초과가 나게 되는 문제들은 추후 업로드할 다른 알고리즘들을 사용해야겠지만요. 다행히 아직은 그런 문제가 많지는 않습니다. (올해 전대프연에 그런 문제가 2개나 나온 건 신경쓰지 맙시다.)

## 네트워크 유량 관련 문제

**6086번: Total Flow**

위에서 설명한 문제입니다.



**2188번: 축사 배정**

위에서 설명한 문제입니다.



**17412번: 도시 왕복하기**

위에서 설명한 문제입니다.



**2316번: 도시 왕복하기 2 (★)**

위에서 설명한 문제입니다.



**7616번: 교실로 가는 길 (★)**

도시 왕복하기 문제와 유사한데, 역시 이번에도 정점이건 간선이건 하나도 안 겹쳐야 합니다.

게다가 이번엔 최대 유량을 구하는 게 아니라, K개의 경로가 존재하느냐, 즉 **유량 K를 보낼 수 있느냐**를 묻는 문제입니다. 가능한지 불가능한지 직접 돌려보고 판단하면 됩니다.

그런데 그것도 모자라서, 가능하면 그때의 경로를 다 출력하라네요. 이건 유량을 흘려보낸 것과 반대로 할 수 있습니다.

소스에서 싱크로 유량이 흐르는 중인 어떤 경로를 찾고, 이 경로를 정점 번호가 중복되지 않게 잘 출력하면서 경로상의 유량을 다 없앱니다. 이걸 K번 반복하면 됩니다.



**5651번: Crucial Links (★)**

위에서 설명한 문제입니다.



**1658번: 돼지 잡기**

문제가 상당히 복잡한데, 각 날짜마다 손님의 정점과 모든 돼지우리의 정점을 싸그리 다 만들어서 **O(MN)**개 정점을 만들어 최대 유량을 구하면 됩니다. 정점 개수가 꽤 많은데도 시간 안에 잘 풀립니다.

![image-20200916172606051](https://user-images.githubusercontent.com/58545240/93313836-f3807200-f843-11ea-901f-84f386992357.png) 

예제에 해당하는 그래프입니다. 생각해보니 초기 우리에 대한 정점은 없어도 되겠네요.

여튼 이 그래프에서 유량 1을 소스에서 싱크로 흘려보내는 것이 돼지를 누군가에게 한 마리 파는 것과 같습니다. 값이 없는 간선의 용량은 다 ∞입니다.

소스에서 1일차의 돼지우리들로 초기에 있던 돼지 마릿수만큼 용량을 설정해주고, 각 손님 정점에서도 최대 살 수 있는 돼지 마릿수만큼의 용량을 갖고 싱크로 간선을 만들어 줍니다.

그리고 각 손님마다 원하는 돼지우리에서 올 수 있도록 간선을 만들고, 해당 돼지우리들끼리는 추가로 돼지를 재배치할 수 있도록 다음 날짜에 다른 우리로 가는 간선을 가능한 한 다 만들어주고...

지독한 그래프네요.



**11495번: 격자 0 만들기 (★)**

위에서 설명한 문제입니다.



**10319번: Avoiding the Apocalypse (★)**

일단 의료시설에서 모두 별도의 싱크 정점으로 향하는 간선을 만들어주고, 소스에서는 i번 정점으로 용량 g의 간선을 만들어주면 될 것 같은데...

간선마다 한 번에 통과할 수 있는 사람 수야 용량이라는 걸 쉽게 알 수 있지만, 문제는 지나는 시간.

이걸 구현하는 방법은 생각보다 쉽고 단순합니다. **각 정점을 시간 정보로 쪼개는 것.**

즉, 정점 u가 현재 시간 정보까지 포함하여 (u, 0), (u, 1), (u, 2), ... 등으로 쪼개어지는 겁니다.

간선 (u, v)가 용량 p를 갖고 있고 통과하는 데 시간 t가 걸린다고 할 때, **임의의 가능한 0 이상의 모든 시간 k에 대해서** 정점 (u, k)와 정점 (v, k+t)를 용량 p로 이어주면 됩니다.

또한 그자리에서 머무는 것도 가능하므로, 정점 (u, k)에서 정점 (u, k+1)로 용량 ∞의 간선도 만들어줍니다.

이렇게 그래프를 모델링하면 미친듯이 많은 개수의 정점이 생길 테니, 일단은 처음에 주어지는 시간제한 s를 잘 활용하여 각 정점마다 0~s, 즉 s+1개 정점으로만 쪼개주면 총 정점은 **O(sn)**개가 됩니다. 간선은 **O(sr)**개가 되겠네요.

거기다 최대 유량은 당연히 g니까, 이 문제의 시간복잡도는 **O(srg)**입니다. 100*1000*100 = 10^7. 놀랍게도 충분한 시간입니다;



**3666번: 리스크 (★)**

문제 해설이 모호할 수 있는데, 목표는 한 턴이 지난 후 적진과 인접한 모든 아군의 진영들 중 각각 주둔한 군대의 수 중 최솟값을 최대가 되게 하는 겁니다.

즉, 두 번째 예제에서 답이 4라는 것은 적진과 인접한 3, 4, 7번 진영 모두에 한 턴 이후 최소 4명씩 주둔시킬 수 있다는 말입니다. 물론, 다른 진영에도 1명 이상은 있어야 합니다.

**이분 탐색**입니다. 인접 지역에 각각 k명을 주둔시키는 것이 가능한지 판별하며, 최대의 k를 찾아야 합니다.

 ![image-20200916172632907](https://user-images.githubusercontent.com/58545240/93313851-f9765300-f843-11ea-996a-11a9c2069a3a.png)

k명을 주둔시키는 게 가능한지를 판별하는 유량 그래프는 다음과 같습니다.

정점 u, u'으로 나누어지는데, u'은 한 턴이 지난 후의 정점이라 보시면 됩니다.

간선 (S, u)는 원래 지역 u에 있던 군대 수, 간선 (u', T)는 u'가 적진과 인접해있지 않으면 1이고(최소 한 명은 남아있어야 하므로) 인접해있으면 k입니다.

그리고 두 지역 u, v가 인접해있으면 간선 (u, v'), (v, u')를 추가해 줍시다. 용량은 ∞.

여기서 **T로 들어가는 모든 간선이 포화가 되게 유량을 흘릴 수 있으면 가능**합니다.

이 그래프에서 유량이 의미하는 바는 원래 있던 군대를 다른 인접한 곳으로 이동시키는 것과 같겠습니다.

# **> 이분매칭**

번에 올릴 글은 네트워크 플로우 개념의 연장...은 아닌 것 같고,

유량 그래프의 아주 특수하면서 메이저한 형태 하나를 다룰 겁니다.

## - BOJ[2188] : 축사배정

https://www.acmicpc.net/problem/2188

저번 글에서 축사 배정 문제를 다뤘는데요.

![image-20200917172430877](https://user-images.githubusercontent.com/58545240/93448205-50e0f580-f90e-11ea-8cbb-b5448e0ccd4f.png)

이 문제의 유량 그래프 형태가 이러했고, 이런 형태가 상당히 특수하고 자주 나타난다고 말했는데, **(모든 간선 용량은 1입니다)**

여기서 왼쪽 열의 정점들은 모두 소스에서 갈 수 있고, 오른쪽 열의 정점들은 모두 싱크로 갈 수 있으며,

그 외의 간선은 모두 왼쪽 열에서 오른쪽 열로 가는 것들 뿐입니다. 이 그래프를 좀 바꾸면...

![image-20200917172443508](https://user-images.githubusercontent.com/58545240/93448253-58a09a00-f90e-11ea-91cb-c299bf942f92.png)

이런 형태로 축약하는 것이 가능합니다.

정점을 두 개의 그룹으로 나누었을 때, 존재하는 모든 간선의 양 끝 정점이 서로 다른 그룹에 속하는 형태의 그래프를 **이분 그래프**(bipartite graph)라고 하는데요.

이분 그래프에서 한쪽 그룹을 A, 다른 쪽 그룹을 B라 할 때

아까의 그림처럼 소스에서 각 A 정점으로 가는 간선, 각 B 정점에서 싱크로 가는 간선들이 추가되고(이 간선들의 용량은 모두 1) A, B 그룹 사이의 간선의 방향은 모두 A->B일 때

최대 유량을 구하는 문제를 **이분 매칭**(bipartite matching) 문제라고 부릅니다.



여기서 이분 매칭 문제의 답은, 축약된 이분 그래프에서 **매칭**(matching)의 최대 개수와 같습니다. 이걸 **최대 매칭**(maximum matching)이라 칭하기도 합니다.

매칭은 간선 하나를 선택하는 것인데, 이때 간선을 선택하면서 양 끝 정점도 같이 선택하는 것이나 마찬가지고, **각 정점은 한 번까지만 선택될 수 있습니다.**

따라서 위 그래프에서 간선 (A, 2), (A, 5)를 동시에 선택하는, 혹은 매칭시키는 것은 불가능합니다. A를 두 번 선택하게 되니까요.

각 정점을 한 번까지만 선택할 수 있는 조건은 소스, 싱크와 이어진 간선 용량이 모두 1이라는 점에서 구현됩니다.

지금 이분 매칭 문제를 표현하고 있는 이분 그래프에서 그려지지 않은 부분은 어차피 항상 같은 형태이기 때문에 생략한 겁니다.



이분 그래프만이 갖는 아주 단순한 구조와 거기서 파생되는 특성들 때문에, 최대 **O(VE)** 시간으로 빠르게 최대 매칭 개수를 구하는 최적화가 존재합니다. 여기서 V는 양쪽 그룹 중 큰 쪽의 크기라 합시다.

그냥 플로우 그래프로 두고 에드몬드 카프 알고리즘을 돌리면 min(O(VE^2), **O(Ef)**)인데, f가 최대 **O(V)**이므로 O(VE)의 시간복잡도가 발생하고 이와 동일합니다.



이분 그래프에서 왼쪽 그룹을 A, 오른쪽 그룹을 B라고 합시다.

포드 풀커슨이건 에드몬드 카프건, 일단 알고리즘을 돌리면 소스 s에서 시작하는 경로를 찾기 위해 첫 번째로 방문하는 노드는 A에 속하는 정점 중 하나일 겁니다. 이걸 a라 합시다.

그리고 a에서 방문 가능한 정점은 반드시 B에 속합니다. 이걸 b라 합시다.

b에서는 일단은 싱크 t로밖에 갈 수 없습니다. 기본적으로 경로는 s->a->b->t 꼴입니다.

그러나 b에서 음의 유량이 흐르는 경로를 찾아서 A에 속하는 다른 정점으로 갈 수도 있겠죠.

이게 반복되면 s->a->b->a'->b'->t, s->a->b->a'->b'->a''->b''->t, ... 식의 경로들이 발생 가능합니다. A, B에 속하는 정점들이 반드시 교차되어 나타납니다.

양쪽 끝의 s, t는 어차피 정해져 있으니까 생략해 버리고, 중간 과정을 최대한 간소화하자는 것이 아이디어입니다.

![image-20200917172456019](https://user-images.githubusercontent.com/58545240/93448265-5d654e00-f90e-11ea-96db-0681a21d06b1.png)

정점은 A 그룹의 것을 순서대로 훑으면서 아직 매칭이 안 된 애들이 있으면 매칭을 시도합니다.

또한 인접 리스트의 원소들(B 그룹에 속함) 역시 위부터 아래로 정렬되어 있다고 합시다.



맨 처음엔 (A, 2) 매칭이 바로 이어집니다.

![image-20200917172506716](https://user-images.githubusercontent.com/58545240/93448282-61916b80-f90e-11ea-8fee-5a1168ad127a.png)

그 다음, B의 인접 원소가 {2, 3, 4}인데 그 중 2가 이미 누군가와 매칭이 된 상태고 그 상대가 A인데,

A를 2 대신 다른 정점과 매칭시킬 수 있나 탐색했더니 가능합니다. 5와 매칭시킬 수 있네요.

그래서 매칭 (A, 2)가 소거되고 새로운 매칭 (B, 2), (A, 5)가 생성됩니다.



이때, 매칭을 하는 데 성공했다는 말은 반드시 현재까지에 이어 매칭 수를 1 증가시켰다는 말입니다.

만약 이런 식으로 원래 매칭 상대이던 애를 다른 애와 매칭시키는 식으로 짝을 다시 지어주는 것이 불가능하면 실패입니다.

![image-20200917172540695](https://user-images.githubusercontent.com/58545240/93448299-66eeb600-f90e-11ea-8bcf-6d497ec1341f.png)

그 다음, C는 그냥 바로 1과 잇습니다.

![image-20200917172552132](https://user-images.githubusercontent.com/58545240/93448393-8554b180-f90e-11ea-83cd-7a50df493fde.png)

D... 이놈이 1을 건드리니까 (C, 1)이 소거되고 C를 5와 매칭시키고,

역시 원래 매칭이던 (A, 5)가 사라지고 A는 다른 짝 2를 찾았으며, 그에 따라 (B, 2)도 사라지고...

그래도 다행히 B가 마지막으로 매칭 (B, 3)을 찾아서 매칭 재배치는 성공했습니다.



E의 경우, 매칭을 더 만들 수가 없습니다.

일단 유일한 인접원소가 2인데, 2와 매칭되어 있던 A를 대신 5와 매칭시키고,

5와 매칭되어 있던 C를 1과, 1과 매칭되어 있던 D를 2 또는 5와 매칭시켜야 하는데,

2는 이번에 이미 E와 매칭되어 있으므로 더 이상 매칭을 시킬 수 없고,

5 역시 이미 A와 매칭되어 있으므로 더 이상 매칭을 시킬 수 없습니다.

따라서 dead end가 발생하고 새로운 매칭을 형성시킬 수 없습니다.

만약 E의 인접원소가 더 있었다면 다른 원소와 매칭 시도를 해 볼 수도 있었겠지만, 그것조차 실패할 수도 있습니다.



이렇게 최종적인 답, 최대 매칭은 4입니다.

```C++
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;
const int MAX = 200;
 
// N: A 그룹 크기, M: B 그룹 크기
// A[i], B[i]: 각 정점이 매칭된 반대편 정점 번호
int N, M, A[MAX], B[MAX];
// adj[i]: A[i]와 인접한 그룹 B의 정점들
vector<int> adj[MAX];
bool visited[MAX];
 
// A그룹에 속한 정점 a를 이분 매칭시켜서 성공하면 true
bool dfs(int a){
    visited[a] = true;
    for(int b: adj[a]){
        // 반대편이 매칭되지 않았거나
        // 매칭되어 있었지만 원래 매칭되어 있던 정점을 다른 정점과 매칭시킬 수 있으면 성공
        if(B[b] == -1 || !visited[B[b]] && dfs(B[b])){
            A[a] = b;
            B[b] = a;
            return true;
        }
    }
    // 매칭 실패
    return false;
}
 
int main(){
    scanf("%d %d", &N, &M);
    for(int i=0; i<N; i++){
        int S;
        scanf("%d", &S);
        for(int j=0; j<S; j++){
            int k;
            scanf("%d", &k);
            adj[i].push_back(k-1);
        }
    }
 
    int match = 0;
    // 초기값: -1
    fill(A, A+N, -1);
    fill(B, B+M, -1);
    for(int i=0; i<N; i++){
        // 아직 매칭되지 않은 그룹 A 정점에 대해 매칭 시도
        if(A[i] == -1){
            // visited 배열 초기화
            fill(visited, visited+N, false);
            if(dfs(i)) match++;
        }
    }
    printf("%d\n", match);
}
```

소스 코드는 상당히 짧은 편입니다.

## - BOJ[9576] : 책 나눠주기

https://www.acmicpc.net/problem/9576

비슷한 문제는 엄청나게 많습니다.

이 문제의 경우는 각 학생마다 선택지가 구간으로 주어졌을 뿐, 그 외는 축사 배정 문제와 동일합니다.

다만 이 문제의 경우 그래프가 완전 이분 그래프에 가까울수록 시간이 많이 걸릴 것인데,

그렇게 빡빡한 그래프는 주어지지 않는 것으로 보입니다. 단순한 이분 매칭으로 충분히 풀립니다.

## - BOJ[11375] : 열혈강호

https://www.acmicpc.net/problem/11375

이 문제 또한 축사 배정 문제와 완전히 똑같습니다.

이렇게 이분 매칭의 문제 구조 자체가 엄청나게 단순하다 보니, 그냥 정말 뻔하게 뭘 서로 매칭시키는 문제는 풀기가 쉽습니다.

그래서 이분 매칭 문제들은 약간 형태가 변형되거나, 자신이 이분 매칭 문제임을 어느 정도 숨기기도 합니다.

## - BOJ[11376] : 열혈강호 2

https://www.acmicpc.net/problem/11376

이 문제의 경우, 각 직원이 최대 한 개가 아니라 **두 개의 일**을 할 수 있다고 합니다.

여태까지는 모든 정점은 매칭에 한 번만 포함될 수 있었는데, 이 규칙이 깨지다니?? 어떻게 해야 하죠?

답은 의외로 간단합니다. **각 직원마다 정점을 2개씩 만드는 겁니다.**

![image-20200917172731099](https://user-images.githubusercontent.com/58545240/93450557-1462c900-f911-11ea-986d-19f0704ab12c.png)

![image-20200917172745558](https://user-images.githubusercontent.com/58545240/93450573-17f65000-f911-11ea-8fbe-17c06b57a786.png)

예제 그래프입니다. 답은 4가 됩니다

## - BOJ[11377] : 열혈강호 3

https://www.acmicpc.net/problem/11377

이 문제는 좀 더 트리키합니다. N명 중 K명이 최대 2개의 일을 할 수 있는데, 그 K명이 누구인지는 상관없습니다.

제일 처음에 생각해볼 수 있는 방법은 열혈강호 2 문제처럼 각 직원마다 정점을 2개로 분리하고, 유량을 흘리다가 N+K개가 되면 멈추는 것입니다.

그러나 이 경우, 만약 N=5, K=3일 때 1, 2, 3, 4번 직원이 2개씩 일을 해서 유량이 8이 될 수도 있는데 이때는 2개의 일을 하고 있는 직원이 4명이므로 잘못된 경우가 됩니다. 이래서는 안 됩니다.



각 직원을 2개의 정점으로 분할하였을 때, 첫 번째 정점 그룹을 P, 두 번째 정점 그룹을 Q라 합시다.

일단 맨 처음에는 P 그룹의 N개 정점들에 대해서만 최대 매칭을 구합니다.

그 다음, Q 그룹의 N개 정점들이 대해서만 또다시 최대 매칭을 구하는데, 이때 Q 그룹에서 매칭이 K개 발생하면 중단합니다. 그때의 총 매칭 개수가 답입니다.

이것이 성립하는 이유는, Q 그룹에서 매칭을 새로 찾다가 원래 매칭이 있던 P 그룹의 정점이 매칭이 없어지는 일이 절대 없기 때문입니다. 이건 보통의 이분 매칭 그래프에서도 성립합니다. 있던 매칭을 끊고 다른 매칭을 찾는 데 성공했으면, **원래 있던 매칭의 양 끝 정점도 마지막엔 새로운 매칭에 포함될 수밖에 없죠.**

따라서 Q 그룹에서 매칭이 K개가 발생하는 순간 중단하면, 일을 2개 하는 직원이 K명 이하라는 조건을 지킬 수 있습니다.



이제부터는 자기가 이분 매칭이 아니다! 라고 위장하고 있는 문제들이나, 좀 어려운 문제들입니다.

## - BOJ[3295] : 단방향 링크 네트워크

https://www.acmicpc.net/problem/3295

이 문제의 경우, 각 정점을 다 2개로 나눠서 이분 매칭을 시도하면 되는데 도대체 왜냐면,

이 문제에서 하라는 행동을 잘 살펴보면, 겹치지 않는 링과 선형 배열이 만족하는 공통점이 있습니다.

바로, 어떤 정점이 있다면 절대 **indegree나 outdegree가 2 이상일 수 없다**는 겁니다.

따라서 모든 정점을 나가기만 하는 정점 그룹 A, 들어오기만 하는 정점 그룹 B로 분리하고,

모든 방향 간선 (u, v)에 대해 u가 A, v가 B에 속한다고 하면 모든 정점이 매칭에 2번 이상 선택되지 않는 최대 매칭과 동치가 됩니다.

## - BOJ[1671] : 상어의 저녁식사

https://www.acmicpc.net/problem/1671

이 문제도 상당히 유사합니다. 상어를 잡아먹는 쪽 정점과 잡아먹히는 쪽 정점으로 분류하면,

(일단은 최대 2마리까지 잡아먹을 수 있다는 건 보류합니다)

![image-20200917173508372](https://user-images.githubusercontent.com/58545240/93450676-33f9f180-f911-11ea-9b84-d7ba03d4dee2.png)

예제를 이렇게 나타낼 수 있습니다. 매칭이 의미하는 것은 왼쪽 정점이 오른쪽 정점을 먹었다는 겁니다.

![image-20200917173742727](https://user-images.githubusercontent.com/58545240/93450693-39573c00-f911-11ea-81d9-f1d698fc0398.png)

이 두 매칭은 2번 상어가 4번 상어를 먹고, 또 4번 상어가 1번 상어를 먹었다는 의미인데요.

이 매칭의 순서는 상관이 없습니다. 4번이 잡아먹기도, 잡아먹히기도 하는데,

문제에서 구하고자 하는 게 살아남는 상어의 최소 마릿수이기 때문에 **잡아먹을 수 있는 한 최대한 많이 잡아먹게 만드는 게 목표**입니다. 그러고 남은 상어 마릿수를 세는 거죠.

따라서 이 경우, 만약 4번이 1번을 먹기 전에 2번이 4번을 먹어버리면 1번 상어가 살아남을 수도 있지만(최대 2마리만 먹을 수 있다는 조건 때문에),

우리의 목적을 이루기 위해 이럴 때는 **무조건 약한 놈이 먼저 더 약한 상어를 먹어치우게 하는 순서**로 가야 합니다. 즉, 1번이 4번에게 먹힌 후 4번이 2번에게 먹혀야 합니다.



따라서 이렇게 연쇄적인 매칭이 일어나도 이렇게 순서를 어떻게든 재배열하여 매칭에 속한 오른쪽의 모든 상어가 잡아먹히게 만들 수 있습니다.

또한 각 상어가 최대 2마리까지 먹을 수 있다는 조건을 위해, 왼쪽 정점을 열혈강호 2 문제처럼 2개로 분열시키면 됩니다.



마지막으로 주의해야 하는 예외는 **완전히 능력치가 동일한 상어가 여러 마리 존재할 때**입니다. 이 경우는 잘못하면 서로가 매칭되어서 둘 다 사라져버릴수도;

이때는 무슨 순서를 매겨서 순서가 앞인 놈만 다른 놈들을 잡아먹을 수 있도록 예외처리를 해야 합니다. 뭐... 입력받는 순서가 제일 적당하겠죠.

## - BOJ[9525] : 룩 배치하기

https://www.acmicpc.net/problem/9525

이 문제도 살펴봅시다. 이제부터 좀 더 굉장합니다.

폰이나 벽이 나오기 전까지의 자신의 상하좌우 빈칸 모두로 이동할 수 있는 룩들을 최대한 많이 배치할 건데, 이들이 서로 이동경로가 하나도 겹치면 안 됩니다.



일단 처음 알 수 있는 어찌보면 당연한 성질은, 하나의 일렬로 된 빈칸 행 중에서는 **최대 한 군데**에만 룩을 배치할 수 있습니다. 이건 열 또한 마찬가지죠.

그런데, 어떤 칸에 룩을 배치한다고 해봅시다. 그렇다면 이 칸을 포함하는 일렬로 된 빈칸 행과, 일렬로 된 빈칸 열에는 더 이상 룩을 배치할 수 없습니다.

이걸 잘 변형시켜 보면, 각 일렬로 된 빈칸들이 정점일 때, **어떤 칸에 룩을 배치하는 것이 자신을 포함하는 두 빈칸 정점을 매칭하는 것**이고, 각 빈칸 정점들은 최대 1개의 매칭만을 가질 수 있게 됩니다.

![image-20200917174430416](https://user-images.githubusercontent.com/58545240/93450707-3d835980-f911-11ea-9312-3aea3a9a3636.png)

이렇게 예제의 맵에서 정점들을 추출할 겁니다.

파란색이 A 그룹, 연속한 빈 공간 행이고, 빨간색이 B 그룹, 연속한 빈 공간 열입니다.

이제 겹치는 영역끼리 간선을 서로 추가해 주고, 그 간선은 모두 딱 하나의 칸에 대응될 겁니다.

그 간선을 뽑아 매칭시키는 것은 그 대응하는 칸에 룩을 배치하는 것이죠.

![image-20200917174446427](https://user-images.githubusercontent.com/58545240/93450746-4aa04880-f911-11ea-9e00-0893dc340efa.png)

그 이분 그래프는 이런 형태가 됩니다!! 두둥!!

## - BOJ[1348] : 주차장

https://www.acmicpc.net/problem/1348

이 문제는 또 어떨까요? 꽤나 어려운 문제 중 하나입니다.

일단 이분 매칭이 정해라는 걸 안다는 가정하에, 어떻게 이분 매칭을 도입할 수 있을지 봅시다.

당연히 존재하는 게 차와 주차 구역이니 각각을 매칭시키는 것이 답이겠지요.

각 주차 구역에는 차가 한 대밖에 들어갈 수 없으니까요.



이때 문제는 모든 차가 주차하는 데 걸리는 최소 시간입니다.

최소 시간을 구하기 전에, **k초 안에 모든 차가 주차 가능한지**를 판단할 수 있을까요?

이때는 차와 주차 구역을 이을 때, 둘 사이의 거리가 k 이하일 때만 잇습니다.

이렇게 이분 그래프를 만든 후 최대 매칭이 차의 개수이면 가능하다는 것이겠죠.

그렇습니다. k를 **이분 탐색**으로 찾는 겁니다.

모든 차와 주차 구역 사이의 거리는 BFS로 전처리하여 빠르게 구해둡니다.



이분 매칭 문제를 여러 개 살펴봤는데, 처음엔 쉬운 것 같으면서도 나중엔 굉장히 당황스러운 문제들이 많습니다.

역시, 기본은 쉬운데 이녀석도 어려워지면 충분히 어려워질 수가 있네요.



아, 이분 매칭의 시간복잡도가 O(VE)였죠. 가끔 이 시간복잡도로 시간 안에 해결할 수 없는 거대한 이분 그래프가 주어지는 문제들이 간혹 있는데요.

이건 역시 나중에 이분 그래프에 대해서 최대 매칭을 좀 더 빠르게 찾아주는 알고리즘과 함께 살펴보도록 합시다.

## 이분매칭 관련 추천 문제

**2188번: 축사 배정**

위에서 설명한 문제입니다.



**11375번: 열혈강호**

위에서 설명한 문제입니다.



**9576번: 책 나눠주기**

위에서 설명한 문제입니다.



**1298번: 노트북의 주인을 찾아서**

이 또한 주는 문제입니다.



**11376번: 열혈강호 2**

위에서 설명한 문제입니다.



**11377번: 열혈강호 3**

위에서 설명한 문제입니다.



**1017번: 소수 쌍 (★)**

유명한 문제입니다. 모든 자연수들을 **홀수 그룹**과 **짝수 그룹**으로 나눕니다.

1이 두 번 존재하지는 않으므로, 서로 다른 두 수를 더해서 나올 수 있는 소수인 수는 반드시 홀수여야만 하고, 그러려면 반드시 홀수와 짝수를 더해야 합니다. ~~소름 끼친다;~~

따라서 홀수 그룹 정점 u와 짝수 그룹 정점 v가 있을 때 u+v가 소수일 때 둘 사이에 간선을 추가한 후 이분 매칭입니다.

이때, 첫 번째 수와 가능한 모든 매칭을 다 해 보면서, 각각 최대 매칭이 N/2인지 판별하면 됩니다.

N이 홀수일 수도 있는 것으로 압니다. 이러면 당연히 걍 불가능.



**9577번: 토렌트 (★)**

정점으로 만들어야 할 것은 **조각**과 **단위시간**입니다.

1~n번 조각이 그룹 A, 0~1, 1~2, 2~3, ... 등의 단위시간이 그룹 B에 속합니다.

이제 각 조각마다 받을 수 있는 단위시간과 연결하여 이분 그래프를 만든 후,

**가능한 한 가장 빠른 시간 정점부터 방문해가며** 이분 매칭을 시도합니다.

![image-20200917174802578](https://user-images.githubusercontent.com/58545240/93450768-4f64fc80-f911-11ea-9f0a-869a97fdc581.png)

입력

**3 2**

**1 3 1 1**

**0 2 2 2 3**

의 예시입니다. 오른쪽이 시간 정점인데, k는 k-1~k초를 뜻합니다.



마지막에 최대 매칭이 N 미만이면 불가능합니다.

가능하다면, 매칭 정점 배열을 참조하여 가장 마지막으로 무언가를 받은 시간을 출력하면 됩니다.



**3295번: 단방향 링크 네트워크 (★)**

위에서 설명한 문제입니다.



**1671번: 상어의 저녁식사 (★)**

위에서 설명한 문제입니다.



**1574번: 룩 어택**

룩 배치하기 문제보다 쉽습니다. 이번엔 폰이 아니라 빈칸이 주어지는데, 빈칸엔 룩을 배치할 수 없다 뿐이지 건너편에도 룩이 없어야 합니다.

따라서 정점이 항상 행 개수와 열 개수라, 정점을 일일이 만드는 난잡한 전처리가 필요하지 않아서 더 쉽습니다.



**9525번: 룩 배치하기 (★)**

위에서 설명한 문제입니다.



**2570번: 비숍 2 (★)**

비숍은 대각선으로만 움직일 수 있습니다. 방향만 다를 뿐 룩 배치하기 문제와 완전히 같습니다.

다만 전처리 과정이 좀 더 머리 아파질 듯...



**1348번: 주차장 (★)**

위에서 설명한 문제입니다. **이분 탐색**입니다.

# **> SCC**

> Strongly Connected Component
>
> 강한 연결 요소

**방향 그래프**에서 임의의 두 정점 `u`, `v`가 있을 때 `u` -> `v`로 가는 경로가 존재 한다면 그 그룹이 바로  **`SCC`**입니다.

이 때, `u` -> `v`로 가는 경로는 **직/간접적인 경로**를 의미합니다.

**즉,  `SCC`는 집합 내 정점들이 서로 왕복 가능한 최대 크기의 집합**을 의미합니다.

## SCC의 특징

1. **같은 SCC**내에서 뽑은 임의의 `u`, `v` 점에서 `u` -> `v` 혹은 `v` -> `u`의 경로는 항상 **존재**한다.

2. **서로 다른 SCC**에서 뽑은 임의의 `u`, `v` 점에서 `u` -> `v` 혹은 `v` -> `u`의 경로는 **존재하지 않는다.**

   => *서로 다른 `SCC`끼리는 사이클이 존재 하지 않는다!*

3. SCC는 **Maximal한 성질**을 가지고 있어 SCC가 형성 된다면 항상 형성될 수 있는 **가장 큰 집합**으로 형성이 된다.

![image-20210512133449789](https://user-images.githubusercontent.com/58545240/117945501-5978b700-b349-11eb-8a43-001dd4573fbe.png)

예를 들어, 오른쪽 `SCC`인 `{c, d, h}`의 하위 집합 중 `{c, d}` 역시 첫 번째 성질은 만족하지만, 여기에 정점 `h`를 더 추가해도 여전히 성질이 만족되므로 `h`는 반드시 추가되어 있어야 합니다.

이렇게 **유향 그래프(DG)** 가 주어지면 파티션을 분할하여 각각이 `SCC`가 되도록 하는 것이 항상 가능하며, 선형 시간, 즉 **O(N)** 안에 모든 `SCC`를 분리하는 것이 가능합니다.

또, 싸이클을 이루는 정점들 사이에서도 서로 항상 도달이 가능하다는 존재 덕분에, `SCC`는 싸이클보다도 더 상위으, 더 포괄적인 개념입니다. `{a, b, e}`나 `{f, g}`만 본다면 단순 싸이클이지만, `{c, d, h}` 쪽은 그렇지 않은 것을 보면 알 수 있습니다.

또, 이것이 무향 그래프 였다면 컴포넌트 자체가 `SCC`라고 볼 수 있기 때문에 유향 그래프에만 이 용어가 유의미 합니다.

그러면 방향그래프가 주어졌을 때, 어떤 정점들이 서로 `SCC`를 이루는 지 분류 할 수 있는 두 가지 알고리즘을 소개하갰습니다. 이 알고리즘 모두 **DFS**를 기반으로 동작합니다.

## 코사라주 알고리즘

먼저 **코사라주 알고리즘**을 수행하기 위해서는

1. 방향 그래프
2. 역방향 그래프
3. 스택

이렇게 세 가지 컨테이너를 준비한 뒤 다음과 같은 순서로 진행합니다.

1. 모든 정점에 대해 정방향 그래프를 DFS를 수행하며 **끝나는 순서**대로 스택에 삽입합니다.
   1. 방문하지 않은 정점이 있는 경우에는 해당 정점부터 다시 DFS를 수행한다.
   2. 이로써 모든 정점을 방문하며 DFS를 완료하여, 스택에 모든 정점을 담는다
2. 스택의 top에서 부터 `pop()`을 진행하며 순서대로 역방향 그래프에서 DFS를 수행하며 한번 수행에 탐색되는 모든 정점들을 같은 SCC로 묶습니다.
   1. 이 과정은 스택이 빌 때까지 진행합니다.
   2. 만약 스택의 top에 위치한 정점이 이미 방문했다면 `pop()`만 합니다.

### - BOJ[2150] : Strongly Connected Component

그러면 `SCC`의 가장 기초적인 문제인 백준의 2150번을 풀어보겠습니다.

방향 그래프와 역방향 그래프를 생성합니다.

그 후 방향 그래프에 대해 dfs를 수행하면서 종료되는 점부터 스택에 해당 정점을 push 합니다.

그리고 스택에서 하나씩  pop하면서 역방향 그래프의 dfs를 수행하고 여기서 pop한 요소와 만나는 정점들은 모두 SCC를 형성하는 그룹이 됩니다.

역방향 그래프에 대해서 dfs를 수행하 ㄹ때는 결과값을 담아야 하고

출력 시에는 SCC 그룹 내 요소가 오름차순을 유지하기 위해서 `Collections.sort()`를 이용하였고, SCC 그룹의 첫번째 요소가 작은 순서대로 출력하기 위해 `TreeMap`을 사용합니다.

```JAVA
import java.io.*;
import java.util.*;
public class Main {
    static List<List<Integer>> graph;
    static List<List<Integer>> rgraph;
    static List<List<Integer>> res;
    static boolean[] visited;
    static Stack<Integer> stack;
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        StringTokenizer st = new StringTokenizer(br.readLine());
        
        int V = Integer.parseInt(st.nextToken());
        int E = Integer.parseInt(st.nextToken());
        
        graph = new ArrayList<>();
        rgraph = new ArrayList<>();
        res = new ArrayList<>();
        
        for (int i = 0; i <= V; i++) {
            graph.add(new ArrayList<>());
            rgraph.add(new ArrayList<>());
            res.add(new ArrayList<>());
        }
        
        // 단방향 인접리스트 구현 (방향 , 역방향 그래프)
        for (int i =  0; i < E; i++) {
            st = new StringTokenizer(br.readLine());
            
            int u = Integer.parseInt(st.nextToken());
            int v = Integer.parseInt(st.nextToken());
            graph.get(u).add(v);
            rgraph.get(v).add(u);
        }
        
        visited = new boolean[V + 1];
        stack = new Stack<>();
        
        // 방향 그래프에 대해 dfs 수행
        for (int i = 1; i <= V; i++) {
            if (!visited[i]) {
                dfs(i);
            }
        }
        
        Arrays.fill(visited, false);
        int groupNum = 0;
        // 역방향 그래프에 대해 dfs 수행
        while (!stack.isEmpty()) {
            int start = stack.pop();
            
            // 스택에서 하나씩 꺼내면서!
            // 이 때 방문 체크가 된 것은 start가 하나의 SCC그룹에 속해있다는 뜻!
            if (visited[start]) {
                continue;
            }
            
            // 같은 그룹끼리(groupNum으로 분류) SCC를 분류한다.
            redfs(start, groupNum);
            groupNum++;
        }
        StringBuilder sb = new StringBuilder();
        // SCC 그룹 개수
        sb.append(groupNum + "\n");	
        
        // key를 기준으로 오름차순 정렬하기 위한 TreeMap 선언
        TreeMap<Integer, Integer> tm = new TreeMap<>();
        for (int i = 0; i < groupNum; i++) {
            // 각각의 SCC 그룹에 대해 오름차순 정렬한다.
            Collections.sort(res.get(i));
            // key : SCC그룹의 첫째 항
            // value : index
            tm.put(res.get(i).get(0), i);
        }
        
        // map의 value를 이용하여 첫번째 항이 작은 순서대로 출력 (오름차순)
        tm.keySet().forEach(key -> {
            int value = tm.get(key);
            
            for (int now : res.get(value)) {
                sb.append(now + " ");
            }
            sb.append("-1\n"); // 문제조건에 따라 끝에 -1 붙이기
        });
        
        bw.write(sb.toString());
        bw.flush();
        bw.close();
    }
    
    // 끝나는 점에 대해서 stack에 push
    static void dfs(int start) {
        visited[start] = true;
        
        for (int cur : graph.get(start)) {
            if (!visited[cur]) {
                dfs(cur);
            }
        }
        stack.push(start);
    }
    
    // 같은 SCC 그룹은 groupNum으로 분류한다.
    // 결과값을 담는 res 코드가 추가된다.
    static void redfs(int start, int groupNum) {
        visited[start] = true;
        res.get(groupNum).add(start);
        
        for (int cur : rgraph.get(start)) {
            if (!visited[cur]) {
                redfs(cur, groupNum);
            }
        }
    }
}
```



## 타잔 알고리즘

타잔 알고리즘은 DFS를 수행할 때 생성되는 DFS 트리의 간선의 정보를 이용해서 ALL DFS 한번으로 모든 `SCC`를 구하는 방법입니다.

ALL DFS란 모든 정점에서 수행되는 DFS를 의미합니다.

1. ALL DFS를 돌리며 **Spaning Tree**를 만들어 갈 때 DFS의 호출 순서에 따라 정점을 stack에 push합니다.
2. 간선 분류를 통해 먼저 호출 되는 정점이 더 높은 위치를 가진다고 생각할 때 가장 높이 올라갈 수 있는 정점을 찾습니다.
3. 이 때 `here` -> `there`이 교차간선이지만 `there`이 아직 `SCC`에 속하지 않는다면 discover[there]을 고려해줍니다.
4. DFS가 끝나기 전에 ret과 discover[`here`]가 같다면 stack에서 pop하면서 `here`가 나올 때까지 같은 `SCC`로 분류합니다.

*타잔 알고리즘은 **위상정렬**을 이용한 방법으로 생성되는 `SCC`들은 위상정렬의 역순으로 생성된다*

타잔 알고리즘을 말로 설명하는 것은 힘든 부분이 있기 때문에, 

https://m.blog.naver.com/PostView.nhn?blogId=kks227&logNo=220802519976&referrerCode=0&searchKeyword=scc 

혹은

https://m.blog.naver.com/PostView.nhn?blogId=ndb796&logNo=221236952158&proxyReferer=https:%2F%2Fwww.google.com%2F

이곳을 참조해보면 좋을 것 같습니다.

위에서 알아본 `2150`번 문제를 타잔알고리즘으로 다시 알아보겠습니다.

```java
import java.io.*;
import java.util.*;
public class p2150_ver2 {
    static List<List<Integer>> graph;
    static List<List<Integer>> res;
    static int cnt = 0, groupNum = 0;
    static int[] dfsn, sn;
    static boolean[] finished; // SCC가 확정된 정점 판별
    static Stack<Integer> stack;
    
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        StringTokenizer st = new StringTokenizer(br.readLine());
        
        int V = Integer.parseInt(st.nextToken());
        int E = Integer.parseInt(st.nextToken());
        
        dfsn = new int[V + 1];
        sn = new int[V + 1];
        graph = new ArrayList<>();
        res = new ArrayList<>();
        
        for (int i = 0; i <= V; i++) {
            graph.add(new ArrayList<>());
            res.add(new ArrayList<>());
        }
        
        // 단방향 인접리스트 구현 (방향 , 역방향 그래프)
        for (int i =  0; i < E; i++) {
            st = new StringTokenizer(br.readLine());
            
            int u = Integer.parseInt(st.nextToken());
            int v = Integer.parseInt(st.nextToken());
            graph.get(u).add(v);
        }
        
        finished = new boolean[V + 1];
        stack = new Stack<>();
        
        // 방향 그래프에 대해 dfs 수행
        for (int i = 1; i <= V; i++) {
            if (dfsn[i] == 0) {
                dfs(i);
            }
        }

        StringBuilder sb = new StringBuilder();
        // SCC 그룹 개수
        sb.append(groupNum + "\n");	

        // key를 기준으로 오름차순 정렬하기 위한 TreeMap 선언
        TreeMap<Integer, Integer> tm = new TreeMap<>();
        for (int i = 0; i < groupNum; i++) {
            // 각각의 SCC 그룹에 대해 오름차순 정렬한다.
            Collections.sort(res.get(i));
            // key : SCC그룹의 첫째 항
            // value : index
            tm.put(res.get(i).get(0), i);
        }

        // map의 value를 이용하여 첫번째 항이 작은 순서대로 출력 (오름차순)
        tm.keySet().forEach(key -> {
            int value = tm.get(key);
            
            for (int now : res.get(value)) {
                sb.append(now + " ");
            }
            sb.append("-1\n"); // 문제조건에 따라 끝에 -1 붙이기
        });
        
        bw.write(sb.toString());
        bw.flush();
        bw.close();
    }
    
    // 각 정점에 대해 dfs 수행
    static int dfs(int start) {
        dfsn[start] = ++cnt; // 노드 마다 고유한 SCC 번호를 할당한다.
        stack.push(start); // 스택에 자기 자신을 삽입
        
        // 자신의 dfs, 자식들의 결과나 dfsn 중 가장 작은 번호를 result에 저장
        int parent = dfsn[start];
        for (int next : graph.get(start)) {
            // 아직 방문하지 않은 이웃에 대하여
            if (dfsn[next] == 0) {
                parent = Math.min(parent, dfs(next));
            } 
            // 방문은 했으나, 아직 SCC로 추출되지 않은 이웃
            else if (!finished[next]) {
                parent = Math.min(parent, dfsn[next]);
            }
        }

        // 부모노드가 자기 자신일 경우
        // 자신과 자신의 자손들이 도달 가능한 제일 높은 정점이 자신일 경우 SCC 추출
        if (parent == dfsn[start]) {
            while (true) {
                int t = stack.pop();
                finished[t] = true;
                sn[t] = groupNum;
                res.get(groupNum).add(t);
                
                if (t == start) break;
            }

            groupNum++;
        }
        
        // 자신의 부모값을 반환
        return parent;
    }
}
```





이러한 **`SCC(강한 연결요소)`**는 그 자체로는 큰 의미가 없고, **위상정렬**과 함께 생각해보았을 때 큰 의미가 있습니다. 모든 `SCC`를 각 정점으로 고려했을 때 각 SCC를 위상 정렬할 수 있음을 인지합시다.

![image-20210512144050417](https://user-images.githubusercontent.com/58545240/117945542-63021f00-b349-11eb-9cb7-81cb3d0be5f9.png)

## SCC 관련 추천 문제

**2150번: Strongly Connected Component**

위에서 설명한 문제입니다. SCC 기본 문제죠.



**10265번 : MT**

동기들을 SCC로 분류하면됩니다.



**6543번: The Bottom of a Graph**

outdegree가 0인 SCC에 속하는 정점들만 출력하면 됩니다.



**4196번: 도미노**



**3977번: 축구 전술**

이번엔 indegree가 0인 SCC가 단 1개만 있어야 합니다. 그렇지 않으면 confunsed입니다.

답이 존재한다면, 그 SCC에 포함된 원소들을 출력해주면 됩니다.



**2152번: 여행 계획 세우기**

ATM 문제와 비슷한데, 이번엔 도착점이 단 하나이고, 각 정점에 서로 다른 값이 있지 않고 다 1이 있다고 생각하시면 됩니다.

같은 SCC에 속한 도시들이 있으면 그 중 하나만 방문해도 나머지를 다 방문할 수 있죠.

따라서 각 SCC의 값을 정점 개수로 두고, SCC 단위로 위상 정렬하여 시작점을 포함한 SCC로부터 방문해올 수 있는 최대 마을 개수를 SCC마다 구하는 식으로 문제를 풉니다.



**4013번: ATM**

위에서 설명한 문제입니다.



**11097번: 도시 계획 (★)**

일단 도시들을 갖고 SCC를 뽑은 뒤, 각 SCC마다 제일 큰 단순 싸이클의 경로 하나만 출력하고,

서로 다른 SCC U, V에 대해 U에서 V로 가는 경로를 하나만 출력해주면 됩니다.

원래의 간선 정보는 잃어버렸고, 리스트에 쓰인 건 도달가능성 뿐이므로 원래 있던 간선인지 아닌지는 아무 상관이 없죠.



**1108번: 검색 엔진 (★)**

링크를 간선으로 나타내고 각 사이트를 SCC 단위로 묶습니다.

그리고 압축, 위상 정렬 후... 이번엔 SCC 단위로 방문하는 게 아니라, SCC 방문 순서는 위상 정렬 순서대로 하되, SCC 대신 SCC를 이루는 모든 정점을 한번씩 방문해야 합니다.

처음엔 모든 사이트의 점수를 1점으로 놓고 시작합니다. 그리고 방문하면서 자신의 점수를 next 정점에 더하는데, 안 더하는 조건이 자신과 next가 같은 SCC 안에 있을 때입니다.

답이 int 범위를 넘어갈 수도 있습니다.



**6264번: Sub-dictionary (★)**

이 문제는 지금까지와는 좀 다릅니다. 단어 u를 익히는 데 단어 v의 뜻이 필요하다고 할 때 간선 (u, v)를 모아서 그래프를 모델링하면,

이번엔 단어 u만 알면 같은 SCC의 단어를 다 알 수 있는 게 아니고, **단어 u를 알려면 같은 SCC 안의 나머지 단어를 다 알아야 합니다.**

이번에도 단어 단위로 익혔는지를 체크하는 bool 배열을 만들고, 이게 다 true가 되도록 각 단어들을 SCC DAG에서 위상 정렬 순으로 방문해야 합니다.

일단 indegree가 0인 SCC들은 어쩔 수 없이 포함된 단어를 모두 가르쳐야 합니다.

그리고 다른 SCC의 단어들의 경우, 어떤 단어를 배우는 데 학습했어야 하는 단어들을 모두 익혔다면 그 단어는 익힐 필요가 없고, 아니면 그 단어도 익혀야 하고...

이런 식으로 처리해줘야 할 것이 상당히 까다로운 편입니다.