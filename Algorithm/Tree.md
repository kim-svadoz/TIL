



# Tree :fist_oncoming:

# **> 트리와 이진트리 기본**

---

## 트리(Tree)

- 계층적인 구조를 표현하기 위해 사용하는 자료구조
  - 조직도
  - 디렉토리와 서브디렉토리 구조
  - 가계도

## 용어

- 루트(Root)
  - 트리는 노드(node)들과 노드들을 연결하는 링크(link)들로 구성된다.
  - 맨 위의 노드를 루트라고 한다.
- 부모-자식(parent-child) 관계
  - 각 노드들의 상하 관계를 부모-자식(parent-child)관계로 나타낸다.
- 형제 관계(sibling)
  - 루트노드를 제외한 트리의 모든 노드들은 유일한 부모노드를 가진다.
  - 부모가 동일한 노드들을 형제관계라고 부른다.
- 리프(leaf) 노드
  - 자식이 없는 노드들을 leaf 노드라고 부른다.
  - 리프노드가 아닌 노드들을 내부(internal)노드라고 부른다.
- 조상-자손(ancestor - descendant) 관계
  - 부모-자식관계를 확장한 것이 조상-자손 관계이다.
- subtree
  - 트리의 특성상 한 노드의 자손노드들의 집합도 트리이다.
  - 트리에서 어떤 한 노드와 그 노드의 자손들로 이루어진 트리를 subtree라고 한다.
- 레벨(level)
  - root 노드는 level 1
  - root 노드의 자식노드들은 level 2
  - ...
- 높이
  - 서로다른 레벨의 수이다.

## 트리의 기본적인 성질

- 노드가 N개인 트리는 항상 N-1개의 링크(link)를 가진다.
- 트리의 루트에서 어떤 노드로 가는 경로는 유일하다. 또한 임의의 두 노드간의 경로도 유일하다.(같은 노드를 두 번 이상 방문하지 않는다는 조건하에)

## 이진트리(binary tree)

- 이진 트리에서 각 노드는 최대 2개의 자식을 가진다.
- 각각의 자식 노드는 자신이 부모의 왼쪽자식인지 오른쪽 자식인지가 지정된다.(자식이 한명인 경우에도)

### 응용 예 - Expression Tree

- 수식을 트리로 구성하여 해석한다.
- 연산자들이 이진연산자라면 이진 트리의 형태로 표현할 수 있다.

![image-20200828134120186](https://user-images.githubusercontent.com/58545240/91522941-62019c80-e936-11ea-9f67-21ffc1ee920c.png)

### 응용 예 - Huffman Code

- 파일압축과 관련된 유명한 알고리즘 중 하나인 허프만 코딩을 할 때, 각 문자를 `encoding`하는데 허프만 tree를 구성한다.
- 추후에 자세히!

![image-20200828134257871](https://user-images.githubusercontent.com/58545240/91522965-6f1e8b80-e936-11ea-967a-a05f46dfb03c.png)

### Full and Complete Binary Trees

- 꽉찬 이진트리와 완전 이진트리
- 높이가 h인 full binary tree는 2^h-1개의 노드를 가진다.
- 노드가 N개인 full 혹은 complete binary 트리의 높이는 O(logN)이다. (노드가 N개인 이진트리의 높이는 최악의 경우 N이 될 수도 있다.)

## 이진트리의 표현

- 힙을 표현했을 때는, 완전 이진 트리의 형태 였기 때문에 부모와 자식간의 관계가 배열로 표현하기에 충분했다. 하지만, 완전 이진트리가 아닌 형태라면 아래와 같은 구조의 표현이 필요하다.

- 연결구조(Linked Structure)

  - 각 노드에 하나의 데이터 필드와 왼쪽자식(left), 오른쪽 자식(right), 그리고 부모노드(p)의 주소를 저장(부모노드의 주소는 반드시 필요한 경우가 아니면 보통 생략함)

  ![image-20200828140842141](https://user-images.githubusercontent.com/58545240/91523715-6929aa00-e938-11ea-82cb-33acdf530f2f.png)

  - 예시
    - 트리상의 노드를 객체로 표현하여 이진트리를 Linked Structure로 표현할 수 있다.

  ![image-20200828140856659](https://user-images.githubusercontent.com/58545240/91523723-6fb82180-e938-11ea-89e6-7aa8d1b83f2e.png)

    

## 이진트리의 순회(traversal)

- 순회 
  - 이진 트리의 모든 노드를 방문하는 일
- 중위(inorder) 순회
- 전위(preorder) 순회
- 후위(postorder)순회
- 레벨오더(level-order) 순회

### inorder-중위 순회

- 순회는 본질적으로 recursive한 알고리즘이다.
- 이진트리를 루트노드, left Tree, right Tree로 나누어 생각한다.
- 먼저 left Tree를 inorder로 순회하고,
- root를 순회하고,
- right Tree를 inorder로 순회한다.
- **pseudo code**
  - x를 루트로 하는 트리를 inorder 순회
  - 시간복잡도 O(n)

```java
INORDER-TREE-WALK(x)
  if x != NULL
    then INORDER-TREE-WALK(left[x])
         print key[x]
         INORDER-TREE-WALK(right[x])
```

### postorder와 preorder순회

- inorder 순회와 다른점은 노드를 방문하는 순서뿐이다. 나머지의 개념은 동일하다.

- 트리를 방문하는 순서만 바뀐다.

- preorder-전위 순회

  - root를 순회하고,
  - 먼저 left Tree를 inorder로 순회하고,
  - right Tree를 inorder로 순회한다.

  ```java
  PREORDER-TREE-WALK(x)
    if x != NULL
      then print key[x]
           PREORDER-TREE-WALK(left[x])
           PREORDER-TREE-WALK(right[x])
  ```

- postorder-후위 순회

  - 먼저 left Tree를 inorder로 순회하고,
  - right Tree를 inorder로 순회하고,
  - root를 순회한다.

  ```java
  POSTORDER-TREE-WALK(x)
    if x != NULL
      then POSTORDER-TREE-WALK(left[x])
           POSTORDER-TREE-WALK(right[x])
           print key[x]
  ```

### Expression Trees

![image-20200828140911666](https://user-images.githubusercontent.com/58545240/91523736-75ae0280-e938-11ea-9dd4-292568bdf801.png)

- Expression 트리를 inorder-중위 순회하면 다음과 같이 출력됨
  - x + y * a + b / c
- 각 부트리를 순회할 때 시작과 종료시에 괄호를 추가하면 다음과 같이 올바른 수식이 출력됨
  - (x + y) * ((a + b) /c)
- postorder-후위 순회하면 후위표기식이 출력됨
  - x y + a b + c / *

### lever-order 순회

![image-20200828140923359](https://user-images.githubusercontent.com/58545240/91523743-7ba3e380-e938-11ea-98d6-4d152b3dfec4.png)

- 레벌 순으로 방문, 동일 레벨에서는 왼쪽에서 오른쪽 순서로 방문
- 큐(queue)를 이용하여 구현
  - 맨 처음 큐에 루트 노드 3을 넣는다.
  - 큐를 꺼내고, 3을 출력한 뒤,
  - 3의 왼쪽자식 1과, 오른쪽자식 5를 큐에 넣는다.
  - 1을 꺼내고 출력한 뒤, 1의 자식인 0과 2를 큐에 넣는다.
  - 다음 순서로 5를 꺼내고 출력한 뒤, 5의 왼쪽 자식인 4와 오른쪽 자식인 6을 큐에 넣는다.
- pseudo code

```java
LEVEL-ORDER-TREE-TRAVERSAL()
  visit the root;
  Q <- root       //Q is a queue
  while Q is not empty do
    v <- dequeue(Q);
    visit children of v;
    enqueue children of v into Q;
  end.
end.
```

# **> 이진탐색트리(BST)**

## Dynamic Set

집합이다. 여러개의 데이터의 집합인데, 그것들의 내용이 고정되지 않고, 생성과 삭제를 반복하면서 유동적인 집합이다. 아래와 같은 특징을 가진다. Dynamic Set, Dictionary 또는 Search Structure라고 불린다.

- 여러 개의 키(key)를 저장
- 다음과 같은 연산들을 지원하는 자료구조
  - INSERT - 새로운 키의 삽입
  - SEARCH - 키 탐색
  - DELETE - 키의 삭제
- 예: 심볼 테이블
- 일반적으로 구현할 때 배열 or 연결리스트를 사용한다.
  - 각 동작에 있어서 다음과 같은 시간복잡도를 가진다.
  - 정렬된 배열의 이진탐색 - O(logn)
  - 정렬된 배열에서 원소를 insert, delete하면 나머지 원소들을 한칸식 shift - O(n)
  - 정렬된 연결리스트의 경우는 이진탐색 불가 - O(n)을 피할 수 없음.
  - 정렬된 연결리스트에서 insert할 자리를 찾는 시간 - O(n)

| 종류       | 정렬 | search  | insert | delete                          |
| :--------- | :--- | :------ | :----- | :------------------------------ |
| 배열       | O    | O(logn) | O(n)   | O(n)(삭제 후 shift)             |
|            | X    | O(n)    | O(1)   | O(1)(찾았다고 가정하고, 삭제만) |
| 연결리스트 | O    | O(n)    | O(n)   | O(1)(찾았다고 가정하고, 삭제만) |
|            | X    | O(n)    | O(1)   | O(1)(찾았다고 가정하고, 삭제만) |

- 정렬된 혹은 정렬되지 않은 배열, 연결 리스트를 사용할 경우 INSERT, SEARCH, DELETE 중 적어도 하나는 O(n)의 시간복잡도를 가짐.
- 3가지 연산 모두 O(n)의 시간을 갖지 않는 효율적인 알고리즘은 없는가?
  - 이진탐색트리(Binary Search Tree), 레드-블랙 트리, AVL- 트리등의 트리에 기반한 구조들
  - Direct Address Table, **해시** 테이블 등

## 검색트리

- Dynamic set을 트리의 형태로 구현
- 일반적으로 SEARCH, INSERT, DELETE 연산이 트리의 높이(height)에 비례하는 시간복잡도를 가진다.
- 이진검색트리, 레드-블랙트리, B-트리 등  

## 이진검색트리(BST)

- 이진 트리이면서
- 각 노드에 하나의 키를 저장
- 각 노드 v에 대해서 그 노드의 왼쪽 서브트리에 있는 키들은 key[v]보다 작거나 같고, 오른쪽 부트리에 있는 값은 크거나 같다.

### SEARCH

![image-20200828140947553](https://user-images.githubusercontent.com/58545240/91523751-8199c480-e938-11ea-9442-5b721470f197.png)

- pesedo code

  - 키 값에 따라서 왼쪽 서브트리 또는 오른쪽 서브트리를 recursive하게 탐색한다.
  - 시간복잡도: O(h), 여기서 h는 트리의 높이 이다.
  - Recursive Version

  ```java
  TREE-SEARCH(x, k)
    if x = NULL or k = key[x]
      then return x
    if k < key[x]
      then return TREE-SEARCH(left[x], k)
      else return TREE-SEARCH(right[x], k)
  ```

  - Iterative Version

  ```java
  TREE-SEARCH(x, k)
    while x!=NULL and k!=key[x]
      do if k < key[x]
        then x <- left[x]
        else x <- right[x]
    return x
  ```

#### 최소값 찾기

- 최소값은 항상 가장 왼쪽 노드에 존재
- 시간복잡도: O(h)
- 최대 값은 반대로 가장 오른쪽 노드를 찾아가는 방법으로 찾는다.

```java
TREE-MINIMUM(x)
  while left[x] != null
    do x <- left[x]
  return x
```

#### Successor 찾기

- 노드 x의 successor란 key[x]보다 크면서 가장 작은 키를 가진 노드
- 모든 키들이 서로 다르다고 가정한다.
- successor의 3가지 경우
  - 노드 x의 오른쪽 서브트리가 존재할 경우, 오른쪽 서브트리의 최소값
  - 오른쪽 서브트리가 없는 경우, 어떤 노드 y의 왼쪽 서브트리의 최대값이 x가 되는 그런 노드 y가 x의 successor
    - 부모를 따라 루트까지 올라가면서 처음으로 왼쪽 링크를 타고 올라간 해당 노드가 y
    - 여기서는 4(x)의 successor를 구할 때, 루트까지 올라가면서 처음으로 왼쪽 링크를 타고 위로 올라간 노드 6(y).
  - 그런 노드 y가 존재하지 않을 경우 successor가 존재하지 않음(즉, x가 최대값)

![image-20200828140959411](https://user-images.githubusercontent.com/58545240/91523758-878fa580-e938-11ea-8346-c573d800fc99.png)

- peudo code
  - 1,2 : 오른쪽 서브트리가 존재할 경우, 오른쪽 트리의 최소 값을 찾는다.
  - 3 : y는 x의 부모노드
  - 4, 5, 6 : 부모노드가 null이 아니고, x가 부모의 오른쪽 자식일 경우에만 계속해서 부모를 찾아 올라간다.
  - 7 : 부모를 찾아 올라가다가 y가 null이거나, 누군가의 왼쪽 자식이 되는 경우 null 또는 y값을return 한다.
  - 시간복잡도 : O(h)

```java
TREE-SUCCESSOR(x)
1  if right[x] != NULL
2    then return TREE-MINIMUM(right[x])
3  y <- p[x]
4  while y != NULL and x = right[y]
5    do x <- y
6       y <- p[y]
7  return y  
```

#### Predecessor

- 노드 x의 predecessor란 key[x]보다 작으면서 가장 큰 키를 가진 노드
- Successor와 반대

 

### INSERT

- 14의 삽입 위치를 찾으러 13의 오른쪽으로 내려갔는데, x의 위치가 null이 되므로 항상 x의 부모 노드 y를 관리해 준다.

![image-20200828141010611](https://user-images.githubusercontent.com/58545240/91523768-8d858680-e938-11ea-9d06-afd77ab0ed90.png)

- pseudo code
  - T는 Tree, z는 insert할 노드
  - 1,2 : y = null, x = root노드 에서 출발
  - 3 : x가 null이 아닐때 까지 
  - 4 : y에 x를 저장해놓고,
  - 5,6,7 : z와 x의 키값을 비교해서 z의 키값이 x의 키값보다 작으면 왼쪽 노드로, z의 키값이 더 크면 오른쪽 노드로 내려간다. 내려간 뒤, 다시 y에 x를 저장, 반복
  - 8 : 새로운 노드 z의 부모는 y가 된다.
  - 9,10 : y가 NULL이라면, Tree가 NULL이라는 의미이고 z는 root가 된다.
  - 11,12 : z의 키 값이 y보다 작다면 왼쪽 자식이 되고,
  - 13,14 : z의 키 값이 y보다 크다면 오른쪽 자식이 된다.
- 시간복잡도는 : O(h)
  - 트리의 높이보다 더 많은 시간을 필요로 하진 않는다.

```java
TREE-INSERT(T, z)
01  y <- NULL
02  x <- root[T]
03  while x!= NULL
04    do y <- x
05      if key[z] < key[x]
06        then x <- left[x]
07      else x <- right[x]
08  p[z] <- y
09  if y = NULL
10    then root[T] <- z
11  else if key[z] < key[y]
12    then left[y] <- z
13  else
14    then right[y] <- z  
```

### DELETE

- Case 1 : 자식노드가 없는 경우
  - 리프노드인경우 그냥 삭제한다.

![image-20200828141022597](https://user-images.githubusercontent.com/58545240/91523782-937b6780-e938-11ea-9d70-8424cc4d795f.png)

- Case 2 : 자식노드가 1개인 경우
  - 자신의 자식 노드를 원래 자신의 위치가 될 수 있도록 연결한다.

![image-20200828141037478](https://user-images.githubusercontent.com/58545240/91523799-9bd3a280-e938-11ea-9377-b4e80685f256.png)

- Case 3 : 자식노드가 2개인 경우
  - 가장 복잡한 경우이다. 자식 노드가 2개인 노드를 삭제하는 경우 트리의 구조가 깨지기 때문에 다시 조건을 만족하는 트리를 만들어주는 작업이 필요하다.
  - 13을 삭제하는 경우, 13의 노드에 있는 데이터만 삭제하고,
  - 삭제하려는 노드의 Successor의 데이터만 copy해서 가져온다.
  - 그리고 Successor를 삭제한다.
  - **자식노드가 2개인 노드의 Successor는 왼쪽 자식이 없다는 것이 보장되어 있다.** 하지만, 오른쪽 자식은 있을 수도 있고 없을 수도 있다. 즉, 자식노드가 0개 또는 1개이다.
  - 이 경우, Case 1 또는 2에 해당하므로, 방법에 맞게 삭제한다.

![image-20200828141048342](https://user-images.githubusercontent.com/58545240/91523811-a4c47400-e938-11ea-9b84-2a4da86031a1.png)

![image-20200828141100931](https://user-images.githubusercontent.com/58545240/91523822-ac841880-e938-11ea-8b46-9bf613298c7d.png)

- Case별 예시

![image-20200828141119116](https://user-images.githubusercontent.com/58545240/91523833-b279f980-e938-11ea-933e-38d556eb936f.png)

- pseudo code
  - T는 트리 z는 삭제할 노드, 삭제할 노드를 search하는 작업은 이루어 졌다고 가정하고, 삭제하는 로직
  - 1,2,3 : 실제로 트리에서 삭제할 노드 y를 정한다. 자식노드가 0개 또는 1개일 경우 실제로 해당 노드를 삭제할 것이기 때문에 y에 z를 대입한다. 자식노드가 2개일 경우 삭제할 노드 y는 z의 successor를 대입하여 삭제한다.
  - 따라서, 4 - 13라인은 실제 노드 y를 삭제하는 경우이고, 14 - 17라인은 노드 z의 Successor를 삭제하는 case 3인 경우이다.
  - 4, 5, 6 : y의 자식은 0개 또는 1개인 상태이다. y의 왼쪽 자식이 존재한다면, x는 y의 왼쪽 자식이고, 그렇지 않다면 x는 y의 오른쪽 자식이다.
  - 7, 8 : 그리고 x가 NULL이 아니라면, 현재 y의 부모를 x의 부모로 설정한다.
  - 9,10 : y의 부모가 없다면, 즉 y가 루트노드라면, x를 루트로 설정한다.
  - 11,12 : 그렇지 않고 y가 자신의 부모의 왼쪽 자식이었다면, 삭제될 노드 y의 부모의 왼쪽 자식을 x로 설정하고
  - 13 : 그렇지 않고 y가 자신의 부모의 오른쪽 자식이었다면, 삭제될 노드 y의 부모의  오른쪽 자식으로 x를 설정한다. 이렇게 해서 실제 y를 삭제하는 일이 끝났다.
  - 14, 15, 16 : 삭제하려는 노드 z와 실제 트리에서 삭제될 노드 z가 다르다는 것은 case 3에 해당한다는 이야기 이므로, y에 보관되어 있는 데이터를 z의 자리로 옮기고(y의 키값만이 아닌 satellite data들 까지 모두), 실제 삭제된 노드의 데이터 y를 리턴한다.
  - 시간복잡도 O(h)

```java
TREE-DELETE(T, z)
01  if left[z] = NULL or right[z] = null
02    then y <- z
03  else y <- TREE-SUCCESSOR(z)
04  if left[y] != NULL
05    then x <- left[y]
06  else x <- right[y]
07  if x != NULL
08    then p[x] <- p[y]
09  if p[y] = NULL
10    then root[T] <- x
11  else if y = left[p[y]]
12    then left[p[y]] <- x
13  else right[p[y]] <- x
14  if y != z
15    then key[z] <- key[y]
16      copy y's satellite data into z
17  return y
```

## BST 정리

- 각종 연산의 시간복잡도는 O(h)이다.
- 최악의 경우 트리의 높이 h는 O(n)이다.
  - 실제 위에서 학습한 BST의 Search, Insert, Delete 모두 최악의 경우 시간복잡도는 O(n)이다.
  - 그러나, 이것은 실제 최악의 경우에 해당한다. BST에 데이터들이 random하게 구성된다고 가정했을때, 평균 트리의 높이는 O(logn)이 된다. 이는 Search, Insert, Delete 연산의 시간복잡도가 O(logn)이 된다는 이야기이다.
- 최악의 경우에도 O(logn)을 넘지 않도록 하는 균형잡힌 트리
  - 레드-블랙 트리 등
  - 키의 삽입이나 삭제시 추가로 트리의 균형을 잡아줌으로써 높이를 O(logn)으로 유지한다.

# **> 부록 - 이진트리**

---

## 1. 후위 순회(postorder)

이진 트리(binary tree)의 후위 순회 알고리즘이 사용될 수 있는 대표적인 예는 **특정 디렉토리(directory)의 용량 계산**이다. 단, 이진 트리이기 때문에 특정 디렉토리(=폴더)의 서브 디렉토리의 개수는 2개 이하로만 존재해야 한다. 삼진 트리(ternary tree)였다면 서브 디렉토리는 총 3개까지 존재할 수 있다.

### 1.1 디렉토리의 용량 계산

디렉토리의 용량 계산을 위해서는 **어떤 알고리즘이 사용되야하는가**를 먼저 고민해보자. 생각을 할 때 구체적인 상황을 두고 예시를 들어보면 이해가 빠르다. 현재 사용하는 컴퓨터에 `datastructure` 라는 디렉토리가 있다고 가정해보자. 이 `datastructure` 디렉토리 내부에는 `stack`, `queue` 라는 서브 디렉토리가 존재한다.

- `datastructure/stack`
- `datastructure/queue` 이 때 `datastructure` 디렉토리의 크기를 구하려면 어떻게 해야할까?

서브 디렉토리인 `stack` 디렉토리와 `queue` 디렉토리의 크기를 각 계산하여 합하면 `datastructure` 폴더의 크기를 계산할 수 있다. **서브 디렉토리의 크기를 더해 현재 디렉토리의 크기를 계산한다**는 아이디어를 생각해보면 서브 디렉토리의 크기를 먼저 계산하는데, 바로 이러한 특징 때문에 후위 순회 알고리즘을 사용해야 한다.

### 1.2 코드

> *후위 순회: 트리를 탐색할 때 왼쪽 서브트리, 오른쪽 서브트리, 루트 순으로 방문하는 순회 알고리즘을 일컫는 말이다. 후위 순회 알고리즘은 아래와 같다.*

```C
// 후위 순회 알고리즘
void postorder(TreeNode *root){
    if(root){
        postorder(root->left);		// 왼쪽 서브 트리를 가장 먼저 순회
        postorder(root->right);		// 다음으로 오른쪽 서브 트리를 순회
        printf("%d", root->data);	// 마지막으로 루트의 노드를 방문
    }
}
```

위와 같은 후위 순회를 사용하여 디렉토리 크기를 계산하는 코드를 작성해보도록 한다. 순환 호출되는 함수가 용량을 반환하도록 만들어줘야 한다.

```C
// 디렉토리 용량 계산 프로그램
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>

typedef struct TreeNode{
    int data;
    struct TreeNode *left, *right;
} TreeNode;

int calc_dir_size(TreeNode *root);

// 아래와 같은 트리 구조를 생성한다.
//				n1
//			n3		n2
//		n4		n5
int main(){
    TreeNode n4 = { 500, NULL, NULL };
    TreeNode n5 = { 200, NULL, NULL };
    TreeNode n3 = { 100, &n4, &n5 };
    TreeNode n2 = { 50, NULL, NULL };
    TreeNode n1 = { 0, &n2, & n3 };
    
    printf("디렉토리의 크기 = %d\n", calc_dir_size(&n1));
}

int calc_dir_size(TreeNode *root){
    if(!root) return 0;		// 존재하지 않는 노드일 경우
    else{
        int left = calc_dir_size(root->left);		// 왼쪽 서브트리를 먼저 순회한다
        int right = calc_dir_size(root->right);		// 오른쪽 서브트리를 그 다음으로 순회한다.
        return left + right + root->data;			// 순회한 노드에 해당하는 데이터를 계속해서 더해간다.
    }
    return 0;
}
```

## 2. 이진트리의 높이 구하기

트리의 높이를 구할 때의 핵심 개념은 왼쪽 서브트리의 높이와 오른쪽 서브트리의 높이를 비교하여 **더 큰 쪽을 택한다**는 것이다. 그렇다면 우리에게 필요한 건 서브트리의 높이와 오른쪽 서브트리의 높이다. 높이는 어떻게 구할 수 있을까?

### 2.1 코드

```C
typedef struct TreeNode{
    int data;
    struct TreeNode *left, *right;
} TreeNode;
int get_height(TreeNode *root);
// 아래와 같은 트리 구조를 생성한다.
//      n1
//    n3    n2
//  n4    n5
void main(){
    TreeNode n4 = { 500, NULL, NULL };
    TreeNode n5 = { 200, NULL, NULL };
    TreeNode n3 = { 100, &n4, &n5 };
    TreeNode n2 = { 50, NULL, NULL };
    TreeNode n1 = { 0, &n2, &n3 };
    
    printf("디렉토리의 크기 = %d\n", calc_dir_size(&n1));
}

int get_height(TreeNode *root){		// 트리의 높이를 구한다
    if(!root) return 0;
    else{
        int left_h = get_height(root->left);		// 왼쪽 서브트리의 높이를 순환호출을 통해 얻는다.
        int right_h = get_height(root->right);		// 같은 방법으로 오른쪽 서브트리의 높이를 얻는다.
        return 1 = (left_h > right_h ? left_h : right_h);		// 둘 중 큰 값에 1을 더해 반환한다.
    }
}
```

위 코드를 이해해보자. 순환 알고리즘이 적용된 코드를 작성하거나 읽을 때는 탈출 조건 보다는 **순환호출 되는 부분을 먼저 살펴봐야 한다.** 호출되는 부분은 `int left_h = get_height(root->left)`, `int right_h = get_height(root->right)` 이 두 부분이다.

위 순환 호출되는 코드로 왼쪽 서브트리의 높이 `left_h`와 오른쪽 서브트리의 높이 `right_h`를 구하기 위해 순환 함수로 각 서브트리의 끝(단말 노드)까지 방문할 수 있다. 방문 순서는 `get_height(root->left`가 먼저 호출되었으므로 먼저 왼쪽 서브트리의 단말노드까지 방문할 것이고 탈출 조건 `if (!root)`를 만나면서 왼쪽 서브트리를 빠져나오면 오른쪽 서브트리로 진입한다(`get_height(root->right)`.

다음으로 탈출되는 조건을 살펴보자. 위 코드에서 상정한 탈출 조건은 **단말노드를 만났을 때**다. 단말노드란 자식이 없는 노드를 뜻한다. 그렇다면 단말노드인 것은 어떻게 알 수 있을까?

자식이 없는 노드가 단말노드이므로 아래와 같은 두 조건을 생각해볼 수 있다.

```C
/**
* if (root->left == NULL && root->right == NULL) // 왼쪽 서브트리와 오른쪽 서브트리가 없을 때
* if (root == NULL) or if (!root)	// 방문을 했는데 존재하지 않는 노드였을 경우
*/
```

`root == NULL`의 의미를 좀 더 풀어서 설명하자면 **자식 노드가 있나 살펴보려 서브 트리를 방문했는데 아무것도 발견할 수 없었다**라는 의미다. 위 코드는 이 조건을 적용한 코드다.

마지막으로 `get_height`함수에서 맨 아래 리턴하는 부분을 살펴보자. **왜 1을 더해서 리턴해주는 걸까?**라는 의문이 든다면 그 이전에 어떤 작업을 시행했는지를 살펴보자. 특히 첫번째 완전한 순환이 끝났을 때를 생각해보자. 순환을 계속하면서 각 서브 트리의 끝까지 방문한 상태(정확히는 오른쪽 서브트리를 끝까지 방문한 상태)에서 한 단계 더 내려가 `root == NULL`이라는 탈출 조건을 만났다. 그렇게 탈출 조건을 만나 빠져나오면 마지막 리턴문을 만나게 되는데 이때의 상황은 더 이상의 자식노드, 서브트리가 없는 상황이므로 리턴문에 있는 `left_h`와 `right_h`는 둘 다 0이 될 것이다.

위 상황에 대한 결론을 내려보면 나에게 자식노드, 서브트리는 존재하지 않지만 적어도 **나는 존재한다는 것을 입증했다는 것**이다. 따라서 나 자신을 하나의 개수로 칠 수 있다. 그래서 1을 더하는 것이다. 1을 더한 후에는 왼쪽 서브트리와 오른쪽 서브트리의 높이 중 더 큰 값을 택하기만 하면 되는 것이다.

순환의 개념을 접할 때는 추상적으로 이해하면 이해에 좀 더 도움이 된다. 큼지막한 매커니즘, 예를 들어 왼쪽 서브트리 높이 구하기, 오른쪽 서브트리 높이 구하기들이 대략 어떤 순서로 실행되는지를 파악하고 리턴은 언제 되고 탈출 조건은 어떻게 되는지를 살펴보는 것이다. 실행 흐름을 하나 하나 다 따지려 하기보다는 먼저 이렇게 개념적으로 접근한 후에 세부적으로 이해하려고 하면 좀 더 편하다.

## 3. 이진트리의 단말 노드 개수 구하기

2번에서 살펴본 알고리즘을 그대로 적용하면 의외로 쉽게 구할 수 있다. 아래의 코드만 보고 개념을 이해하도록 해보자.

### 3.1 코드

```C
typedef struct TreeNode{
    int data;
    struct TreeNode *left, *right;
} TreeNode;

int get_leaf(TreeNode *root);
// 아래와 같은 트리 구조를 생성한다.
//      n1
//    n3    n2
//  n4    n5

void main(){
    TreeNode n4 = { 500, NULL, NULL };
    TreeNode n5 = { 200, NULL, NULL };
    TreeNode n3 = { 100, &n4, &n5 };
    TreeNode n2 = { 50, NULL, NULL };
    TreeNode n1 = { 0, &n2, &n3 };
 
    printf("단말 노드의 갯수 = %d\n", get_leaf(&n1));
}

int get_leaf(TreeNode *root){		// 트리에 존재하는 단말노드의 갯수를 구한다.
    if(!root) return 0;
    if(root->left == NULL & root->right == NULL) return 1;
    else return get_leaf(root->left) + get_leaf(root->right);
}
```

위 코드의 탈출 조건은 `if (root->left == NULL && root->right == NULL)`다. 즉 **자식노드 혹은 서브트리가 존재하지 않을 때**가 탈출 조건이다. 의미는 **자식 노드는 존재하지 않지만 내가 존재한다는 건 적어도 증명했으니 난 1개로 셀 수 있다**는 것이다. 첫번째 `if (!root)`의 조건은 누군가 이 함수를 사용할 때 존재하지 않는 노드를 매개변수로 넘겼을 때를 대비하기 위함이다 .오류를 방지하는 용도로서의 의미를 가진 조건이다. 이 조건을 탈출 조건으로 쓸 수 없는 것은 이 조건 만으로는 단말 노드의 여부를 증명할 수 없기 때문이다. 아무것도 존재하지 않으므로 개수를 셀 수 없다.

## 4. java코드

```java
class Node {
    int element;
    Node left;
    Node right;
    
    Node(int element) {
        this(element, null, null);
    }
    
    Node (int element, Node left, Node right) {
        this.element = element;
        this.left = left;
        this.right = right;
    }
}

class Tree {
    // 트리 생성
    public Node insert(Node tree, int n) {
        if (tree == null) {
            tree = new Node(n);
            tree.right = tree.left = null;
        } else if (n > tree.element) {
            tree.right = insert(tree.right, n);
        } else {
            tree.left = insert(tree.left, n);
        }
        
        return tree;
    }
    // 트리의 노드 갯수를 return하는 recursive한 알고리즘
    public int count(Node rootNode) {
        int num;
        
        if (rootNode == null) {
            num = 0;
        } else {
            num = count(rootNode.left) + count(rootNode.right) + 1;
        }
        return num;
    }
    
    // 트리의 높이를 return하는 recursive한 알고리즘
    public int depth(Node rootNode) {
        int dep, depl, depr;
        
        if (rootNode == null) {
            dep = 0;
        } else {
            depl = depth(rootNode.left);
            depr = depth(rootNode.right);
            if (depl >= depr) {
                dep = depl + 1;
            } else {
                dep = depr + 1;
            }
        }
        return dep;
    }
}

// 트리를 가지고 테스트를 해보자.
public class Main {
    public static void main(String[] args) {
        Node rootNode = null;
        int nansu;
        Tree tree = new Tree();
        
        Random r = new Random();
        System.out.print("발생된 난수: ");
        for (int i = 0; i < 5; i++) {
            nansu = r.nextInt() % 100;
            System.out.print(nansu+" ");
            
            // 항상 루트노드가 반환된다.
            rootNode = tree.insert(rootNode, nansu);
        }
    }
}
```

# **> 트라이(Trie)**

---

> **문자열에서의 검색을 빠르게 해주는 자료구조. 여러 문자열을 저장하는 자료구조**
>
> **래딕스 트리(radix tree)** 나 **접두사 트리(prefix tree)**라고도 한다.

우리는 정수형 자료형에 대해서 이진검색트리를 이용하면 O(logN)의 시간만에 원하는 데이터를 검색할 수 있다. 하지만 문자열에서 이진검색트리를 사용한다면 문자열의 최대길이가 M이라면 O(MlogN)의 시간 복잡도를 가지게 될 것이다.

우리는 문자열 검색을 개선하기 위해 트라이를 이용하여 O(M)의 시간만에 원하는 문자열을 검색할 수 있다.

트라이라는 명칭은 Re**trie**val에서 유래한다. 트라이가 retrieve(탐색)하는데 유용한 걸 생각하면 납득ㅇ ㅣ디ㅗㄴ다.

자 그러면 트라이는 어떻게 문자열의 검색을 O(M)만에 처리할까?

아래 그림은 문자열 집합 = {"AE" , "ATV", "ATES", "ATEV", "DE" ,"DC"} 가 존재할 때 트라이의 예입니다.

![image-20200910180006571](https://user-images.githubusercontent.com/58545240/92707306-23d19780-f390-11ea-9dbc-fb8affcde180.png)

쿼리에 따라서 처리해줄 수 있는 역할이 달라지겠지만 우리는 대부분 문자열이 끝나는 지점을 표시하는것이 쿼리를 처리할 때 편합니다.

![image-20200910180022996](https://user-images.githubusercontent.com/58545240/92707337-2a600f00-f390-11ea-92e0-76236f2927c8.png)

종료 노드들을 표시해주면 위와같은 그림이 되겠군요

자 우리는 트리형태를 띄는 트라이에서 검색을 할 경우 최대 트리의 높이까지 탐색하게 됩니다.

따라서 시간복잡도는 O(H)가 되겠죠 하지만 트리의 높이는 최대 문자열의 길이가 되기 때문에 O(M)의 시간복잡도에 문자열 검색이 가능한 것입니다.

자 그러면 우리는 트라이를 어떻게 구현해야 할까요?

많은 방법이 있겠지만 종만북을 참고하여 가장 보편적인 방법을 보여드리겠습니다.

## TrieNode.java

```java
import java.util.HashMap;
import java.util.Map;
public class TrieNode {
    // [ 변수 ]
    // 자식 노드 맵
    private Map<Character, TrieNode> childNodes = new HashMap<>();
    // 마지막 글자인지 여부
    private boolean isLastChar;
    // [ GETTER / SETTER 메서드 ]
    // 자식 노드 맵 Getter
    
    Map<Character, TrieNode> getChildNodes() {
        return this.childNodes;
    }
    // 마지막 글자인지 여부 Getter
    boolean isLastChar() {
        return this.isLastChar;
    }
    // 마지막 글자인지 여부 Setter
    void setIsLastChar(boolean isLastChar) {
        this.isLastChar = isLastChar;
    }
}
```

```c++
struct Trie {
    bool finish;    //끝나는 지점을 표시해줌
    Trie* next[26];    //26가지 알파벳에 대한 트라이
    Trie() : finish(false) {
        memset(next, 0, sizeof(next));
    }
    ~Trie() {
        for (int i = 0; i < 26; i++)
            if (next[i])
                delete next[i];
    }
    void insert(const char* key) {
        if (*key == '\0')
            finish = true;    //문자열이 끝나는 지점일 경우 표시
        else {
            int curr = *key - 'A';
            if (next[curr] == NULL)
                next[curr] = new Trie();    //탐색이 처음되는 지점일 경우 동적할당
            next[curr]->insert(key + 1);    //다음 문자 삽입
        }
    }
    Trie* find(const char* key) {
        if (*key == '\0')return this;//문자열이 끝나는 위치를 반환
        int curr = *key - 'A';
        if (next[curr] == NULL)return NULL;//찾는 값이 존재하지 않음
        return next[curr]->find(key + 1); //다음 문자를 탐색
    }
};
```

트라이는 자료구조이기 때문에 입맛에 따라서 변형하여 사용이 가능해야 합니다.

따라서 우리는 문제에서 원하는 조건에 따라서 find함수를 여러방식으로 변형하여 사용하게 될것입니다. 

그러면 우리는 트라이를 통하여 어떤 문제를 해결할 수 있을까요??

[BOJ 5052 전화번호 목록](http://icpc.me/5052) 문제를 보겠습니다.

전화 번호의 목록이 주어질 때 일관성이 있는지는 확인하는 문제입니다.

우리는 트라이를 이용하여 이 문제를 간단하게 해결할 수 있습니다.

모든 문자열을 트라이에 삽입해준 후 다시 모든 문자열을 트라이로 검색하면서 아직 검색중인데 finish인 부분이 한번이라도 존재한다면 일관성이 없다고 처리가 됩니다.

총 시간 복잡도는 O(T*(N*10))이 되겠군요 여기서 10은 전화번호의 최대길이입니다.

다음은 소스코드입니다.

```c++
#include <cstdio>
#include <algorithm>
#include <cstring>
#define MAX_N 10000
using namespace std;
struct Trie{
    Trie* next[10];
    bool term;
    Trie() : term(false){
        memset(next,0,sizeof(next));
    }
    ~Trie(){
        for(int i=0;i<10;i++){
            if(next[i])
                delete next[i];
        }
    }
    void insert(const char* key){
        if(*key=='\0')
            term=true;
        else{
            int curr = *key-'0';
            if(next[curr]==NULL)
                next[curr]=new Trie();
            next[curr]->insert(key+1);
        }
    }
    bool find(const char* key){
         if(*key=='\0')
            return 0;
        if(term)
            return 1;
        int curr = *key-'0';
        return next[curr]->find(key+1);
    }
};
int t,n,r;
char a[MAX_N][11];
int main(){
    scanf("%d",&t);
    while(t--){
        scanf("%d",&n);
        getchar();
        for(int i=0;i<n;i++)
            scanf("%s",&a[i]);
        Trie *root=new Trie;
        r=0;
        for(int i=0;i<n;i++)
            root->insert(a[i]);
        for(int i=0;i<n;i++){
            if(root->find(a[i])){
                r=1;
            }
        }
        printf("%s\n",r?"NO":"YES");
    }
    return 0;
}
```



# **> 세그먼트 트리(Segment Tree)**

---

> **각 구간들을 그대로 보존하고 있는 트리**

![image-20200914160424940](https://user-images.githubusercontent.com/58545240/93054868-01e45780-f6a5-11ea-824c-93a0ed3c2007.png)

전체 구간이 [0, N-1]이라 할 때, 즉 N개의 공간이 있을 때

이렇게 리프 노드들은 길이가 1인 각각의 구간을 갖고 있고

부모 노드는 자신의 자식들의 구간의 합을 갖고 있으며 모든 구간은 연속적이어야만 합니다.

루트는 전체 구간을 포함하게 됩니다.

이렇게 각 노드가 구간, 혹은 그 구간의 정보를 저장하고 있는 자료구조를 말합니다.

![image-20200914160437172](https://user-images.githubusercontent.com/58545240/93054876-06a90b80-f6a5-11ea-9a8e-9d3eb18fa8e5.png)

보통은 **완전 이진 트리**의 형태를 사용해 전체적으로 동일한 재귀적 구조가 반복되도록 이렇게 표현하며, 값의 개수가 2^n 꼴이 아닐 때 남는 구간을 의미없는, 혹은 기본 값으로 채워서 **포화 이진 트리** 형태로 사용하는 게 대부분입니다.

이렇게 하면 값이 N개일 때 반드시 트리의 높이가 **O(logN)**으로 균형잡혀 있기 때문이죠!

그리고 힙 때와 마찬가지로 루트의 인덱스가 1부터 시작되며 레벨 오더 순번으로 노드 번호를 매겨서 자신의 부모, 왼쪽/오른쪽 자식을 접근하게 쉽게 합니다.

즉, [0, 7]은 1번, [0, 3]은 2번, [4, 7]은 3번, [0, 1]은 4번...

그리고 리프 노드들은 8, 9, 10, ... , 15번으로 N ~ 2N-1번의 번호를 얻게 됩니다. 번호는 곧 인덱스라고 생각해도 좋습니다.

## - BOJ[2042] : 구간합구하기

> https://www.acmicpc.net/problem/2042


이 문제를 살펴봅시다. 값이 N개이고 쿼리가 2개의 형태로 들어옵니다.

하나는 b번째 값을 c로 바꾸라는 것이고 하나는 구간 [b, c]에 속한 모든 원소의 합을 구하란 거네요.

만약 두 번째 쿼리만 있었다면 구간 합 배열(https://kks227.blog.me/220787178657)만을 사용하여 문제를 풀 수 있었을 것인데, 문제는 도중에 값을 바꾸는 쿼리가 들어온다는 점...

이 때문에 값을 바꿀 때마다 구간 합 배열을 O(N)으로 갱신해줘야 해서 쿼리 개수를 Q(=M+K)라 하면 전체 **O(NQ)**의 시간복잡도를 피할 수 없게 됩니다. 즉 시간초과...

그래서 좀 더 최적화된 자료구조가 필요하게 되었습니다!! 그것이 세그먼트 트리입니다.



세그먼트 트리는 구간 정보로 사용자가 원하는 아무 값이나 저장해 두는데,

가장 대표적인 것이 **구간에 속한 원소들의 합**, 구간에 속한 원소들의 곱, 구간 원소들 중 최댓값, 구간 원소들 중 최솟값 등이 있습니다. 즉...

![image-20200914160527201](https://user-images.githubusercontent.com/58545240/93054884-09a3fc00-f6a5-11ea-847a-69ff8be40b83.png)

위의 문제를 풀기 위해 자신이 포함하는 구간의 원소의 합을 갖고 있으면 이렇게 됩니다.

여기서 만약 구간 전체의 합을 알고 싶다면 바로 루트를 보면 됩니다. 14네요.

구간 [0, 3]의 합은? 그에 해당하는 노드가 2번입니다. 그 값이 9네요.

구간 [4, 5]는? 6번 노드를 보면 됩니다. 그 값이 4네요.

구간 [6, 6]은? 이건 리프 노드인 14번 노드의 값이자 그냥 배열의 6번 원소인 0이 되겠습니다.



이렇게 구간에 딱 맞춰 대응하는 노드가 있으면 그 노드의 값으로 구간 합을 구할 수 있음은 쉽게 알 수 있습니다.

그런데 하나의 노드로 표현할 수 없는 구간은? 예를 들면 [0, 2]나 [3, 6]은 어떻게 할까요?

![image-20200914160540717](https://user-images.githubusercontent.com/58545240/93054893-0dd01980-f6a5-11ea-90d0-444c55eb5208.png)

구간 [0, 2]의 합을 구하는 방법입니다.

보시면 구간을 여러 개로 쪼개서 트리상의 노드들로만 표현이 가능하게 해버렸죠.

[0, 1]과 [2, 2] 구간으로 쪼개서 그 각각의 합을 구했습니다.

![image-20200914160554683](https://user-images.githubusercontent.com/58545240/93054907-1163a080-f6a5-11ea-9990-733bfae13040.png)

구간 [3, 6]의 합을 구하는 방법입니다. 이번엔 저 빨간색 노드들의 합을 더하면 됩니다.

![image-20200914160605294](https://user-images.githubusercontent.com/58545240/93054916-16285480-f6a5-11ea-9a9c-8bb8882b6fb3.png)

구간 [2, 7]의 합입니다.

지금까지 예시를 보면 모두 구간을 여러 개로 쪼개고, 동시에 그 쪼개서 생기는 구간의 개수도 최소화하고 있습니다.

즉 어떤 넓은 구간이 원래 합을 구하려는 구간에 포함된다면 그 구간은 더 쪼개지 않고 바로 자신에 대응하는 노드 값을 보태버리면 됩니다.

만약 구간 [0, 1]과 [2, 3]이 동시에 목표 구간에 포함된다면 그 둘을 합친 구간 [0, 3] 또한 해당하는 노드가 있으므로 [0, 3] 구간을 쪼개지 않고 그 노드 값으로 처리하겠다는 거죠.



이걸 재귀함수로 구현할 수 있습니다. 먼저 루트부터 내려가면서, 구하려는 구간에 이 노드가 완전히 포함되면 자신의 값을 리턴하고, 아니면 구간을 양쪽으로 쪼개서 각각 재귀호출해 두 함수의 결과를 더하면 됩니다.

만약 이 노드의 구간이 목표 구간과 전혀 겹치지 않으면 더 탐색할 필요없이 역시 종료해버리면 됩니다.



구간 [L, R]에서 목표 구간에 속하는 원소들의 합을 구하는 함수를 sum(L, R)이라 해봅시다.

세 번째 그림을 예로 들어보자면 우리가 목표로 하는 구간이 [2, 7]이고, 맨 처음엔 루트인 [0, 7]부터 시작합니다. 즉, sum(0, 7)을 불러서 시작합니다.

호출된 sum(0, 7)은 이런 행동을 합니다. [0, 7]이 [2, 7]에 포함되지는 않으므로 구간을 양분해 [0, 3], [4, 7]로 나누어서 각각을 재귀호출해 그 결과를 더하도록 합시다. 즉, sum(0, 3)과 sum(4, 7)을 부릅니다.

sum(0, 3)은 마찬가지로 sum(0, 1)과 sum(2, 3)을 부릅니다.

sum(0, 1)은 목표 구간 [2, 7]과 **겹치는 구간이 전혀 없으므로** 0을 리턴하며 종료합니다.

sum(2, 3)은 목표 구간 [2, 7]에 **완전히 포함되므로** 자신의 값 4를 리턴합니다.

sum(0, 3)은 따라서 0+4 = 4를 리턴합니다.

sum(4, 7) 또한 [2, 7]에 완전히 포함되므로 바로 5를 리턴합니다.

최종적으로 sum(0, 7) = sum(0, 3) + sum(4, 7) = 4 + 5 = 9가 됩니다.



대충 이런 식으로 재귀호출이 이루어집니다.

```c++
 int sum(int L, int R, int nodeNum, int nodeL, int nodeR){
        if(R < nodeL || nodeR < L) return 0;
        if(L <= nodeL && nodeR <= R) return arr[nodeNum];
        int mid = (nodeL + nodeR) / 2;
        return sum(L, R, nodeNum*2, nodeL, mid) + sum(L, R, nodeNum*2+1, mid+1, nodeR);
 }
```

매개변수가 좀 많은데 종만북의 코드를 거의 그대로 옮긴 겁니다.

nodeNum은 현재 보고 있는 노드의 번호(인덱스)이고 nodeL과 nodeR은 그 노드가 포함하는 구간을 의미합니다. L과 R이 본래 우리가 구하고자 하는 구간이고요.

따라서 구간 [L, R]의 합을 구하고 싶을 때는 맨 처음에 **sum(L, R, 1, 0, N-1)**을 호출해야 합니다. N이 값의 개수, 즉 전체 구간의 크기입니다. 루트 번호는 1이구요.



첫 번째 줄은 [nodeL, nodeR]과 [L, R]이 **전혀 안 겹치는 경우.** 바로 0을 리턴하는데 0은 덧셈에 영향을 미치지 않죠.

두 번째 줄은 [nodeL, nodeR]이 [L, R]에 **완전히 포함되는 경우.** 바로 자신의 값을 리턴하면 됩니다. 이 경우는 구간 크기가 1인 경우도 자동으로 포함합니다.

세 번째~네 번째 줄이 그 외의 경우로 현재 노드의 구간을 양분해 각각을 재귀호출해서 더하는데, 이건 이 구간을 2등분하면 왼쪽 것은 이 노드의 왼쪽 자식, 오른쪽 것은 이 노드의 오른쪽 자식이 표현하고 있다는 걸 잘 이용한 형태입니다.

저의 경우는 구간 [L, R]이 아니라 구간 [L, R)의 형태로 짜서(즉, R은 구간에 포함 안 됨) 몇몇 식들이 조금 다릅니다.



자, 그럼 이 sum 함수의 시간복잡도가 얼마일까요?

기껏 이렇게 어려운 방법으로 구간 합을 구하고 있으니 적어도 O(N)보다는 적기를 기대합니다.

정답부터 말씀드리자면 **O(logN)**이고, 이는 트리의 높이가 O(logN)이라서 최대 그만큼의 연산을 하리라는 짐작에서 나옵니다.

그런데 간혹 구간이 엄청 절묘하고 예술적으로 뽑혀서 엄청 많은 수의 재귀호출을 해야 할 때가 있지 않을까요? O(logN)의 범주를 초과할 정도로...



**그럴 수는 없다**는 것이 중요합니다.

어떤 구간을 여러 개로 쪼개서 각 구간이 전부 세그먼트 트리상의 어떤 노드의 구간과도 같지 않게, 최대한 재귀호출이 많이 되게 만들어봅시다. 얼마나 많이 되도록 만들 수 있을까요?

이렇게 생각해 봅시다. 여태까지 예제에서 하나의 깊이에 두 번의 호출이 시도되는 경우는 봤습니다. 두 번째 그림([3, 6]의 합)의 깊이 4에서 [3, 3]과 [6, 6]이 불러진 게 그 예죠.

그럼 하나의 깊이에서 3개 이상의 호출이 시도될 수 있을까요?

그러려면 어떻게 해야 할까요? 어떤 연속된 하나의 구간을 3등분해서 각 구간이 호출되도록 만들어 봅시다.

![image-20200914160638046](https://user-images.githubusercontent.com/58545240/93054945-22acad00-f6a5-11ea-993a-d749bb895342.png)

예를 들면, 구간 [0, 5]의 합을 구하고 싶은데 깊이를 3으로 잡고 이걸 저렇게 [0, 1], [2, 3], [4, 5] 3개의 구간으로 나눠서 호출해 해결했다고 가정합니다.

근데... 이거 불가능하죠. 왜냐면 [0, 1]과 [2, 3]을 합한 구간 [0, 3]을 한번에 포함하는 상위의 노드가 엄밀히 존재하고 있습니다! 따라서 저런 호출은 절대 일어날 수가 없습니다.

이런 식으로 어떤 경우를 생각해봐도 **절대 하나의 깊이에서 3개의 호출이 일어날 일이 없습니다.**

따라서 호출은 많이 되어봐야 2*O(logN)번임을 알 수가 있죠!!



그럼 이제 우리를 이렇게 힘들게 만든, 어떤 원소의 값을 바꾸는 경우를 생각해 봅시다.

보통 update라는 이름의 함수나 연산으로 표현합니다.

만약 우리가 2번째 원소 -3을 어떤 값, 예를 들면 1로 바꾸었다고 합시다. 그럼 어떤 노드들의 값도 덩달아 바뀌어야 할까요?

![image-20200914160654341](https://user-images.githubusercontent.com/58545240/93054961-2809f780-f6a5-11ea-91b3-725e38cd829f.png)

이 노드들이죠. 2번 원소를 포함하는 구간이 있는 노드들!

이러한 노드는 각 깊이마다 단 1개이며, 그러므로 총 O(logN)개의 노드들의 값이 바뀌고

이건 리프 노드 값을 갱신한 후 부모를 찾아가며 루트까지 갱신을 계속해주면 됩니다.

그렇죠. 갱신에 필요한 시간이 **O(logN)**입니다!!!

원소 값을 바꾸는 연산, 구간 합을 구하는 연산 둘 다 시간복잡도가 O(logN)이므로, 값 개수 N과 쿼리 개수 Q가 주어지면 시간복잡도가 **O(QlogN)**이 됩니다!! 드디어 세그먼트 트리의 저력이 드러납니다.

```c++
// update
 void update(int i, int val){
        i += size;
        arr[i] = val;
        while(i > 1){
            i /= 2;
            arr[i] = arr[i*2] + arr[i*2+1];
        }
 }
```

update 함수는 이렇게 구현합니다. i번째 원소를 val로 갱신하라.

먼저 해당 원소가 있는 세그먼트 트리상의 진짜 노드 번호를 찾아야 합니다.

이 코드에서는 size가 값의 개수(2^K 꼴)라 가정했을 경우이고 그렇다면 size를 더해주면 그 인덱스가 되겠죠.

만약 size가 세그먼트 트리의 노드 개수였다면 size/2를 더해주면 될 것이구요.

이렇게 시작해서 i가 루트에 다다를 때까지 차례대로 부모를 방문해가며 값들을 갱신합니다. 자신의 왼쪽 자식 노드 + 자신의 오른쪽 자식 노드 값으로 갱신하면 됩니다.



맨 처음에 배열의 값을 초기화할 때도 이렇게 매번 업데이트 함수를 불러줘야 세그먼트 트리가 온전히 제작되겠죠.

아니면 초기화할 때만 리프 노드 값들만 먼저 조작해두고 그 다음 한 번에 모든 노드의 값을 깊은 곳부터 구해놓으면 연산 횟수가 줄어듭니다.

또한 세그먼트 트리의 특성상 **그 크기를 2^K 꼴로 맞춰주는 게 필수적**이므로 그러한 최소의 값을 찾아서 크기를 재조정해 주는 전처리도 필요합니다.



마지막으로, 필수적일 정도로 필요한 경우가 많지는 않으나 최적화에 꽤 도움을 주는 연산이 하나 더 있습니다. 바로 구축(construct) 연산입니다.

리프 노드들의 값을 미리 준 후, 이 값들로 세그먼트 트리를 구축하는 것인데 간단합니다.

```c++
void construct(){
    for(int i = MAX_ST/2-1; i > 0; --i)
        arr[i] = arr[i*2] + arr[i*2+1];
}
```

인덱스 [MAX_ST/2, MAX_ST)에 리프 노드들의 값이 있다고 할 때, 그 바로 위 노드들부터 인덱스가 감소하는 순으로 배열의 값을 구하는 것입니다.

값을 구할때 자신의 두 자식의 배열 값을 더해야 하는데, 인덱스가 감소하는 순으로 구하면 항상 제대로 된 값을 구할 수 있습니다.

각 노드를 한 번씩만 보니까 **O(N)**만에 세그먼트 트리를 만들 수 있습니다. 그냥 리프 노드를 하나하나 update하는 식으로도 구축은 가능하지만 **O(NlogN)**이 걸리게 됩니다. 확실히 이것보다는 빠르죠.



여튼간 이렇게 해서 구간 합, 구간 최댓값 등의 구간 정보를 매우 빠르게 구할 수 있게 되었습니다!

학교 자료구조나 알고리즘 커리큘럼에서는 잘 등장하지 않는 자료구조지만, 제가 상당히 재미있게 생각하는 자료구조이기도 하고 유용할 때도 많습니다.

## - BOJ[12015] : 가장 긴 증가하는 부분 수열2


세그먼트 트리를 활용할 수 있는 것 중 하나가 **LIS**(Longest Increasing Sequence)입니다.

어떤 수열에서 증가하는 부분 수열을 뽑을 때 그 최대 길이인데요... 이거 O(N^2) DP로 구할 수 있었죠!

그러나 인생은 만만치 않아서 대부분 O(NlogN) 알고리즘이 필요할 정도로 큰 N을 줘버립니다.

LIS를 구하는 방법은 이것 하나뿐이 아니라 이분 탐색을 사용하는 방법도 존재하는데(종만북에 짤막하게 나와 있음),

굳이 세그먼트 트리를 사용한다면 이렇게 구현할 수 있습니다.



방법은 이러합니다. A[i] = x 값들을 모두 받아서 각각 (x, i) pair들을 만든 후 x 값에 대해 오름차순 정렬합니다.

이 문제에서는 그렇지 않지만 일단은 **x 값들은 전부 구분된다**고 가정해보죠.

어쨌든 정렬하면 작은 x값부터 훑으면서 그게 등장하는 인덱스 i를 알 수 있게 됩니다.

이제 작은 x값부터 순회하면서, **A[i]=x인 i에 대해 구간 [0, i]에 지금까지 존재하는 LIS 길이 +1이 x로 끝나는 LIS 길이**입니다.

이렇게 순회하면서 등장하는 가장 큰 길이가 답입니다.



이 방법을 구현하려면 이렇게 하면 됩니다.

**구간 최댓값**을 구하는 세그먼트 트리를 사용합니다. 처음엔 모든 자리가 0으로 초기화되어 있습니다.

그리고 작은 x부터 순회하면서 A[i]=x인 **구간 [0, i]에서 최댓값을 구하고**, 그 값+1을 세그먼트 트리의 인덱스 i인 리프 노드 값으로 **업데이트**합니다.

이러면서 등장하는 값들 중 제일 큰 게 정답이고요.



수열이 [6, 1, 2, 7, 8, 3, 5, 4]라고 해봅시다.

![image-20200914160812042](https://user-images.githubusercontent.com/58545240/93054979-2f310580-f6a5-11ea-9f0a-c8c9f679acf6.png)

수열에 등장하는 원소가 오름차순으로 [1, 2, 3, 4, 5, 6, 7, 8]이네요.

맨 처음엔 A[i]=1인 i를 방문하게 되고 그 i는 1입니다.

먼저 구간 [0, 1]의 최댓값을 보는데 0입니다. 따라서 1로 끝나는 LIS 길이는 1이고, 그 1 값을 인덱스 1에 업데이트해 줍니다.

![image-20200914160825767](https://user-images.githubusercontent.com/58545240/93054988-322bf600-f6a5-11ea-8a12-75b3440ecc66.png)

그 다음은 A[2]=2이므로 2를 방문하는데, 구간 [0, 2]의 최댓값이 1입니다.

따라서 2로 끝나는 LIS의 최대 길이는 2고, 이걸 또 업데이트해 줍니다.

![image-20200914160837115](https://user-images.githubusercontent.com/58545240/93055004-38ba6d80-f6a5-11ea-97a2-28d841ad7683.png)

다음, A[5]=3이므로 5를 방문해서 같은 걸 합니다.

![image-20200914160849071](https://user-images.githubusercontent.com/58545240/93055017-3ce68b00-f6a5-11ea-9ebf-546abc129b2a.png)

다음, A[7]=4.

![image-20200914160859687](https://user-images.githubusercontent.com/58545240/93055053-4839b680-f6a5-11ea-95c3-ff5cf8adc8bf.png)

그 다음은 A[6]=5니까 6을 방문하는데, 이번엔 지금까지와 달리 결과가 증가하지는 않습니다.

지금까지 보면서 알 수 있는 점은, 새로 보는 원소가 기존의 LIS 길이를 증가시키려면 **그 원소가 기존의 LIS보다 뒤에 나타나야 하죠?**

그걸 확인하는 것이나 다름없는 행위가 구간 [0, i]의 최댓값을 보는 겁니다. 이게 구간 [0, i] 안에만 속한 LIS의 최대 길이를 의미하고,

어차피 이번에 훑은 인덱스 i는 아직까지는 등장하지 않았으므로 구간 [0, i-1]의 최댓값과도 같은 결과일 겁니다.

이번에 훑은 값이 i-1보다 큰 인덱스니까 지금까지 찾은 구간 [0, i-1]에 속한 LIS보다 뒤에 있음도 보장되고,

x 값을 오름차순으로 방문 중이므로 지금까지 등장한 모든 값들보다도 크다는 것마저 보장됩니다.

따라서 LIS에 꼬리를 하나 달아 이를 1 늘일 수 있는 것이죠!

![image-20200914160913966](https://user-images.githubusercontent.com/58545240/93055072-525bb500-f6a5-11ea-8ce1-3f1acd8e6ae9.png)

그 다음은 A[0]=6이니까 0을 방문하는데 보시다시피 제일 왼쪽이라 별 실적을 못 냅니다.

![image-20200914160927712](https://user-images.githubusercontent.com/58545240/93055079-55ef3c00-f6a5-11ea-9190-224c7182a645.png)

그 다음, A[3]=7이므로 3을 방문했습니다.

여기서 지금까지 등장한 LIS는 길이 4를 갖고 있지만 원소 7과는 전혀 상관없음을 관찰할 수 있는데

그러한 LIS 마지막 원소들은 다 7보다 오른쪽에 있기 때문이죠.

그러한 결과도 지금 세그먼트 트리는 충실하게 반영하고 있습니다.

![image-20200914160939359](https://user-images.githubusercontent.com/58545240/93055091-58ea2c80-f6a5-11ea-8585-14ede7b1a0c0.png)

마지막으로 A[4]=8이므로 4를 방문. 길이가 4나 되는 증가수열을 찾아냈지만 지금까지의 결과와 같네요.

최종적으로 답은 4라는 것을 알 수 있고 이건 사실 모든 연산을 끝마친 후 세그먼트 트리의 루트 값과도 같습니다.



그런데 지금까지는 중복되는 값이 없을 거라 가정하고 한 건데 만약 중복되는 값이 존재한다면 이게 답을 제대로 못 구할 수 있습니다.

문제에서는 [2, 2]를 증가수열로 치지 않기 때문(같으면 증가한 게 아님). 따라서 여기서 0번 인덱스 방문 후 1번 인덱스를 방문하면 답이 1인데 2를 구해버릴 수 있습니다.

이걸 방지하려면 **중복되는 값들 중에서는 가장 큰 인덱스부터 방문**하면 됩니다. 정렬할 때 애초에 그렇게 정렬해두면 됩니다. 값 오름차순 -> 인덱스 내림차순으로요.



LIS 예제를 보면서 느끼셨을 수 있지만... 세그먼트 트리 역시 막상 활용하려고 하면 좀 어렵습니다.

대체로 처음부터 세그먼트 트리를 써야하게 생겼다기보다는 뭔가 알고리즘을 구상하다가 이러이러한 연산을 빨리 해야 하는데 그게 혹 세그먼트 트리에 적합할지도 모르겠다 식의 루트로 이어지는 편...

또한 LIS도 그 자체로 쓰이거나 문제의 키가 될 때가 많아서 아예 독자적인 분야로 인식됩니다. LIS를 구하는 방법이 한 가지도 아니라서요...



또한 구간 합을 구하는 데만 미친듯이 최적화되어서 시간복잡도는 같지만 실제로 더 적은 시간과 공간을 들이는 **펜윅 트리**(fenwick tree)라는 게 있으며, 2^k 꼴인 N에 대해 N+1칸의 배열만을 사용합니다.

다른 이름으로 **바이너리 인덱스 트리**(binary indexed tree, BIT)라고도 합니다.

가끔 2차원 배열~~뭐?~~에 대한 구간 합을 구해야 하는 ~~막장~~ 문제들이 존재하는데 이때는 거의 2차원 펜윅 트리를 사용하고는 합니다.

## 세그먼트 트리 관련 추천 문제

**2042번: 구간 합 구하기**

연습 문제입니다. 문제에서 경고하듯이 배열의 자료형을 int가 아니라 64비트 정수형으로 두세요.



**11505번: 구간 곱 구하기**

이번엔 구간 곱을 구하는 문제입니다. 연산의 특성상 값이 커질 수 있어서 modular를 줬으니 이것만 주의하시면 됩니다.



**2357번: 최소값과 최대값**

이번에는 값 갱신 쿼리는 안 들어오지만 구간 최소값과 최대값을 세그먼트 트리로 구해야 합니다.

즉, 세그먼트 트리를 서로 다른 용도로 2개를 만들어서 써야 합니다.



**12837번: 가계부 (Hard)**

단순한 구간 합 트리입니다. 다만 오버플로우를 피하기 위해 자료형을 64bit 정수형으로 설정해야 하고,

1번 연산 해석에 주의해야 합니다. p일의 내용이 x가 되는 것이 아니라, x가 더해지는 겁니다.



**12015번: 가장 긴 증가하는 부분 수열 2**

위에서 설명한 문제로, 최대 LIS 길이를 찾아야 합니다.



**1275번: 커피숍2**

문제 자체는 굉장히 쉬운데, **꼭 x<=y이지는 않고**, 입력만 int형 안이랬지 합도 int형 안이란 보장은 없습니다. 함정이 많은 문제.



**2268번: 수들의 합**

역시 그냥 세그먼트 트리 그 이상도 이하도 아닙니다. 다만 확인은 못해봤는데 i>j일 수도 있으니 조심하세요.



**3745번: 오름세**

LIS 여러 번 구하는 문제입니다.



**1365번: 꼬인 전깃줄**

문제에서 주어지는 입력을 배열이라 할 때 이 배열의 **LIS** 길이가 답입니다.



**3006번: 터보소트**

숫자를 1->N->2->N-1->... 순으로 방문하면서 쿼리를 날려 원하는 구간 안에 수가 몇 개 남아있는지를 세면 됩니다. 이걸 구간 합 트리로 구현할 수 있죠. 이때 세그먼트 트리 리프 노드들의 값은 1로 초기화되어 있습니다.

그 수를 원래 자리 밖으로 빼면서, 그 수가 있던 인덱스 값은 0으로 업데이트해 줍시다.



**1280번: 나무 심기 (★)**

일단 같은 위치에 나무가 여러 개 심어질 수도 있습니다.

세그먼트 트리의 리프 노드들의 경우 인덱스 i인 칸이 이 칸에 심어진 모든 나무들에 대해 x=0으로부터의 거리 합이라 합시다. 뭐... 나무가 k그루 심어져 있다면 항상 ki겠죠.

중요한 건 매번 나무를 심을 때마다 이 나무와 그 이전의 모든 나무들의 거리 합을 구하는 것.

이건 이번에 심을 나무의 위치를 x라 할 때,

왼쪽에 있는 나무들과의 거리 합은 **cnt(0, x-1)\*x - sum(0, x-1)**,

오른쪽에 있는 나무들과의 거리 합은 **sum(x+1, MAX) - cnt(x+1, MAX)\*x**

임을 도출할 수 있습니다. 이 둘의 합이 비용이고, cnt는 구간 내 심어진 나무 개수고 sum은 0으로부터의 거리 합입니다.

long long을 쓰셔야 합니다. 당연히 cnt, sum은 서로 다른 세그먼트 트리로 구해야 합니다.



**3653번: 영화 수집 (★)**

매번 자신보다 위에 쌓여 있는 영화 개수를 구해야 하는데, 맨 위에 쌓는다는 게 좀 어렵습니다. 그럼 전체 배열의 인덱스가 바뀌어버리는 것 아닌가...?

그러나 트릭을 써서 처음부터 세그먼트 트리의 원소 개수를 2N개로 잡고, i번째로 영화를 빼내서 맨 위에 쌓을 때 N+i번 위치로 옮겨버립니다.

그리고 쿼리를 날려서 이번 영화가 있는 위치를 i라 하면 구간 [i, 2N]의 영화 개수를 구간 합 트리로 세서 반환하면 됩니다.



**9345번: 디지털 비디오 디스크 (★)**

이 문제는 쿼리를 곧이곧대로 받아들이면 안 됩니다. 세그먼트 트리의 리프가 각각 그 자리에 몇 번 DVD가 있는지를 나타내면 풀기 어렵습니다.

바꿔서, 세그먼트 트리의 리프가 k번이라면 **k번 DVD가 어느 위치에 있는지**를 저장해 두면 됩니다. 매번 L~R번 DVD가 있는 위치들 중 최솟값과 최댓값이 각각 L, R인지 확인하면 문제를 풀 수 있습니다! 한 단계 발상의 전환이 필요한 문제.



**2243번: 사탕상자 (★)**

전체에서 k번째로 작은 수를 찾아야 합니다. 그리고 중복되는 값이 여러 개일 수도 있네요.

이때는 **구간 합 트리**를 마련하고, 재귀적으로 k번째 값을 찾을 때, 자신의 왼쪽 노드 구간에 포함되는 사탕 개수가 k 초과면 왼쪽 노드를 방문해 찾고, k 이하면 오른쪽 노드를 방문하는데 이때는 (k-왼쪽 자식 노드 구간의 사탕 개수)번째로 작은 수를 찾으면 됩니다. 즉



**2336번: 굉장한 학생 (★)**

문제에서 정보를 너무 많이 줘서 혼란스럽고 어렵습니다.

일단 첫 번째 시험, 두 번째 시험, 세 번째 시험 등수 순으로 오름차순 정렬해놓고 **첫 번째 시험 등수가 낮은 학생부터 차례대로 순회**합시다.

일단 이번에 순회한 학생은 지금까지 방문한 모든 학생보다 **첫 번째 시험 등수가 높으니까** 조건 하나는 아예 볼 필요가 없어졌습니다. 이제 두 번째와 세 번째 시험 등수만 신경쓰면 됩니다!

즉 지금까지 순회한 학생들 중 두 번째, 세 번째 시험 등수가 모두 자신보다 낮은 학생이 한 명이라도 있는지 알아보면 됩니다!



이것을 **구간 최솟값 트리**로 구현합니다. ~~뭐?~~

**자신보다 두 번째 시험 등수가 낮은 학생들 중, 세 번째 시험 등수 중 최솟값**을 찾는 겁니다. 최솟값이니까 이 값이 자신의 세 번째 시험 등수보다 낮으면 자신은 바로 그 학생을 능가했으므로 굉장한 학생이 되는 것이죠!

이것을 구현하려면 세그먼트 트리의 각 리프 노드들이 이런 형태면 됩니다. i번 리프 노드는 **2번째 시험 등수가 i인 학생의 3번째 시험 등수.**

이런 식으로 먼저 구간 최솟값 쿼리를 날리고, 자신의 정보도 세그먼트 트리에 업데이트시켜 가면서 문제를 풀면 됩니다.



# **> 레이지 프로퍼게이션(Lazy Propagation)**

---

이번에도 트리에 관한 내용인데, 아마 다음엔 기하 관련 내용을 쓰지 않을까 싶습니다.

특히나 **세그먼트 트리**에 관한 내용입니다.

지금까지는 세그먼트 트리에는 2개의 연산이 있었습니다. 특정 인덱스의 값을 바꾸는 것과, 특정 구간의 합, 최댓값 등을 구하는 것.

그런데 **레이지 프로퍼게이션**(lazy propagation)이란 것을 사용하면 이런 연산도 가능합니다.



**특정 구간 [a, b]에 값 c를 동시에 더한다**



더한다는 연산은 다른 연산이 될 수도 있습니다. 보통은 구간합 트리가 많이 쓰이므로 더하는 연산이 됩니다.

저 연산을 naive하게 구현한다면 구간 [a, b] 안의 모든 인덱스에 c씩을 더하는 업데이트 연산을 할 것이므로 구간 길이가 K면 O(KlogN)의 시간이 드는데, K가 최대 N이니까 이 시간은 너무 클 수 있습니다.

레이지 프로퍼게이션을 사용한다면 이 연산 또한 단 **O(logN)**만에 가능합니다.

## - BOJ[10999] : 구간 합 구하기 2

https://www.acmicpc.net/problem/10999

이 문제에서 요구하는 연산이 이렇습니다...

이 문제의 예제의 초기 세그먼트 트리를 그림으로 나타내면 아래와 같습니다.

![image-20200922144426266](https://user-images.githubusercontent.com/58545240/93848065-aa1ca080-fce3-11ea-8190-5f43e1cf4a0a.png)

맨 아래의 리프 노드 5개가 실질적인 값입니다. 오른쪽의 빈 3개 리프 노드와 그 부모들은 그냥 생략했습니다.

구간 합을 구하는 것이야 그냥 원래 세그먼트 트리에서 하던 대로 하면 되는데,

그럼 이제 구간에다 일정한 값을 더하는 연산을 어떻게 구현할 것이냐...!!

기존의 각 노드에 대응하는 구간 합 배열에 추가로 노드마다 값이 존재하는 **lazy 배열**을 만듭니다.

lazy 배열이 의미하는 바는, **이 노드의 영역 전체에 얼마만큼의 값을 더할 계획이 있다**는 겁니다. 그러나 게을러서 아직 하지는 않았다... 언젠가는... 할 것이다... 이런 뜻입니다.



예를 들어, 맨 첫 번째 연산인 "1 3 4 6"을 시행하면 이와 같게 됩니다.

일단 구간 [3, 4]는 3, 4번 노드에 6을 더하라는 의미이므로...

![image-20200922144443197](https://user-images.githubusercontent.com/58545240/93848080-b1dc4500-fce3-11ea-804f-2f902de7b356.png)

해당 노드의 lazy 값이 6이 됩니다. 이건 이 노드 하의 값들에는 6을 더할 것이라는 의미입니다.

그러므로 훗날 만약 3번째나 4번째 인덱스를 포함한 구간의 합을 구해야 한다면, 6을 더한 결과를 알려줘야 한다는 겁니다.

물론 세상이 끝날 때까지 lazy 값을 저대로 방치할 수는 없고, 저 노드를 다시 만나게 되면 그제서야 자신의 자식 노드들로 lazy를 미룹니다. 이 과정이 propagation이 되겠습니다.

이렇게 계속 미루고, 미루다가 리프 노드에까지 lazy가 도달하게 되면, 리프 노드는 더 이상 미룰 자식이 없으므로 그냥 자신의 값에 lazy를 흡수합니다.



두 번째 연산 "2 2 5"를 시행하면, 저 [3, 4] 노드도 마주쳐야만 하므로 프로퍼게이션이 이루어집니다.

일단 나머지 인덱스 2, 5인 노드들이야 그냥 평소처럼 도달해서 값을 넘겨줄 것이고, 문제는 구간 [3, 4]인데요.

![image-20200922144457387](https://user-images.githubusercontent.com/58545240/93848093-b7398f80-fce3-11ea-957c-023a511a355d.png)

[3, 4] 노드가 자식들에게 lazy를 미루고, 자신은 6을 그만큼 더한 셈 치고 값에 12를 더합니다.

이 12는 자신이 포함하는 인덱스 개수인 2 * lazy 값 6입니다.

아직 리프 노드에 값이 더해진 건 아니지만 어쨌거나 언젠간 더할 것이고, 또 더한 것처럼 취급할 것이므로

앞으로 저 구간 노드를 만나면 더한 만큼의 값을 돌려주겠다는 겁니다.

결과적으로 쿼리의 답은 2+19+5=26이 됩니다.



그 다음 연산 "1 1 3 -2"를 가하면, 구간 [1, 3]은 노드 [1, 2]와 리프 노드 3으로 쪼개져 도달할 겁니다.

![image-20200922144508806](https://user-images.githubusercontent.com/58545240/93848115-bc96da00-fce3-11ea-8e7c-bcaf1cf42efb.png)

일단 [1, 2] 노드에는 아까처럼 lazy 값 -2가 생깁니다.

그리고 리프 노드 3은 도달했을 때 원래 lazy 값 6이 있었고, 자신이 리프니까 그냥 자기 값에 6을 더하고 나서 새로운 lazy 값 -2를 부여합니다.

그러나 여기서 끝이 아닙니다.

![image-20200922144523248](https://user-images.githubusercontent.com/58545240/93848139-c1f42480-fce3-11ea-9214-5dcd59f4bd9d.png)

일단 자기 자신이 리프면 lazy 값을 자기한테 매기는 수고를 하지 말고, 걍 자기 자신한테 그 값을 더해버리는 게 낭비가 없을 겁니다.

따라서 자신에게 lazy 값 -2를 부여하지 말고 그냥 자기 값에 -2를 더합시다.



게다가 지금 그림도 뭔가 이상합니다.

3번 노드에는 7, 4번 노드에는 실질적으로 4+6=10이 있는데 그 부모 노드는 합 17이 아닌 19를 담고 있네요.

이건 그 자식 중 하나에 -2 값이 빼졌는데도 그걸 갱신하지 않은 결과입니다.

따라서 자식들의 프로퍼게이션이 모두 이루어진 후, 자신의 값도 자식들의 값을 사용해 갱신해 주도록 합시다.

![image-20200922144618038](https://user-images.githubusercontent.com/58545240/93848158-c6204200-fce3-11ea-901d-29ca0260fa43.png)

최종 결과는 이렇게 됩니다.

4번 노드까지 lazy 값이 흡수된 게 뜬금없어 보일 수 있지만,

구간에 포함되건 안 되건 [3, 4] 노드가 자식 둘을 무조건 일단 호출은 하는 형태였으니까

호출을 하면 일단 자신의 lazy 값을 처리하게 되면서 이렇게 4번 노드도 처리가 된 것.



마지막 연산 "2 2 5"를 시행하면 인덱스 5야 아무것도 없으니까 제끼고, 리프 노드 2, 구간 노드 [3, 4]를 신경쓰면 될 것인데

구간 노드 [3, 4]야 보시는 대로 17이고, 리프 노드 5는 5, 남은 건 리프 노드 2인데...

![image-20200922144724108](https://user-images.githubusercontent.com/58545240/93848169-c9b3c900-fce3-11ea-9fa2-4c0e9af071e8.png)

리프 노드 2를 보기 위해 구간 노드 [1, 2]를 건드리면 거기 있던 lazy 값 때문에 프로퍼게이션이 일어나고, 결국 이렇게 됩니다.

그 결과, 쿼리의 답은 0+17+5=22가 됩니다.

```c++
#include <cstdio>
#include <algorithm>
using namespace std;
const int ST_MAX = 1<<21;
 
// 세그먼트 트리 구조체
struct SegTree{
    int start;
    long long arr[ST_MAX], lazy[ST_MAX];
 
    // 생성자
    SegTree(){
        start = ST_MAX/2;
        fill(arr, arr+ST_MAX, 0);
        fill(lazy, lazy+ST_MAX, 0);
    }
 
    // 리프 노드들의 값을 먼저 입력한 후 전체 세그먼트 트리 구축
    void construct(){
        for(int i=start-1; i>0; i--)
            arr[i] = arr[i*2] + arr[i*2+1];
    }
 
    // 구간 [ns, ne)인 node의 lazy 값을 propagate
    void propagate(int node, int ns, int ne){
        // lazy 값이 존재하면 실행
        if(lazy[node] != 0){
            // 리프 노드가 아니면 자식들에게 lazy 미룸
            if(node < start){
                lazy[node*2] += lazy[node];
                lazy[node*2+1] += lazy[node];
            }
            // 자신에 해당하는 만큼의 값을 더함
            arr[node] += lazy[node] * (ne-ns);
            lazy[node] = 0;
        }
    }
 
    // 구간 [s, e)에 k를 더하라
    void add(int s, int e, int k){ add(s, e, k, 1, 0, start); }
    void add(int s, int e, int k, int node, int ns, int ne){
        // 일단 propagate
        propagate(node, ns, ne);
 
        if(e <= ns || ne <= s) return;
        if(s <= ns && ne <= e){
            // 이 노드가 구간에 완전히 포함되면 lazy 부여 후 propagate
            lazy[node] += k;
            propagate(node, ns, ne);
            return;
        }
        int mid = (ns+ne)/2;
        add(s, e, k, node*2, ns, mid);
        add(s, e, k, node*2+1, mid, ne);
        // 마지막에 자식들의 값을 사용해 다시 자신의 값 갱신
        arr[node] = arr[node*2] + arr[node*2+1];
    }
 
    // 구간 [s, e)의 합을 구하라
    long long sum(int s, int e){ return sum(s, e, 1, 0, start); }
    long long sum(int s, int e, int node, int ns, int ne){
        // 일단 propagate
        propagate(node, ns, ne);
 
        if(e <= ns || ne <= s) return 0;
        if(s <= ns && ne <= e) return arr[node];
        int mid = (ns+ne)/2;
        return sum(s, e, node*2, ns, mid) + sum(s, e, node*2+1, mid, ne);
    }
};
 
int main(){
    // 초기 세그먼트 트리 입력받기
    int N, M, K;
    scanf("%d %d %d", &N, &M, &K);
    SegTree ST;
    for(int i=0; i<N; i++)
        scanf("%lld", ST.arr+ST.start+i);
    ST.construct();
 
    // 쿼리 처리
    for(int i=0; i<M+K; i++){
        int a, b, c, d;
        scanf("%d", &a);
        if(a == 1){
            scanf("%d %d %d", &b, &c, &d);
            ST.add(b-1, c, d);
        }
        else{
            scanf("%d %d", &b, &c);
            printf("%lld\n", ST.sum(b-1, c));
        }
    }
}
```

소스 코드입니다. propagate() 함수 부분을 주목하시면 됩니다.

또한 업데이트 함수도 구간을 받도록 바뀌었기 때문에, 구간 합 함수와 굉장히 구조가 비슷한 재귀 함수가 되었는데요.

이때 본인의 구간이 쿼리 구간에 완전 포함되면 lazy를 대신 매깁니다. 이때 바로 propagate를 해줘도 좋습니다.

또한 자신에서 함수가 종료되지 않았을 경우 마지막에 자식 노드들의 값을 통해 자신의 값을 갱신하는 것도 잊어서는 안 됩니다.



레이지 프로퍼게이션이 필요한 문제는 세그먼트 트리가 필요로 하는 연산이 무엇이냐에 따라 프로퍼게이션에서 처리해줘야 하는 일이 좀 달라지기 때문에 감이 잘 안 잡힐 수 있습니다.

물론 그냥 세그먼트 트리에 비해 등장빈도도 굉장히 적어도 연습하기도 힘든 건 덤. 응용문제를 풀어봅시다.

## - BOJ[12844] : XOR

https://www.acmicpc.net/problem/12844

일단 이 문제는 연산이 합에서 XOR로 바뀌었습니다. 프로퍼게이션을 구현하려면 연산의 성질을 잘 이해해야 합니다.

일단 뭐 모든 연산을 합에서 XOR 연산으로 바꾸면 되긴 하는데, 문제는

```c++
//자신에 해당하는 만큼의 값을 더함
arr[node] += lazy[node] * (ne-ns);
```

구간 합 트리에서의 이부분. 이 부분 어떻게 될까요?

답은 ... 이 줄이 사라집니다! 정확히는 리프 노드가 아니라면 이 줄을 지워도 됩니다.

```c++
void(propagate(int node, int ns, int ne)){
    if(lazy[node]!=0){
		if(node < start){
            lazy[node*2] ^= lazy[node];
            lazy[node*2+1] ^= lazy[node];
        }
        else arr[node] ^= lazy[node];
        lazy[node] = 0;
    }
}
```

이렇게 되는데, 왜 리프 노드일 때만 자신의 값을 갱신할까요?

왜냐면, 리프 노드가 아니라면 자신이 포함하는 구간은 항상 짝수 칸이기 때문입니다.

똑같은 값을 짝수 번 XOR 하면 0이 되죠... 따라서 하나 안 하나 결과가 그대로가 됩니다.



아, 이 문제 굉장히 양아치니까 조심하세요. 구간 정보 a, b가 들어왔을 때 a>b일 수도 있습니다...

## - BOJ[1395] 스위치

https://www.acmicpc.net/problem/1395

이 문제는 조금 더 어렵습니다. 일단 각 노드의 기본값은 이 구간 안에 켜져 있는 스위치 개수인 건 맞습니다.

문제는 lazy. 스위치는 항상 그 상태를 반전시킬 수만 있는데, 만약 하나의 스위치를 두 번 반전시키면 원래 상태가 되므로, lazy 값을 bool 타입으로 표현할 수 있습니다.

```c++
// 구간 [ns, ne)인 node를 propagate
void propagate(int node, int ns, int ne){
    if(lazy[node]){
        // 리프 노드가 아님
        if(node < start){
            lazy[node*2] ^= 1;
            lazy[node*2+1] ^= 1;

            // 왼쪽 자식과 오른쪽 자식의 결과로 자신의 결과 갱신
            int temp = 0;
            // 만약 왼쪽 자식 전체가 반전될 것이라면, 실질적인 값은 구간 크기 - 현재 값
            if(lazy[node*2]) temp += (ne-ns)/2 - arr[node*2];
            // 아니면 그냥 현재 값
            else temp += arr[node*2];
            // 오른쪽 자식도 마찬가지
            if(lazy[node*2+1]) temp += (ne-ns)/2 - arr[node*2+1];
            else temp += arr[node*2+1];

            arr[node] = temp;
        }
        // 리프 노드
        else arr[node] ^= 1;

        lazy[node] = false;
    }
}

// 구간 [s, e)의 상태를 반전시켜라
void turn(int s, int e, int node, int ns, int ne){
    propagate(node, ns, ne);
    if(e <= ns || ne <= s) return;
    if(s <= ns && ne <= e){
        // lazy 값을 반전시킴
        lazy[node] ^= 1;
        propagate(node, ns, ne);
        return;
    }
    int mid = (ns+ne)/2;
    turn(s, e, node*2, ns, mid);
    turn(s, e, node*2+1, mid, ne);
    arr[node] = arr[node*2] + arr[node*2+1];
}
```

propagate() 함수에서 자신의 arr 값을 갱신하는 부분을 주목해야 합니다.

lazy 값은 true 또는 false입니다. true면 반전을 시킬 거란 말입니다. 홀수 번 반전시키는 건 다 true와 같고, 짝수 번 반전시키는 건 다 false와 같죠.

이때, 만약 자기 자식의 lazy 값이 true라면 그 자식 구간에 속한 켜져 있는 스위치 개수는 사실상 arr 값의 반대일 겁니다. 왜냐면 앞으로 꺼져 있던 게 켜질 것이고 켜져 있던 건 꺼질 것이니까.

## 레이지 관련 추천 문제

**10999번: 구간 합 구하기 2**

위에서 설명한 문제입니다.



**12844번: XOR**

위에서 설명한 문제입니다.



**1395번: 스위치 (★)**

위에서 설명한 문제입니다.



**10713번: 기차 여행**

각 도로마다 이 도로를 전체 여행 중 몇 번 지나치는지를 각각 세야 하는데, 이를 구간 갱신 쿼리로 구합니다.

마지막으로 각 도로마다, A, B, C 값을 받아서 지난 횟수와 조합해 보고 어느 쪽이 더 싼지 각각 판단해서 더하면 됩니다.

다른 풀이가 존재하는 문제입니다.



**16404번: 주식회사 승범이네 (★)**

![image-20200922145234274](https://user-images.githubusercontent.com/58545240/93848237-fa93fe00-fce3-11ea-8b4d-632b27e16fd1.png)

사원들의 관계를 루트 노드가 정해진 트리로 나타내고, 위와 같이 서브트리가 반드시 연속된 수들로만 이루어지도록 전위 순회나 후위 순회로 각 사원에게 번호를 매길 수 있습니다.

그리고 번호를 매기면서 각 사원을 루트로 하는 서브트리에서 제일 작은 정점 번호와 제일 큰 정점 번호도 쉽게 구해 나갈 수 있습니다.

이렇게 각 사원에게 정점 번호를 부여한 후, 주어지는 질의를 이 정점 번호들에 대해서 하면 됩니다. 예를 들어 저기서 정점 번호가 6번인 사원에게 손익이 발생했다면 6~8 구간에 레이지 프로퍼게이션을 시행하는 식으로 풀 수 있습니다.



**13925번: 수열과 쿼리 13 (★)**

상당한 발상이 필요한 문제.

lazy 배열이 독특합니다. 기존에는 lazy[node] = k라면 node 휘하에 전부 k를 더할 것이라는 의미였는데, lazy 값으로 a, b 이렇게 2개를 관리해서 node 휘하의 모든 값을 a*(val) + b로 만들 것이라는 의미를 부여하면 문제를 풀 수 있습니다.

디폴트로는 a = 1, b = 0이면 되고, v를 더하는 연산은 b에 v를 더하고, v를 곱하는 연산은 a와 b에 v를 곱하고, v로 만드는 연산은 a = 0, b = v로 만드는 식으로 propagate하면 됩니다.



# **> 트라이(Trie)**

---

여튼 또 문자열인데, 이번엔 매칭 문제가 아니라 **여러 문자열을 저장하는 자료구조**를 소개해드릴 겁니다.

바로 **트라이**(Trie)인데, 트리와 굉장히 스펠링이 비슷하면서 트리와도 유사합니다. 아니, 아예 트리의 한 종류라고 해도 될 겁니다.

**래딕스 트리**(radix tree)나 **접두사 트리**(prefix tree)라고도 합니다.

![image-20200925093755756](https://user-images.githubusercontent.com/58545240/94215926-fe5c9600-ff18-11ea-82c5-326678856361.png)

예를 들어 {"he", "she", "her", "him", "show"}라는 문자열 집합이 있다면, 그들을 담고 있는 트라이는 그림과 같습니다. 빨간색 겹선 노드가 **여기서 끝나는 문자열이 있다**는 뜻으로, output이 있다고 하거나 final state, accepting node라고도 하는 등... 그런 의미가 있습니다.

왜 트라이의 별칭 중 접두사 트리라는 것이 있는지도 구조를 보면 파악할 수 있습니다.

여기 저장된 모든 문자열은 루트부터 시작해서 아래로 한 칸씩 내려가며 겹선 노드까지 가며 봐 온 문자를 순서대로 나열한 형태가 됩니다.

예를 들면 "him"이라는 문자열을 찾을 때까지 거쳐가는 경로는 루트->h->i->m인데, 도중에 문자열을 한 글자씩 붙이며 "", "h", "hi", "him"으로 완성됩니다. 이때 도중에 등장하는 문자열은 모두 접두사(prefix)이죠.

또한 집합 중 "he"는 또다른 원소 "her"의 접두사인데, "he"에 도달하는 경로가 "her"에 도달하는 경로에 포함되기도 합니다.



여튼 이제 트라이의 구조는 감이 잡히셨을 겁니다.

저렇게 트라이가 있을 경우 삽입, 탐색에 걸리는 시간은 그 문자열의 길이만큼의 시간이 드리라는 것은 자명합니다(보통 트라이에서 삭제를 하지는 않습니다).

문제는 **공간 복잡도**입니다. 저런 선형 시간이 나오려면, 찾는 문자열의 다음 글자를 보자마자 맞는 노드로 이동할 수 있어야 합니다.

이렇게 하려면, 영소문자만 단어에 올 수 있을 경우 26칸짜리 포인터 배열을 가지고 있다거나 해야 합니다. 따라서 포인터의 크기 * 26byte 만큼의 메모리가 노드 하나마다 필요하고, 트라이에 존재하는 **총 노드 개수**를 곱해야겠죠.

당연히 32~127 모든 아스키코드가 존재할 수 있다거나 하면 상황은 더 나빠집니다.

이 때문에 트라이 문제에서는 **입력 데이터의 전체 글자 개수는 얼마를 넘지 않는다**는 식의 조건을 자주 볼 수 있습니다.

경우에 따라 포인터 배열이 아닌 set(BST)으로 구현할 수도 있습니다.

## - BOJ[5052] : 전화번호 목록

https://www.acmicpc.net/problem/5052

이 문제가 트라이 문제 중 가장 쉽고, 트라이의 성질을 잘 사용하는군요.

문제를 읽어보시면 전화번호를 단어라고 했을 때, 영소문자 대신 숫자만 등장하는 경우입니다.

전화번호들을 모두 하나의 트라이에 저장할 것인데, 전화번호가 최대 만 개고 각각 10자리 이하이므로 등장하는 글자 개수는 최대 10만 개 이하라고 짐작할 수 있습니다.



일관성이 있다의 기준을 트라이만으로 해결할 수 있을까요?

아까 접두사 트리라는 이름과 트라이의 연관성을 살짝 설명해드린 것이 힌트가 됩니다.

![image-20200925093835008](https://user-images.githubusercontent.com/58545240/94215927-00bef000-ff19-11ea-90ad-919398066765.png)

첫 번째 예제입니다. 일관성이 없죠.

![image-20200925093853392](https://user-images.githubusercontent.com/58545240/94215929-03214a00-ff19-11ea-838b-3cc675fc20d9.png)

두 번째 예제는 일관성이 있습니다.

일관성이 있으려면, **그 어떤 전화번호도 다른 전화번호의 접두사가 되는 일이 없어야 합니다.**

그 말인 즉슨, 트라이의 관점에서 보자면 아까처럼 어떤 전화번호로 가는 경로에 다른 전화번호의 경로가 완전히 포함되면 안 된다는 겁니다.

전화번호의 끝 노드를 accepting node라고 하면, **모든 accepting node가 자식 노드를 가지지 않으면** 일관성이 있게 됩니다.



그럼, 트라이를 구현해 봐야겠죠.

```C++
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int GO_MAX = 10; // 트라이 노드마다 포인터 개수
 
struct Trie{
    Trie* go[GO_MAX]; // 다음 노드를 가리키는 포인터 배열
    bool output; // 이 노드에서 끝나는 전화번호가 있는가?
    bool goexist; // 이 노드의 자식이 있는가?
 
    // 생성자
    Trie(){
        fill(go, go+GO_MAX, nullptr);
        output = goexist = false;
    }
    // 소멸자
    ~Trie(){
        for(int i=0; i<GO_MAX; i++)
            if(go[i]) delete go[i];
    }
    // 문자열 key를 현재 노드부터 삽입
    void insert(const char* key){
        // 문자열이 끝남
        if(*key == '\0') output = true;
        // 아닐 경우
        else{
            int next = *key - '0';
            // 해당 노드가 없으면 새로 동적 할당해서 만듦
            if(!go[next]) go[next] = new Trie;
            goexist = true;
            // 자식 노드에서 이어서 삽입
            go[next]->insert(key+1);
        }
    }
    // 이 노드가 일관성이 있는가?
    bool consistent(){
        // 자식도 있으면서 여기서 끝나는 전화번호도 있다면 일관성 없음
        if(goexist && output) return false;
        // 자식들 중 하나라도 일관성이 없으면 이 노드도 일관성이 없음
        for(int i=0; i<GO_MAX; i++)
            if(go[i] && !go[i]->consistent()) return false;
        // 일관성이 있음
        return true;
    }
};
 
int main(){
    int T;
    scanf("%d", &T);
    for(int t=0; t<T; t++){
        int N;
        scanf("%d", &N);
        Trie *root = new Trie; // 루트 노드 만들기
        for(int i=0; i<N; i++){
            char tel[11];
            scanf("%s", tel);
            root->insert(tel);
        }
        puts(root->consistent() ? "YES" : "NO");
        // 소멸자를 호출하여 동적 할당 해제를 하지 않으면 힙 메모리가 부족할 수 있음
        delete root;
    }
}
```

제가 자주 사용하는 방식입니다. 각 노드를 필요할 때 동적 할당하는 방법이죠.

트라이 구조체 부분에서 consistent() 함수를 제외하고 보면 트라이 기본 구조를 알 수 있습니다.

이 문제에서 필요한 consistent() 함수의 경우 이 노드로부터 도달할 수 있는 전화번호들의 목록이 일관성이 있는지를 bool 타입으로 반환합니다.

트라이 또한 트리 구조이기 때문에 거의 모든 연산이 **재귀호출**의 형태를 띕니다.

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int GO_MAX = 10; // 트라이 노드마다 포인터 개수
 
struct Trie{
    Trie* go[GO_MAX]; // 다음 노드를 가리키는 포인터 배열
    bool output; // 이 노드에서 끝나는 전화번호가 있는가?
    bool goexist; // 이 노드의 자식이 있는가?
 
    // 생성자
    Trie(){
        fill(go, go+GO_MAX, nullptr);
        output = goexist = false;
    }
    // 소멸자
    ~Trie(){
        for(int i=0; i<GO_MAX; i++)
            if(go[i]) delete go[i];
    }
    // 문자열 key를 현재 노드부터 삽입. 삽입 후 일관성이 있는지를 리턴
    bool insert(const char* key){
        if(*key == '\0'){
            output = true;
            return !goexist; // 만약 자식이 있다면 일관성이 없다
        }
        int next = *key - '0';
        if(!go[next]) go[next] = new Trie;
        goexist = true;
        // 여기까지 온 시점에서 자식이 분명히 있는데, 여기서 끝나는 전화번호가 있다면 일관성이 없다
        return !output && go[next]->insert(key+1);
    }
};
 
int main(){
    int T;
    scanf("%d", &T);
    for(int t=0; t<T; t++){
        int N;
        scanf("%d", &N);
        Trie *root = new Trie; // 루트 노드 만들기
        bool result = true;
        for(int i=0; i<N; i++){
            char tel[11];
            scanf("%s", tel);
            // insert 함수가 일관성이 유지되는지를 즉각 리턴함
            if(result && !root->insert(tel)) result = false;
        }
        puts(result ? "YES" : "NO");
        // 소멸자를 호출하여 동적 할당 해제를 하지 않으면 힙 메모리가 부족할 수 있음
        delete root;
    }
}
```

헌데 트라이 구조를 잘 이해하셨다면 마지막이 아니라 그냥 삽입 도중에 답을 알 수도 있습니다.

어쨌거나 어떤 노드에서 끝나는 문자열과 자식이 동시에 있느냐만 알면 되니까,

삽입을 하는 도중에 그 경우가 일어나는지를 바로 체크해서 재귀함수를 통해 리턴하게 할 수 있습니다.

이 트라이 구조체의 경우 goexist와 output이 둘 다 true면 일관성이 없게 됩니다.

```c++
#include <cstdio>
#include <cstring>
using namespace std;
const int GO_MAX = 10; // 트라이 노드마다 포인터 개수
const int CHAR_MAX = 100000; // 트라이의 최대 글자 개수
 
struct Trie{
    int cnt; // 노드의 개수
    int go[CHAR_MAX+1][GO_MAX]; // 다음 노드 번호를 담고 있는 배열
    bool output[CHAR_MAX+1]; // 이 노드에서 끝나는 전화번호가 있는가?
    bool goexist[CHAR_MAX+1]; // 이 노드의 자식이 있는가?
 
    // 생성자
    Trie(){
        cnt = 1;
        memset(go, 0, sizeof(go));
        memset(output, 0, sizeof(output));
        memset(goexist, 0, sizeof(goexist));
    }
    // 문자열 key를 현재 노드부터 삽입. 삽입 후 일관성이 있는지를 리턴
    bool insert(const char* key, int node = 0){ // 루트의 번호는 0
        if(*key == '\0'){
            output[node] = true;
            return !goexist[node]; // 만약 자식이 있다면 일관성이 없다
        }
        int next = *key - '0';
        if(!go[node][next]) go[node][next] = cnt++;
        goexist[node] = true;
        // 여기까지 온 시점에서 자식이 분명히 있는데, 여기서 끝나는 전화번호가 있다면 일관성이 없다
        return !output[node] && insert(key+1, go[node][next]);
    }
};
 
int main(){
    int T;
    scanf("%d", &T);
    for(int t=0; t<T; t++){
        int N;
        scanf("%d", &N);
        Trie trie; // 트라이 자료 구조
        bool result = true;
        for(int i=0; i<N; i++){
            char tel[11];
            scanf("%s", tel);
            // insert 함수가 일관성이 유지되는지를 즉각 리턴함
            if(result && !trie.insert(tel)) result = false;
        }
        puts(result ? "YES" : "NO");
    }
}
```

또한, 동적 할당이 영 내키지 않으신다면 입력의 최대 문자 개수를 알 때 동적 할당 없이도 구현이 가능합니다.

위 코드는 Trie 구조체가 노드 하나가 아닌, 자료구조 하나를 구현하고 있는데요.

노드가 하나 생길 때마다 0, 1, 2, 3, ... 등의 번호를 순차적으로 부여하면서, go, output, goexist 값들을 전체 배열 하나로 통합합니다. 루트는 보통 0번입니다.

## -BOJ[5670] Cellphone Typing

https://www.acmicpc.net/problem/5670

정말 미친듯이 트라이스러운 문제입니다.

문제는 상당히 긴 편이지만 꽤 직관적이라서 이해하는 게 어렵지는 않으실 겁니다.

추천 단어들이 있는 사전이 있고, 추천 단어들만을 타이핑하고 싶을 때 자판기가 단어 완성을 100% 정확한 경우에만 바로바로 해주는 것인데요.

예를 들어 사전에 {"abc", "abcd", "xyz"}가 있다면 자판기에서 'a'를 타이핑하는 순간 a로 시작하는 모든 추천 단어는 "abc"로도 시작하므로 "abc"까지 자동 타이핑이 됩니다.

여기서 입력을 멈추면(멈추는 것은 별도의 타이핑 횟수로 세지 않습니다) "abc"가 입력되고, "d"를 더 치면 "abcd"가 입력되는 셈입니다.

즉 "abc"는 단 1번의 타이핑, "abcd"는 2번의 타이핑으로 끝낼 수 있습니다.

마찬가지로 맨 처음에 'x'를 타이핑하면 x로 시작하는 단어가 "xyz"뿐이고, 따라서 "x"로 시작하는 모든 단어는 "xyz"로도 시작하니까 "xyz"까지 자동 완성이 되고, "xyz"는 1번의 타이핑만으로 입력할 수 있습니다.

이때 사전 내의 모든 단어의 평균 타이핑 횟수를 구하는 것인데, 재귀호출로 구할 수 있어 보입니다.

![image-20200925101931041](https://user-images.githubusercontent.com/58545240/94215932-04eb0d80-ff19-11ea-8d7e-46524493e3ca.png)

확인차 첫 번째 예제를 트라이로 그려보면 위와 같습니다.

현재 노드의 서브트리 안에서 등장하는 문자열들을 치는 데 추가로 필요한 평균/총 타이핑 횟수를 구해서 반환해 주는 **재귀 함수**를 트라이에서 구현하면 풀 수 있습니다.

저는 일단 총 타이핑 횟수를 구한 후 마지막에 전체 단어 개수로 나누겠습니다.



가장 먼저 낼 수 있으면서 핵심이 되는 아이디어는, **어떤 노드의 자식이 단 하나뿐이라면 자동완성으로 현재 글자가 타이핑될 것**이라는 점입니다.

이런 글자가 연속적으로 나타난다면 전부다 자동 타이핑으로 넘어가겠죠.

만약 자동완성이 되지 않는다면, 해당 노드 서브트리에 속한 단어 개수만큼 총 타이핑 횟수가 필요할 겁니다.

또한 문제 조건에도 있듯이 루트에서는 자동완성이 안 됩니다. 즉 맨 첫 글자는 반드시 타이핑해야 합니다.

```c++
#include <cstdio>
#include <algorithm>
using namespace std;
 
struct Trie{
    Trie *go[26];
    bool output;
    int branch; // 가지, 즉 자식 노드의 개수
    int words; // 현재 노드 서브트리에 있는 단어의 개수
 
    // 생성자
    Trie(): output(false), branch(0), words(0){ fill(go, go+26, nullptr); }
    // 소멸자
    ~Trie(){
        for(int i=0; i<26; i++)
            if(go[i]) delete go[i];
    }
    // 트라이에 단어를 삽입하는 함수
    void insert(char *str){
        if(*str == '\0'){
            branch++;
            output = true;
        }
        else{
            if(!go[*str-'a']){
                branch++;
                go[*str-'a'] = new Trie;
            }
            words++;
            go[*str-'a']->insert(str+1);
        }
    }
    // 현재 노드에서 더 필요한 총 타이핑 횟수를 세는 재귀 함수
    long long cntKeystrokes(bool isRoot=false){
        long long result = 0;
        // 맨 처음이거나, 현재로부터 도달가능한 단어가 2개 이상이면 속한 단어 개수만큼 타이핑++
        // 바꿔 말하면, 위 경우가 아니면 타이핑이 필요없다
        if(isRoot || branch > 1) result = words;
        // 각 자식들의 결과를 모두 더해서 반환
        for(int i=0; i<26; i++)
            if(go[i]) result += go[i]->cntKeystrokes();
        return result;
    }
};
 
int main(){
    int N;
    while(scanf("%d", &N) > 0){
        Trie *root = new Trie;
        for(int i=0; i<N; i++){
            char W[81];
            scanf("%s", W);
            root->insert(W);
        }
        printf("%.2lf\n", 1.0*root->cntKeystrokes(true)/N);
        delete root;
    }
}
```

문제에 따라 트라이에서 노드마다 저장해 두어야 하는 값이 다양하게 변합니다.

위 전략대로 풀 경우 각 노드마다 현재 노드의 서브트리에 존재하는 단어 개수(words)를 담고 있으면 정말 좋을 것입니다.



트라이 응용 문제들은 예제로 트라이를 그려 보고 규칙을 관찰하다 보면 풀리는 경우가 많습니다.

다들 공책을 상비합시다!

## 트라이 관련 추천문제

**14425번: 문자열 집합**

메모리 1536 MB의 압박은 총 500만개의 노드를 다 저장하고서라도 트라이를 써보라는 말입니다. 저런 메모리 제한은 처음 보네요...

그러나 사실은 이 문제는 그냥 **해싱**(ounrdered_set)으로도 충분히 풀립니다.



**5052번: 전화번호 목록**

위에서 설명한 문제입니다.



**4358번: Hardwood Species**

문제 자체는 정말 쉽습니다. 그냥 각 나무마다 전체 나무들 중 얼마나 분포하는지를 % 단위로 세면 되는데요, 이건 output을 bool type 대신 카운팅 변수로 써서 전체 나무 개수로 나누면 쉽게 구할 수 있습니다.

단, 정말 어이가 없는 함정이 있는데 나무 이름에 영어와 공백뿐 아니라 특수문자도 들어갑니다. 32~127 사이의 아스키코드를 전부 사용합니다;;



**5670번: Cellphone Typing (★)**

위에서 설명한 문제입니다.



**3080번: 아름다운 이름 (★)**

문제의 규칙을 잘 관찰해 보면, 어떤 노드가 있을 때 그 노드의 서브트리에 속한 이름들을 정렬하는 방법은 순열과 관련이 있습니다.

첫 번째 예제를 봅시다. IVO는 첫 번째나 세 번째 자리에만 올 수 있는데 이는 J로 시작하는 두 이름이 반드시 붙어있어야 하기 때문입니다. J로 시작하는 두 이름의 순서는 상관이 없습니다.

따라서 IVO를 앞에 배치하느냐 뒤에 배치하느냐(2) * J로 시작하는 두 이름의 배치(2)의 경우의 수를 곱해 **4**가 됩니다.

두 번째 예제에서 "MARA", "MARICA", "MARTA", "MARTINA" 이 4개는 반드시 붙어 있어야 하는데 이는 모두다 "MAR"로 시작하기 때문. 따라서 그렇지 않은 "MATO"는 반드시 이 5개의 단어 중 맨 앞이나 뒤에 와야 합니다(*2).

그 다음, 저 "MAR"로 시작하는 4개의 단어들 중에서 "MART"로 시작하는 단어 2개는 반드시 붙어 있어야 하고 나머지 순서는 상관이 없죠. 이때 "MAR"로 시작하는 단어들 중 "MAR" 다음 글자는 'A', 'I', 'T' 총 3개이므로 이때 경우의 수는 순열 3P3 = 3!이 됩니다.

마지막으로 "MART"로 시작하는 두 단어의 순서는 상관없으므로 *2. 따라서 답이 2*6*2=**24**입니다.



규칙을 일반화하면 어떤 노드에서 **공백을 포함하여** 존재하는 다음 글자의 개수가 k이면 k!만큼의 경우의 수를 곱해 주는 식으로 결과를 구할 수 있습니다.



**5446번: The Great Cleanup (★)**

"rm ~~*" 형식의 명령어를 최소 횟수로 써서 지워야 하는 파일을 모두 지워야 합니다. 이때, 지우면 안 되는 파일도 있어서 골치아프죠.

형식에서 애스터리스크가 반드시 맨 끝에만 올 수 있기 때문에 접두사를 매우 잘 써먹을 수 있게 되고 이는 곧 트라이를 사용한다는 아이디어로 직결됩니다.



어떤 노드에 도달하는 문자열이 P라고 합시다. 이때 "rm P*"를 사용할 수 있는 경우는 **P로 시작하는 파일 중 지우면 안 되는 파일이 하나도 없을 경우**입니다.

따라서 각 노드마다 이 노드 서브트리에 지워야 하는 파일이 존재하는지와 지우면 안 되는 파일이 존재하는지를 bool 변수로 저장해두는 것이 유용합니다. 그리고 각 노드마다 P로 시작하는 파일들을 모두 지우는 데 필요한 최소연산횟수를 재귀호출로 구하면 해결할 수 있습니다.



재귀함수를 모델링했다면 다음과 같은 3가지 경우가 생깁니다.

**P로 시작하는 지워야 하는 파일이 하나도 없다면** 연산이 아예 필요없습니다! 이때는 바로 0을 리턴합니다.

**P로 시작하는 지우면 안 되는 파일이 하나도 없다면** "rm P*"를 사용해서 모든 파일을 지울 수 있으므로 바로 1을 리턴합니다.

이도저도 아닐 경우 자식들을 재귀호출에 결과를 모두 더하면 되겠죠. 이때 주의할 점은, 파일명이 P인 파일이 존재할 경우 이걸 지우기 위해 "rm P"를 한 번 써야 합니다! 따라서 노드의 output 값을 보고 1을 더해 줘야 합니다.

# **> 최소 공통 조상(LCA)**

---

>   Lowest Common Ancestor

LCA 알고리즘이란 주어진 트리에서 `최소 공통 조상`을 찾는 알고리즘입니다.

`최소 공통 조상` 이란 두 정점 `u`, `v`에서 가장 **가까운** 공통 조상입니다. 

u이거나 u의 조상이면서 동시에 v이거나 v의 조상인 노드들 중 가장 깊은 노드(가까이 있는) 노드이죠.

![image-20210505114551055](https://user-images.githubusercontent.com/58545240/117093255-63277b00-ad9b-11eb-9f2a-c81c723b3c18.png)

이런 트리가 있을 때, 4번 정점과 3번 정점의 LCA는 1번 정점입니다.

이때 빨간색으로 칠해진 간선들을 이어보면 두 정점 사이의 최단 경로가 됩니다.

![image-20210505114620505](https://user-images.githubusercontent.com/58545240/117093030-c1079300-ad9a-11eb-81c6-960efbe2c2e0.png)

10번 정점과 14번 정점의 LCA는 2번 정점입니다.

![image-20210505114704673](https://user-images.githubusercontent.com/58545240/117093050-ca90fb00-ad9a-11eb-85a4-d0459f953a51.png)

3번 정점과 13번 정점의 LCA는 3번 정점입니다.

트리에는 싸이클이 없으므로, 두 정점 u, v의 LCA를 w라 하면 두 정점 사이의 최단 경로는 u-w-v 형태의 경로가 됩니다. 이걸 지금까지의 빨간 간선들로 확인할 수 있죠.

이것이 대부분의 LCA 문제에서 아주 중요한 경로입니다. 트리에서 너무 지나칠 정도로 최단경로를 빨리 찾기를 원한다면 LCA를 먼저 생각해 봐야 합니다.



LCA를 찾는 방법은 여러 가지가 있는데, 세그먼트 트리를 사용하는 방법이 종만북에 나와 있지만

저는 다른 방법을 선호합니다. DP를 사용하여 바텀업으로 각 정점의 정보들을 저장해 놓는 방식.

양쪽 다 크기 N인 트리에서 **O(logN)**만에 두 특정 정점의 LCA를 찾을 수 있습니다.



LCA를 가장 단순하고 쉽게 찾는 방법은, 그냥 두 정점 중 깊이가 더 깊은 정점에서 계속 부모로 이동합니다. 둘의 깊이가 같아질 때까지.

그리고 두 정점이 만날 때까지 두 정점을 동시에 부모로 이동시키면, 두 정점이 만나는 지점이 LCA가 됩니다.

그러나 이건 최악의 경우 **O(N)**입니다. 뭐 실제 상황에서 최악의 치우쳐진 트리가 맨날천날 나오지는 않겠지만, 대회문제에서는 무조건 반드시 나오겠죠.

기본적인 알고리즘은 위와 동일하지만, 부모로 이동시키는 것을 좀 더 빨리, 더 많이 건너뛰는 것이 아이디어입니다.

## 알고리즘 동작과정

1.  입력받은 정점과 간선을 이용해 양방향 그래프를 생성합니다.
2.  depth와 parent을 가지는 트리를 생성합니다. (이 때 누가 누구의 조상인지 알 수 있도록 하여야 합니다.)
3.  LCA(u, v) 즉, u와 v의 공통 조상이 누구인지 조사합니다.
    1.  LCA 알고리즘에서는 깊이가 더 깊은 노드를 깊이가 더 낮은 노드까지 올려줍니다.
    2.  서로 다른 깊이를 가지는 노드를 같은 깊이를 가지는 노드로 만들어 주면
    3.  한 칸(2<sup>k</sup>)씩 조상을 올려다보며 조상이 같아질때까지 올라갑니다.
    4.  두 조상이 같으면 그 조상이 바로 LCA가 됩니다.

## - BOJ [11437] : LCA

https://www.acmicpc.net/problem/11437

문제 이름부터 LCA를 쓰라고 나와있습니다.

이 문제는 쉬우므로 바로 소스코드를 보겠습니다.

```java
/*
    LCA (Lowest Common Ancestor): 최소 공통 조상
    depth를 모두 구하고 부모 자식 간에 관계를 구하여 트리를 만든 다음에
    구하고자 하는 정점의 depth를 맞춰준 다음 같은 노드가 될 때까지 부모를 타고 하나씩 올라오면 된다.
*/
import java.io.*;
import java.util.*;

public class p11437 {
    static int n, m;
    static int[] parent, depth;
    static List<List<Integer>> list;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;
        n = Integer.parseInt(br.readLine());
        list = new ArrayList<>();
        for (int i = 0; i <= n; i++) {
            list.add(new ArrayList<>());
        }
        
        // 트리 생성
        for (int i = 0; i < n - 1; i++) {
            st = new StringTokenizer(br.readLine());
            int u = Integer.parseInt(st.nextToken());
            int v = Integer.parseInt(st.nextToken());
            list.get(u).add(v);
            list.get(v).add(u);
        }

        parent = new int[n + 1];
        depth = new int[n + 1];

        // 루트노드 1, depth 1을 시작으로 각 정점들의 depth를 구한다.
        dfs(1, 1);

        m = Integer.parseInt(br.readLine());
        for (int i = 0; i < m; i++) {
            st = new StringTokenizer(br.readLine());
            int u = Integer.parseInt(st.nextToken());
            int v = Integer.parseInt(st.nextToken());

            int ret = lca(u, depth[u], v, depth[v]);
            System.out.println(ret);
        }
    }

    // dfs가 아닌 bfs로 각 노드의 depth를 구해도 된다.
    // depth 및 부모 관계 설정
    static void dfs(int from, int cnt) {
        depth[from] = cnt++;
        for (int next : list.get(from)) {
            // depth가 0이 아니면 이미 depth를 구한 노드이다.
            if (depth[next] != 0) continue;

            dfs(next, cnt);
            parent[next] = from;
        }
    }

    // LCA 알고리즘 
    static int lca(int a, int aDepth, int b, int bDepth) {
        // 두 노드의 depth가 같아질 때까지 한쪽을 올린다.
        if (aDepth > bDepth) {
            while (aDepth != bDepth) {
                aDepth--;
                a = parent[a];
            }
        } else if (aDepth < bDepth) {
            while (aDepth != bDepth) {
                bDepth--;
                b = parent[b];
            }
        }
        // 두 노드의 높이를 같게 했다.

        // 그 이후에 depth를 똑같이 증가시키다가 (내 윗 부모가 되는 것이 올라가는 과정)
        // 만난 같은 정점이 가장 가까운 공통 조상이 된다.
        while (a != b) {
            a = parent[a];
            b = parent[b];
        }

        return a;
    }
}
```

## - BOJ [11438] : LCA2

https://www.acmicpc.net/problem/11438

문제를 풀어버려야만 합니다.

https://kks227.blog.me/220793361738

위 글에서 사용한 개념인 희소 테이블을 그대로 도입해서 유용하게 쓸 수 있습니다!

방법을 설명하자면, 원래는 자신의 부모 하나만을 parent 배열로 저장하던 것을 확장하여

2차원 배열 parent\[u][k]로 만듭니다. 이는 **정점 u의 2^k번째 부모**입니다.

![image-20210505120226773](https://user-images.githubusercontent.com/58545240/117093064-d4b2f980-ad9a-11eb-84c4-1fa73f8d53d4.png)

표로 나타내면 다음과 같습니다.

그렇다면 이제 이 배열을 사용하여, 정점을 건너뛰는 것을 좀 더 빨리 할 수 있습니다.

일단, 2^(k+1) = 2^k + 2^k이므로, **parent\[u][k+1] = parent[ parent\[u][k] ]\[k]**의 식으로 구할 수 있습니다.

이렇게 k=i일 때의 정보가 모두 있다면 k=i+1일 때의 정보를 그에 기반하여 얻을 수 있으므로, 바텀업 DP를 사용하여 parent 배열을 채울 수 있습니다.



이제 이 parent 배열을 사용해서 LCA를 빨리 찾아야 합니다.

아까 LCA를 찾는 방식을 이렇게 2개의 단계로 나눌 수 있었습니다. 두 정점 u, v가 있고 depth[u] >= depth[v]일 때,

**① depth[u] > depth[v]일 때, u를 parent[u]로 대체하는 것을 반복한다.**

**② u != v일 때, u를 parent[u], v를 parent[v]로 동시에 대체하는 것을 반복한다.**

이제 이 두 과정을 새로운 parent 배열로 좀 더 빨리 해야 합니다.



먼저 **①**은 이렇게 할 겁니다.

만약 u와 v의 깊이가 딱 보기에도 너무너무 많이 차이가 나는데도 부모를 하나씩 하나씩 따라 올라가고 있는 건 멍청한 짓입니다.

만약 둘의 깊이 차이가 11이라면 이것은 이진수로 1011(2)이므로, 2^0번째 부모->2^1번째 부모->2^3번째 부모를 따라가면 될 겁니다. 그럼 단 3번만 따라가면 됩니다. 검사는 4번 하죠.

이럴 때는 둘의 깊이 차이가 최대 O(N)이니까, 이진수로 나타냈을 때 비트 수가 O(logN)이므로 O(logN)번의 검사와 따라가기만으로 둘의 깊이를 같게 만들 수 있습니다.



그 다음, **②**도 비슷합니다. 여기로 넘어왔으면 일단 depth[u] == depth[v]인 상태입니다.

이제 둘의 깊이는 항상 똑같이 유지되면서 정점들이 바뀌어갈 겁니다.

만약 parent\[u][k] != parent\[v][k]라 합시다. 그럼 일단 두 정점 u, v의 LCA의 깊이는 둘로부터 2^k보다는 멀리 떨어져 있음이 확실합니다.

그런데 이 상태에서 parent\[u][k+1] == parent\[v][k+1]이다? 그렇다면 2^k, 2^(k+1) 사이의 어딘가에 둘의 LCA가 있다는 것이겠죠.

이제 k를 큰 값부터 시도하면서 순회하여, parent\[u][k] != parent\[v][k]이면 u, v를 동시에 2^k만큼 위로 올려보내면 될 것입니다.

```cpp
#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>
using namespace std;
const int MAX = 18; // roundup log(2, 100000)
 
int N, M;
int parent[100000][MAX]; // parent[i][k]: i의 2^k번째 부모
int depth[100000]; // 정점의 깊이 (루트의 깊이: 0)
vector<int> adj[100000]; // 인접 리스트
 
// dfs로 트리 제작하며 parent[i][0], depth 배열 채움
void makeTreeByDFS(int curr){
    for(int next: adj[curr]){
        if(depth[next] == -1){
            parent[next][0] = curr;
            depth[next] = depth[curr] + 1;
            makeTreeByDFS(next);
        }
    }
}
 
 
 
int main(){
    // 트리 정보 입력
    scanf("%d", &N);
    for(int i=0; i<N-1; i++){
        int u, v;
        scanf("%d %d", &u, &v);
        u--; v--;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    // 배열 초기화
    memset(parent, -1, sizeof(parent));
    fill(depth, depth+N, -1);
    depth[0] = 0;
    // 트리 만들기
    makeTreeByDFS(0);
 
    // parent 배열 채움
    for(int j=0; j<MAX-1; j++)
        for(int i=1; i<N; i++)
            if(parent[i][j] != -1)
                parent[i][j+1] = parent[parent[i][j]][j];
 
    // 쿼리 입력받기
    scanf("%d", &M);
    for(int i=0; i<M; i++){
        int u, v;
        scanf("%d %d", &u, &v);
        u--; v--;
 
        // depth[u] >= depth[v]가 되도록 필요에 따라 u, v를 스왑
        if(depth[u] < depth[v]) swap(u, v);
        int diff = depth[u] - depth[v];
 
        // 깊이 차(diff)를 없애며 u를 이동시킴
        for(int j=0; diff; j++){
            if(diff % 2) u = parent[u][j];
            diff /= 2;
        }
 
        // u와 v가 다르면 동시에 일정 높이만큼 위로 이동시킴
        if(u != v){
            // 높이 2^17, 2^16, ..., 2^2, 2, 1 순으로 시도
            for(int j=MAX-1; j>=0; j--){
                if(parent[u][j] != -1 && parent[u][j] != parent[v][j]){
                    u = parent[u][j];
                    v = parent[v][j];
                }
            }
            // 마지막엔 두 정점 u, v의 부모가 같으므로 한 번 더 올림
            u = parent[u][0];
        }
 
        // LCA 출력
        printf("%d\n", u+1);
    }
}
```

입력을 받아서 트리를 형성하는 부분도 있습니다. 보통 트리 관련 문제는 다 이런 전처리가 들어가죠.

희소 테이블 글에서 설명한 문제와는 좀 다르게, 여기서는 다음 이동이라는 게 없을 수도 있습니다. 즉, 조상이 없는 경우죠. 이 코드에서는 "-1" 값으로 그걸 초기화해 두고 사용하고 있습니다.



그럼 LCA가 유용한 건 어떨 때일까요?

가장 유명한 예시는 트리상에서 두 정점의 거리를 빠르게 구하는 것입니다.

## - BOJ [1761] : 정점들의 거리

https://www.acmicpc.net/problem/1761

그래프가 아니라 트리이기 때문에 이 문제를 푸는 것이 가능합니다.

두 정점 u, v가 주어지고 이 두 정점 사이의 거리를 구하라면, 애초에 트리에서는 두 정점 사이의 경로가 하나뿐이니까 최단이고 뭐고 없습니다. 그냥 어떻게든 거리를 구하면 되는데요.

이때 이 경로는 LCA를 w라 하면 u-w-v의 형태가 됩니다.

즉 거리는 (u와 w 사이의 거리) + (v와 w 사이의 거리)가 되는 것입니다. LCA를 구하면 해결되죠.

이때, 모든 정점 사이의 거리를 바로 알기는 힘들지만, 어떤 루트 r이 있다고 치면

u와 w 사이의 거리는 (u와 r 사이의 거리) - (w와 r 사이의 거리)가 되므로,

루트를 아무거나 하나 정하고 모든 정점에 대해 자신과 루트 사이의 거리를 구해두면 될 것입니다.

## LCA 관련 추천 문제

**11438번: LCA 2**



위에서 설명한 문제입니다.



**1761번: 정점들의 거리**



위에서 설명한 문제입니다.



**8012번: Byteasar the Travelling Salesman**



정점들의 거리 문제와 유사한데, 단지 마을을 일정 순서대로 방문해야만 한다는 점만 다릅니다.

예제에서는 1, 3, 2, 5 순으로 방문하라는데 시작점은 항상 1이니까 1~1, 1~3, 3~2, 2~5의 거리의 총합이 답이 됩니다.



**15480번: LCA와 쿼리 (★)**



조금 생각을 해봐야 하는 문제. r을 신경쓰지 않고 먼저 u와 v의 LCA를 구했는데 그게 w라고 해봅시다. 만약, 이때 w가 r이거나 w의 조상 중에 r이 있다면 그냥 w가 답이겠죠. 아닌 경우들을 처리해야 합니다.



**①** 먼저 관찰할 수 있는 것은, 꼭 r이 w의 조상이 아니더라도 w가 답인 경우가 존재한다는 것입니다. 이건 현재 트리의 루트에서 한쪽 서브트리에 w가, 다른 어떤 서브트리에 r이 속한 경우입니다. 이는 w가 r의 조상이 아닐 때에 해당하는데 이 여부는 w와 r의 LCA를 다시 구해서 판단할 수 있죠. LCA가 w면 w가 r의 조상인 겁니다.

**②** u나 v 중 하나가 r의 조상이라면 답은 조상인 그 노드가 됩니다. 만약 둘 다 조상이라면 r에 좀 더 가까운 쪽이 답입니다.

**③** u와 w 사이 또는 v와 w 사이 어딘가에 r이 있을 경우, 이때는 u와 r, v와 r의 LCA를 각각 구해서 케이스 분류를 할 수 있습니다. u와 r의 LCA가 w의 자손이거나 w라면 이게 답이 되는 식.

...



이렇게 케이스 분류를 세세하게 하면서 풀어야 하는 문제입니다. 핵심은 u와 v, u와 r, v와 r의 LCA를 구해보는 것이고, 간소화해 보면 위보다 더 간단히 추스릴 수도 있습니다.



**1396번: 크루스칼의 공 (★)**



상당히 발상이 재미있는 문제. 먼저 주어진 그래프에서 **크루스칼 알고리즘**을 통해 미니멈 스패닝 트리를 만드는 과정을 시뮬레이션하면서, 어떤 시간에 두 컴포넌트가 서로 합쳐진다면 그 두 컴포넌트 각각을 자식으로 하는 새 노드를 만듭니다. 이 노드는 이제 합쳐진 컴포넌트를 의미합니다.

이런 식으로 트리를 구성해 두면, 쿼리가 주어졌을 때 노드 x와 노드 y의 LCA를 찾아 이 노드에 대응하는 시간이 언제인지를 구할 수 있습니다. 구현이 상당히 까다롭습니다.

놀랍게도 다른 풀이가 존재합니다. 언젠가 그걸 볼 날이 오길...