# **C Coding Style Guide**

> 아래는 소프트웨어 개발 시 준수해야 하는 코딩 스타일을 정의하고 가이드한다. `C`언어를 대상으로 하고 있으며 `C99`표준이 적용된다. ( 추후 C11 등 최신 표준으로 변경 적용 가능하며, 이에 따라 본 문서의 내용이 일부 변경될 수 있다.)
>
> 해당 가이드는 [구글 C++ 코딩 스타일 가이드](https://google.github.io/styleguide/cppguide.html)를 기반으로 필요에 따라 일부 내용을 수정, 변경하여 적용하였다.

# **코딩 명명법**

---

프로젝트를 진행하면서 선언하는 변수명,함수명,클래스명 등 여러가지 이름들의 명명법에는 규칙이있다.

대표적으로 카멜표기법, 파스칼표기법, 스네이크 표기법이 있는데 하나씩 알아보겠다.

## 카멜(Camel) 표기법

```java
int manAge;
int womanAge;

int peopleAge(int man, int woman) {
    return man + woman;
}
```

변수명과 함수명을 카멜표기법으로 작성한 예이다.

카멜표기법은 낙타등처럼 내려갔다 올라가는 모양인데 woman+age 처럼 단어 여러개가 붙을때 맨 앞에오는 단어만 소문자로 표기하고, 뒤에오는 단어는 대문자로 표기하는 방법이다. (**세단어 이상일경우도 맨앞만 소문자**)

## 파스칼(Pascal) 표기법

```java
int ManAge;
int WomanAge;

int PeopleAge(int man, int woman) {
    return man + woman;
}
```

파스칼 표기법은 그냥 모든단어가 대문자로 시작한다.

함수명이나 클래스명을 파스칼표기법으로 작성하는 경우가 많은데, 보통 카멜과 파스칼표기법을 섞어 적절히 사용하기도한다.

## 스네이크(Snake) 표기법

```java
int man_age;
int woman_age;

int people_age(int man, int woman) {
    return man + woman;
}
```

언더바(_) 를 붙여 단어를 구분짓는 표기법이다.

사실 변수명을 선언할 때는 종종 쓰이기도 하지만 잘 쓰이진 않는것같다.

# **헤더파일**

---

> 헤더파일을 바르게 사용하는 것으로 코드의 가독성과 크기, 성능에 큰 차이를 만들 수 있다.

- **define guard**

  - *헤더파일이 중복 포함되는 것을 방지하기 위해, 모든 헤더파일 내에 #define 가드를 사용한다*

    #define 가드의 형식은 `<PROJECT>_<PATH>__<FILE>_H_`이며, `<PATH>`는 프로젝트 소스 디렉토리로부터의 하위경로로 표시된다.

    ```C
    // foo/src/bar/baz.h
    
    #ifndef FOO_BAR_BAZ_H
    #define FOO_BAR_BAZ_H
    
    #endif // FOO_BAR_BAZ_H
    ```

- **인라인 함수**

  - *10줄 이하이면서 `for, while, switch` 문을 포함하지 않은 함수만 인라인 함수로 정의한다.*

- **-inl.h 파일**

  - *복잡한 인라인 함수의 정의로 인해 헤더파일이 지저분해질 경우, 인라인 함수만 정의하는 `-inl.h` 접미어가 붙은 헤더파일을 추가로 사용한다.*

- **함수 인자 순서**

  - *함수의 인자는 입력 인자, 입출력 인자, 출력 인자 순서로 정의한다.*

    단순히 새로운 변수라고 해서 가장 뒤에 추가하지 않는다.

    단, 관련된 함수들과의 일관성을 위해 이 규칙을 따르지 않을 수 있다.

- **include 형식**

  - *시스템 라이브러리 및 다른 라이브러리의 헤더파일을 include할 때는 `"<", ">"`를 사용한다.*

  - *현재 프로젝트의 헤더파일을 include할 때는 쌍 따옴표(`"`)를 사용한다.*

  - *모든 프로젝트 헤더파일은 현재 디렉터리 기준의 상대경로 `".", ".."`를 사용하지 않고, 프로젝트 소스 디렉토리 기준의 하위경로로 표시한다.*

    ex) google-awesome-project/src/base/logging.h는 다음과 같이 #include된다.

    ```c
    #include "base/logging.h"
    ```

- **include 순서**

  - *include하는 헤더파일의 순서는*

    1. 시스템 라이브러리의 헤더파일(들)
    2. 다른 라이브러리의 헤더파일(들)
    3. 현재 프로젝트의 헤더파일(들)

    *의 순서로 구역을 나누어 작성하며, 각 구역 내 헤더파일의 순서는 알파벳 순서를 따른다*

    이를 통해 가독성을 높이고 숨겨진 종속성을 피할 수 있다.

    ex) google-awesome-project/src/foo/internal/fooserver.c

    ```c
    // 1) 시스템 라이브러리
    #include <sys/types.h>
    #include <unistd.h>
    
    // 2) 다른 라이브러리
    #include <other_libs.h>
    
    // 3) 현재 프로젝트
    #include "base/basictypes.h"
    #include "base/commandlineflags.h"
    #include "foo/public/bar.h"
    ```

    **예외)** (시스템 의존적인) 조건부 include는 가장 아래에 작성한다.

    ```c
    #include "base/port.h" // LANG_CXX11를 위해
    
    #ifdef LANG_CXX11
    #include <initializer_list>
    #endif // LANG_CXX11
    ```

# **서식**

---

> 코딩 시 모두가 통일된 스타일을 사용하면 프로젝트를 파악하기 쉬워진다.
>
> 각자가 모든 서식 규칙에 동의하기 어렵고, 일부는 익숙해지는데 시간이 걸리지만, 프로젝트 구성원들이 규칙에 따라 코드를 작성함으로써 서로의 코드를 쉽게 이해하도록 하는 것은 중요하다

- **줄 길이**

  - *코드의 각 줄은 120 문자를 넘지 않게 한다.*

- **문자형식**

  - *문자는 되도록 ASCII 문자를 사용하고, ASCII가 아닌 문자를 사용할 경우에는 UTF-8 형식을 사용한다.*

- **들여쓰기**

  - *단계 당 2개의 스페이스로 들여쓰기(indentation) 하고 탭은 사용하지 않는다.*

    코드 상의 그 어디에서도 탭을 사용하지 않는다.

- **중괄호**

  - *중괄호로 묶이는 모든 코드블럭에서, 각 중괄호 `"{", "}"`는 구문에 따라 같은 줄에 작성하거나 줄바꿈하여 작성한다.*

    ```c
    // 함수 내용을 여는 중괄호와 닫는 중괄호는 모두 새로운 줄에 작성한다.
    int Function(int a)
    {
    }
    
    // 구조체 내용을 여는 중괄호와 닫는 중괄호는 모두 새로운 줄에 작성한다.
    struct Structure
    {
    };
    
    // 열거형 내용을 여는 중괄호와 닫는 중괄호는 모두 새로운 줄에 작성한다.
    enum eCode
    {
    };
    
    // 조건문 내용을 묶는 중괄호는 같은 줄에 작성하고, 닫는 중괄호는 새로운 줄에 작성한다.
    // 단, 가독성이 현저하게 낮은 경우 가독성 향상을 위해 묶는 중괄호를 새로운줄에 작성할 수도 있다.
    if (condition) {
        DoSomething();
    }
    
    // switch 문을 묶는 중괄호는 같은 줄에 작성하고, 닫는 중괄호는 새로운 줄에 작성한다.
    // 단, 가독성이 현저하게 낮은 경우 가독성 향상을 위해 묶는 중괄호를 새로운줄에 작성할 수도 있다.
    switch (var) {
        case 0:
            ...
    }
    ```

  - *모든 조건문(if, switch)와 반복문(for, while)에서 중괄호를 반드시 사용한다. 본문이 한 줄인 경우에도 중괄호를 사용한다.*

    ```c
    if (condition) {
        DoSomething();
    }
    
    while (condition) {
        DoSomething();
    }
    
    switch (var) {
        case 0:
            ...
    }
    ```

- **강제 줄 바꿈**

  - *모든 조건문(if, switch), 반복문(for, while)의 표현식이 정해진 가로 줄 길이를 초과할 경우, 가독성 좋게 정렬하여 줄바꿈한다.*

    1. 일관성 있게 줄바꿈 한다.
    2. 각 줄의 시작지점을 통일한다.
    3. 보통 연선자 뒤에서 줄바꿈한다.

    ```c
    if ((this_one_thing) > this_other_thing) &&
        (a_third_thing == a_fourth_thing) &&
        yet_another &&
        last_one) {
        ..
    }
    ```

- **함수 선언과 정의**

  - *기본적으로 리턴 타입과 함수이름, 인자를 같은 줄에 작성하지만, 정해진 가로 줄 길이를 초과할 경우 줄바꿈하여 작성할 수 있다.*

    ```c
    // 기본 형식
    ReturnType FuctionName(Type var1, Type var2)
    {
        DomSomething();
    }
    
    // 한줄에 작성하지 못할 경우, 리턴 타입 작성 후 줄바꿈하여 작성한다.
    ReturnType
    ReallyLongFunctionName(Type var1, Type var2, Type var3)
    {
        DoSomething();
    }
    
    // 리턴 타입을 제외한 함수이름, 인자만으로도 한줄에 작성하지 못할 경우, 리턴타입과 함수이름을 한줄에 작성하고, 각 인자를 서로 다른 줄에 작성한다.
    ReturnType ReallyLongLongLongLongLongFunctionName(
    	Type var1,
    	Type var2,
    	Type var3)
    {
        DoSomething();
    }
    ```

  - **주의사항**

    - 여는 괄호 "`(`"는 항상 함수 이름과 같은 줄에 작성한다.
    - 닫는 괄호 "`)`"는 항상 마지막 인자에 붙여서 작성한다.
    - 함수 일므과 여는 괄호 "`(`" 사이에는 스페이스를 넣지 않는다.
    - 여는 괄호 "`(`" 및 닫는 괄호 "`)`"와 인자 사이에는 스페이스를 넣지 않는다.
    - 각 인자 사이에는 쉼표 + 하나의 스페이스를 사용하여 구분한다.
    - 여는 중괄호 "`{`" 는 항상 닫는 괄호 "`)`" 다음 줄에 작성한다.
    - 닫는 중괄호 "`}`"는 혼자 마지막 줄에 위치해야 한다.
    - 모든 인자는 이름을 가져야 하며, 선언과 구현에서 같은 이름을 가져야 한다.
    - 함수 내 기본 들여쓰기는 2개의 스페이스다.
    - 모든 인자들은 가능한 한 정렬되어야 한다.
    - 인자들이 다음 줄로 이동할 경우 2개의 스페이스 들여쓰기를 사용한다.
    - 인자들이 다음 줄로 이동할 경우 한 줄당 하나의 인자만 작성한다.

- **함수 호출**

  - *기본적으로 한 줄로 작성하지만, 정해진 가로 줄 길이를 초과할 경우 줄바꿈하여 작성할 수 있다.*

    ```c
    // 기본 형식
    bool retval = FunctionName(argument1, argument2, argument3);
    
    // 같은 줄에 작성하지 못하는 경우, 첫 번째 인자를 제외한 나머지 인자들을 별도의 줄에 작성한다.
    // 인자의 시작위치는 동일하다.
    bool retval = ReallyLongLongLongLongLongFuctionName(argument1,
                                                        argument2,
                                                        argument3);
    ```

- **switch문**

  - *case 구문은 스페이스 2개로 들여쓰기 한다.*
  - *case 구문의 본문은 스페이스 4개로 들여쓰기 한다.*
  - *항상 `default` 구문을 포함해야 한다, default 케이스가 실행되지 말아야 할 경우 assert()하거나 사용자가 알 수 있도록 로그 출력 등을 수행해야 한다.*

  ```c
  switch (var) {
      case 0:
          ...
          break;
          
      case 1:
          ...
          break;
          
      default:
          assert(false);
  }
  ```

- **반복문**

  - *비어 있는 반복문은 세미콜론 `";"`대신 중괄호 `"{}"`를 사용하고, 중괄호는 조건문 다음에 붙여서 작성한다.*

    ```c
    for (int i = 0; i < kSomeNumber; ++i) {}
    while (condition); // 나쁨
    while (condition) {} // 좋음
    ```

- **리턴값**

  - *return 표현식을 불필요하게 괄호로 묶지 않는다.*

    ```c
    return result;	// 좋음 - 괄호 사용이 필요 없는 간단한 경우
    return (some_long_condtion && another condition);	// 좋음 - 복잡한 표현식의 가독성을 높이는 경우 괄호가 허용됨.
    return (value);	// 나쁨
    return(result);	// 나쁨
    ```

- **전처리기 지시자**

  - *전처리기 지시자의 `"#"` 기호는 항상 그 줄의 처음에 작성한다. (들여쓰기 된 코드의 내부의 전치리기 지시자 포함)*

    ```c
    // 좋음 - 지시자가 줄의 처음부터 시작한다.
    #define NORMAL
    if (lopsided_score) {
    #if DISATER_PENDING	// 좋음
        DropEverthing();
    #if NOTIFY // 좋음
        NotifyClient();
    #endif
    #endif
        BackToNormal();
    }
    
    // 나쁨 - 지시자가 들여쓰기 되어 있다.
    if (lopsided_score) {
        #if DISASTER_PENDING // 나쁨
        DropEverything();
        #endif // 나븜
        BackToNormal();
    }
    ```

  - *전처리기 지시자가 코드블럭을 감싸고 있는 경우, 닫는 부분 `"#endif"` 뒤에는 여는 부분에 명시된 조건을 주석으로 표시한다.*

    ```c
    if (lopsided_score) {
    #if DISASTER_PENDING
        DropEverything();
    #if NOTIFY
        NotifyClient();
    #endif // NOTIFY
    #endif // DISASTER_PENDING
        BackToNormal();
    }
    ```

- **가로 공백**

  - *줄 끝에는 공백 문자를 사용하지 않는다.*

    줄 끝에 공백문자를 두면 같은 파일을 편집하는 다른 사람이 기존의 뒤쪽 공백문자를 삭제할 경우, 코드 내용의 변경이 없이도 코드변경이 발생한다.

- **가로 공백 - 일반사항**

  - *연속적으로 나열된 인자나 변수들을 구분하는 쉼표 `","`뒤에는 하나의 스페이스를 넣는다.*

    ```c
    int i, j;
    int x[] = { 0, 1, 2};
    ```

  - *모든 문장의 콜론 `":"`과 세미콜론 `";"` 앞에는 스페이스를 넣지 않는다.*

    ```c
    int i = 0;	// 모든 문장의 세미콜론 앞에는 스페이스를 사용하지 않는다.
    
    switch (i) {
        case 3:	// switch 문의 case 구문의 콜론 앞에는 스페이스를 사용하지 않는다.
            ...
    }
    
    out:	// goto 문에서 사용되는 분기구문의 콜론 앞에는 스페이스를 사용하지 않는다.
    ```

  - *각 괄호 `"(", ")"`와 괄호 안 내용 사이에는 스페이스를 넣지 않는다. 괄호 안 내용 자체는 가독성을 위해 스페이스를 사용할 수 있다.*

    ```c
    int ret - Fuction(a, b);
    int result = 1 + (a + b);
    for (int i = 0; i < 5; ++i)
    ```

  - *중괄호 `"{", "}"`를 이용한 리스트 초기화 시, 중괄호와 괄호 안 내용 사이에는 하나의 스페이스를 넣는다. 괄호 안 내용 자체도 가독성을 위해 스페이스를 사용할 수 있다.*

    ```c
    int x[] = { 0, 1, 2 };
    ```

- **가로 공백 - 반복문과 조건문(if, else, if, for, while)**

  - *조건문/반복문의 키워드(if, else, if, switch, for, while)와 여는 괄호 `"("` 사이에는 하나의 스페이스를 넣는다.*

    ```c
    // 좋음
    if (condition)
    switch (var)
    while (condition)
    ```

  - *조건문/반복문에서 갈 괄호 `"(", ")"`와 조건구문/반복구문 사이에는 스페이스를 넣지 않는다.*

    ```c
    // 좋음
    switch (var)
    ```

  - *for문에서 세미콜론 `";"`다음에는 하나의 스페이스를 넣는다.*

    ```c
    for (int i = 0; i < 5; ++i)
    for (; i < 5; ++i)
    ```

- **가로 공백 - 연산자**

  - *연산자(=, +, -, /, %, >>, <<, ^, &, |) 전후에는 각각 하나의 스페이싀를 넣는다.*

    하지만 가독성을 위해서 각 항마다 스페이스를 넣지 않을 수 도 있다.

    ```c
    a = (w * y) + (t / z) - 1;
    a += 3;
    a = b >> 3;
    a = b ^ 2;
    a = y | 3;
    a = z & 3;
    a = (w*y) + (t+z);	// 가독성을 위해 스페이스 생략 가능
    ```

  - *단항 연산자(예, -, ++, !)와 그 인자 사이에는 스페이스를 넣지 않는다.*

    ```
    x = -5;
    ++x;
    if (x && !y)
    ```

- **세로 공백**

  - *세로 공백의 사용을 최소화 한다.*

    꼭 필요한 경우가 아니면 빈 줄을 사용하지 않는다. 더 많은 코드가 화면에 들어올수록 프로그램의 흐름을 따라가거나 이해하기 쉽다. 단, 지나치게 조밀한 코드는 가독성을 저해하므로 적절한 수준을 유지해야 한다.

  - *함수 사이에 3개 이상의 빈 줄을 추가하지 않는다.*

  - *함수의 시작이나 끝 부분에 빈 줄을 사용하지 않는다.*

  - *함수 내부에서도 빈 줄을 되도록 사용하지 않는다.*

    단, 가독성 향상을 위해 블록 별로 빈 줄을 구분 할 수도 있다.

- **if문**

  - *else if 또는 else 문은 이전 if문 또는 else if 문을 닫는 중괄호와 같은 줄에 작성한다*

    필요한 경우 가독성을 위해 이전 중괄호의 다음줄에 작성할 수 도 있다.

    ```c
    // 기본 형식
    if (condition) {
    } else if (condition) {
    } else {
    }
    ```

    

# **이름규칙**

---

- **이름규칙**

  일관성을 위해 가장 중요한 것은 이름 규칙을 따르는 것이다.

  이름의 스타일을 통해 요소의 선언을 찾지 않고도 해당 요소가 타입인지, 변수인지, 함수인지, 상수인지, 혹은 매크로인지 바로 알 수 있다.

  이름 규칙은 개인의 선호도보다 일관성이 더 중요하다. *합리적이라고 생각하든 아니든 규칙은 지켜야 한다.*

- **일반**

  - *함수 이름, 변수 이름, 파일 이름은 약어를 사용하지 않고 서술형으로 짓는다.*

    가능한 상세한 이름을 사용한다. 다른사람이 즉시 이해할 수 있는 것이 글자 길이를 줄이는 것보다 중요하다.

    제 3자에게 익숙하지 않은 약어를 사용하지 않으며, 축약하지 않는다.

  ```c
  // 좋은 예
  int price_count_reader;	// 축약 없음.
  int num_errors;	// 누구나 이해 가능
  int num_dns_connections; // DNS 정도면 누구나 이해 가능
  
  // 나쁜 예
  int n; // 의미 없음
  int nerrr; // 모호한 축약
  int n_comp_conns; // 모호한 축약
  int wgc_connections; // 내부자만 아는 단어
  int pc_reader; // pc의 의미는..?
  int cstmr_id; // 중간 단어 축약
  ```

- **파일이름**

  - *파일 이름은 모두 소문자로 구성하고 대시 `"-"`를 포함할 수 있다.*

    단, 특정 프로젝트 내에서 대시 `"-"` 대신 언더바 `"_"`를 사용하는 경우, 해당 프로젝트의 관례에 따라 언더바 `"_"`를 사용할 수 있다.

  ```c
  // 사용 가능한 파일 이름
  my_useful_class.c
  my-useful-class.c
  myusefulclass.c
  myusefulclass_test.c
  ```

  - *이미 존재하는 파일 이름은 사용하지 않는다.(errno.h 등)*

  - *파일 이름은 되도록 상세하게 짓는다.*

    예를 들면 `http_server_logs.h`가 `logs.h`보다 좋다.

  - *인라인 함수는 헤더 파일에 정의한다.*

    인라인 함수의 코드가 짧으면 `.h` 헤더 파일 안에 정의하고, 길다면 `-inl.h` 헤더 파일 안에 정의한다.

  ```c
  url_table.h	// 헤더파일
  url_table.c // 모듈파일
  url_table-inl.h // 많은 코드를 포함한 인라인 함수 헤더 파일
  ```

- **디렉터리 이름**

  - *디렉터리 이름은 모두 소문자로 구성하고 대시 `"-"`를 포함할 수 있다.*

    단, 특정 프로젝트 내에서 대시 `"-"` 대신 언더바 `"_"`를 사용하는 경우, 해당 프로젝트의 관례에 따라 언더바 `"_"`를 사용할 수 있다.

- **타입 이름**

  - *타입 이름은 대문자로 시작하며, 언더바 `"_"` 없이 단어마다 첫 글자를 대문자로 작성한다.*

    구조체, typedef, 열거형을 포함한 모든 타입에 대해 동일한 규칙이 적용된다.

  ```c
  // 구조체
  struct UrlTablePropertiesStruct 
  {
  	...    
  }
  
  // typedef
  typedef struct UrlTablePropertiesStruct * UrlTableProperties;
  
  // 열거형
  enum eUrlTableErrors
  {
      ...
  };
  ```

- **변수 이름**

  - *변수 이름은 모두 소문자로 작성하며 단어 사이에 언더바 `"_"`를 사용한다.*

    지역변수, 전역변수, 구조체 멤버 변수 모두 동일한다.

  ```c
  int table_name;	// 좋음 - 언더바 사용
  int tablename;	// 좋음 - 모두 소문자
  int tableName;	// 불가 - 대문자 사용
  ```

  - *전역변수는 `"g_"`와 같이 지역 변수와 구분할 수 있는 접두어를 사용한다.*

  ```c
  int g_table_num;
  ```

- **상수 이름**

  - *상수 이름은 k로 시작하고, 대소문자가 섞인 형태(매 단어의 첫글자를 대문자)를 사용한다.*

  ```c
  const int kDaysInAWeek = 7;
  ```

- **함수 이름**

  - *함수 이름은 대문자로 시작하고 각 단어의 첫글자를 대문자로 쓰며, 언더바 `"_"`는 사용하지 않는다.

  ```c
  AddTableEntry()
  DeleteUrl()
  ```

- **열거형 이름**

  - *열거형 이름은 접두어 `"e"`를 붙이고, 각 단어의 첫 글자를 대문자로 쓰며 언더바 `"_"`는 사용하지 않는다.*

    열거형 정의 코드 바로 밑에 해당 열거형의 변수 타입 및 이름을 재지정(`typedef`)하고, 코드상에서는 재 지정된 열거형 이름을 사용한다.

    각 열거형 값은 상수 이름 형식으로 작성하며, 필요시 공통 접두어와 각 값의 의미 구문을 언더바 `"_"`로 구분할 수 있다.

  ```c
  enum eResultCode
  {
      kResultSuccess,
      kResultFail
  };
  typedef unit16_5 ResultCode;
  
  enum eStatusCode
  {
      kStatus_Init,
      kStatus_Run
  };
  typedef int StatusCode;
  ```

- **매크로 이름**

  - *매크로 정의는 대문자와 언더바 `"_"`만 사용할 수 있고, 값, 수식 등을 정의할 때에는 반드시 괄호를 사용해야 한다.*

  ```c
  #define ROUND(x) ...
  #define PI_ROUNDED (3.0)
  ```

- **이름 규칙의 예외**

  - *표준 기술을 구현하는 경우, 해당 표준 문서 상의 표현과 통일성을 갖기 위해 표준 문서 상에 정의된 이름/형태를 그대로 사용할 수 있다.*

  ```c
  // 표준에 정의된 프리미티브 형식
  DATA-TX.request {
  	Data,
      Length
  }
  
  // 구현
  DATA_TX_request (char *Data, int Length)
  ```

  - *동일한 도메인에 속한 다른 사람이 쉽게 이해할 수 있는 이름의 경우, 약어를 사용할 수 있다.*

    변수 이름에 사용되는 약어는 모두 소문자를 사용한다.

    `타입 이름, 함수 이름, 상수 이름, 열거형 이름` 등에 사용되는 약어는 모두 대문자를 사용한다.

  ```c
  // MAC Protocol Data Unit의 약어 = MPDU
  
  uint8_t mpdu[];	// 변수 이름에서는 모두 소문자로 사용
  int ConstructMPDU(uint8_t *payload); // 함수 이름에서는 모두 대문자로 사용
  ```

- **기타**

  - *상식적이고 일관성있게 작성ㅎ산다.*

    코드를 수정하는 경우 잠시 주변의 코드를 살펴 그것의 스타일을 판단하고, 해당 코드와 일관성을 가지도록 작성한다.

  - *이 스타일을 따르지 않는 기존 코드와의 일관성을 유지하기 위해 본 가이드라인을 따르지 않을 수 있다.*

# **변수 범위**

---

> 변수의 범위를 적절히 조점함으로써 코드의 가독성이나 성능을 높일 수 있다.

- **지역 변수**

  - *함수 내 변수는 가능한 한 좁은 범위에 둔다.*

    `C99` 이상에서는 함수 어디에서나 변수 선언을 할 수 있지만, 변수를 가능한 한 국한된 범위로 선언하고 최대한 첫 번째 사용처에 가깝게 선언한다. 이는 읽는 사람이 선언을 찾고 변수의 타입과 초기값을 알아내는 것을 쉽게 한다.

  - *되도록 선언과 동시에 초기화 한다.*

    ```C
    // 나쁨 - 선언과 초기화가 분리되어 있다.
    int i;
    i = f();
    
    // 좋음 - 선언과 동시에 초기화 된다.
    int j = g();
    ```

  - *for, if, while 문에서 조건검사에 사용되는 변수는 되도록 해당 라인에서 변수를 선언한다.*

    이 경우 해당 변수명은 코드의 다른부분에서 재 선언 가능하다.

    ```c
    for(int i = 0; i < 10; i++)
    while (const char* p = strchr(str, '/')) {
        str = p + 1;
    }
    ```

  - *성능 면에서 변수를 반복문 내에서 선언하기 보다는 반복문 앞에서 선언하는 것이 좋다.*

    물론 가능할 경우에만 적용한다.

    ```c
    // 나쁨 - 선언이 반복문 내에 있다.
    for(int i = 0; i< 10000; i++) {
        int j;
        handling(j);
    }
    
    // 좋음 - 선언이 반복문 밖에 있다.
    int j;
    for (int i = 0; i < 10000; i++) {
        handling(j);
    }
    ```

# **주석**

---

> 주석은 코드의 가독성을 유지하는 데 매우 중요하다.
>
> 하지만 이와 별개로, 가장 좋은 주석은 코드 자체이다. 즉, 최대한 주석없이도 코드 만으로 이해할 수 있도록 코드를 작성한다.
>
> 타입과 변수, 함수 등에 이해할 수 있는 이름을 적용하는 것이 이상한 이름을 짓고 주석으로 설명하는 것보다 낫다.
>
> 주석을 작성할 때에는 그 코드를 보고 이해해야 하는 사람을 위해 성실하게 작성한다.

- **주석스타일**

  - `//` 또는 `/ * * / `를 사용하되 일관성 있게 사용한다. 되도록 `//`를 사용한다.

    주석의 내용과 위치, 작성 방식에 일관성을 가져야 한다.

- **파일 주석**

  - *모든 파일의 시작 부분에는 라이선스 문구를 작성하고 그 뒤에 내용에 대한 설명을 작성한다.*

- **라이선스**

  - *모든 파일은 라이선스 문구를 퐇마한다. 또는 동일 라이선스 범위를 갖는 파일들의 최상위 디렉토리에 라이선스 문구를 포함한 별도의 텍스트 파일을 둔다.*

    프로젝트에서 사용하는 적절할 라이선스 문구를 선택한다.

- **파일 내용**

  - *모든 파일의 위쪽에는 파일의 내용에 대한 주석을 작성한다.*

    `.h` 파일은 그 안에 정의된 것들과 그들이 사용되는 방식에 대한 설명을 포함한다.

    `.c` 파일은 구현에 대한 세부사항이나 알고리즘 등에 대한 내용을 포함한다. 해당 내용이 `.h` 파일읅 읽는 사람에게도 필요할 경우에는 `.h`파일에 넣고, `.c`파일에는 해당 내용이 `.h`파일에 포함되어 있다는 것을 명시한다.

  - *`.h`와 `.c` 파일에 중복된 내용을 사용하지 않는다.*

    언젠가 서로 다르게 된다.

- **함수 주석**

  - *함수의 사용방법에 대해서는 함수 구현부에 주석으로 작성한다.*

    (오픈 API와 같이 선언부만 공개되는 경우에는 선언부와 구현부에 모두 작성한다)

    모든 함수의 선언 직전에, 그 함수가 무엇이고 어떻게 사용하는지에 대한 설명이 주석으로 작성 되어야 한다.

    단, 함수의 동작방식에 대한 자세한 설명은 언급하지 않는다.

    

    다음과 같은 내용이 포함된다.

    - 입력은 무엇이고 출력은 무엇인지
    - 함수 내에서 메모리를 할당하는 경우, 호출자가 해제해야 하는지 여부
    - 인자 중 어떤 것이 null 포인터가 될 수 있는지
    - 함수 사용시 성능 상의 영향이 있는 경우
    - 필요 이상으로 자세하게 서술하지 않으며, 설명이 사소한 경우 주석을 생략한다.

  - 함수 사용방법에 대한 주석은 `doxygen` 형식 " `/ * *`"으로 작성한다

    `@brief, @param, @return`은 필수로 작성한다.

  - *함수의 동작방식에 대해서는 함수 구현부에 주석으로 작성한다.*

    함수가 동작을 어떻게 수행 하는지에 대해 언급한다.

    함수가 작업을 수행하는 데 까다로운 부분이 있는 경우, 이에 대한 설명을 주석으로 작성한다.

    `.h` 파일이나 혹은 어딘가에 있을 함수 선언부의 주석을 단순히 반복해서는 안 된다.

- **변수 주석**

  - *일반적으로 변수의 이름은 주석이 필요 없도록 이해하기 쉽게 정한다.*

- **구조체 멤버 변수**

  - *구조체 내 멤버 변수는 그 것이 무엇을 위한 것인지 설명하는 주석을 가지며, `doxygen` 형식 "` / / / `"으로 작성한다.*

- **전역 변수**

  - *모든 전역 변수는 그것이 무엇이며 어디에 사용되는지에 대한 주석을 가진다.*

    ```c
    // 이 테스트에서 통과한 테스트케이스의 총 개수
    int g_testcase_num = 6;
    ```

- **구현 주석**

  - *구현에서 까다롭거나, 명백하지 않거나, 흥미롭거나, 중요한 부분은 주석을 작성한다.*

  - *까다롭거나, 복잡한 코드 조각은 그 앞에 주석을 작성한다.*

  - *명확하지 않은 부분의 줄 끝에는 주석을 작성한다.*

    코드와 주석은 스페이스 2개로 분리한다.

    ```c
    // 충분한 메모리가 있는 경우, 데이터 부분도 mmap으로 처리한다.
    if (mmap_budget >= data_size && !MampData(mmap_chunk_bytes, mlock)) {
    	return;		// 오류는 이미 로그에 기록되었다.
    }
    ```

  - *null pointer나 boolean, 문자로 된 숫자값을 함수에 전달할 때, 그것들이 무엇인지에 대한 주석을 추가하거나 상수를 사용하여 코드가 스스로 설명할 수 있게 한다.*

    ```c
    // 나쁜 예
    bool success = CalculateSomething(interesting_value,
                                     10,
                                     false,
                                     NULL);	// 이 인자들의 의미는?
    
    // 좋은 예 주석추가
    bool success = CalculateSomething(intersting_value,
                                     10,	// 디폴트 기본 값
                                     false,	// 호출이 최고가 아님
                                     null);
    
    // 가장 좋은 예#2 - 상수사용
    const int kDefaultBaseValue = 10;
    const bool kFirstTimeCalling = false;
    bool success = CalculateSomething(interesting_value,
                                     kDefaultBaseValue,
                                     kFirstTimeCalling,
                                     null_callback);
    ```

  - *절대로 코드 그 자체를 설명하지 않는다.*

- **맞춤법**

  - *주석 작성시 맞춤법을 잘 지켜야 한다.*

- **TODO 주석**

  - *아주 임시 목적으로 `TODO` 주석을 사용할 수 있찌만, 반드시 최대한 빨리 제거한다.*

    함께 사용되는 `3RD PARTY` 의존코드의 `TODO `주서과 구분하기 위해 `TODO::`로 작성한다.

# **함수**

---

- **짧은 함수**

   - *짧고 집중된 함수를 작성한다.*

     함수가 40줄을 넘어가면 포그램의 구조를 해치지 않는 범위에서 함수를 나눌 수 있도록 노력한다.

     긴함수가 지금은 잘 동작하더라도, 누군가 나중에 새로운 동작을 넣을 수 있으며, 이로 인채 찾기 힘든 버그가 발생할 수 있다. 함수를 짧고 간단하게 유지하는 것은 다른 사람이 코드를 읽고 고치지 쉽게 만든다.

​	