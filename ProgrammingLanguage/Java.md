# **Java**

>   참고 : https://github.com/gyoogle/tech-interview-for-developer
>
>   전반적인 흐름은 gyoogle님의 깃허브를 참고하였으며, 추가 레퍼런스는 글을 진행하며 알려드릴 것입니다. 파이팅 !

# 자바 컴파일과정

---

>   자바는 OS에 독립적인 특징을 가지고 있다.
>
>   그게 가능한 이유는 JVM(Java Virtual Machine) 덕분인데, 그렇다면 JVM의 어떠한 기능 때문에, OS에 독립적으로 실행시킬 수 있는지 자바 컴파일 과정으로 알아보자.

![image-20210525210710504](https://user-images.githubusercontent.com/58545240/119519685-96ff2a80-bdb4-11eb-8db1-54db97c59bad.png)

![image-20210525210932332](https://user-images.githubusercontent.com/58545240/119519690-99618480-bdb4-11eb-84f0-8caa324f35ac.png)

## 자바 컴파일 순서

1.  개발자가 자바 소스 코드(`.java`)를 작성합니다.
2.  자바 컴파일러(Java Compiler)가 자바 소스파일을 컴파일한다.
    1.  이 때 나오는 파일은 자바 바이트 코드(`.class`) 파일로 아직 컴퓨터가 읽을 수 없는 자바 가상 머신이 이해할 수 있는 코드입니다.
    2.  바이트 코드의 각 명령어는 1바이트 크기의 `Opcode`와 추가 피연산자로 이루어져 있습니다.
3.  컴파일된 바이트 코드를 `JVM`의 **클래스 로더(Class Loader)**에게 전달합니다.
4.  클래스 로더는 동적로딩(Dynamic Loading)으로 필요한 클래스들을 로딩 및 링크하여 런타임 데이터 영역(Runtime Data Area), 즉 `JVM`의 메모리에 올립니다.
    -   클래스 로더 세부 동작
        -   `로드` : 클래스 파일을 가져와서 JVM의 메모리에 로드합니다.
        -   `검증` : 자바 언어 명세(Java Language Specification) 및 `JVM` 명세에 명시된 대로 구성되어 있는지 검증합니다.
        -   준비 : 클래스가 필요로 하는 메모리를 할당합니다. (필드, 메서드, 인터페이스 등등)
        -   분석 : 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경합니다.
        -   초기화 : 클래스 변수들을 적절한 값으로 초기화 합니다.(**static field**)
5.  실행엔진(Execution Engine)은 `JVM` 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행합니다. 이 때, 실행 엔진은 두 가지 방식으로 변경합니다.
    -   **인터프리터**
        -   바이트 코드 명령어를 하나씩 읽어서 해석하고 실행합니다.
        -   하나하나의 실행은 빠르나, 전체적인 실행 속도가 느리다는 단점을 가집니다.
    -   **JIT 컴파일러(Just-In-Time Compiler)**
        -   인터프리터의 단점을 보완하기 위해 도입된 방식으로 바이트 코드 전체를 컴파일하여 바이너리 코드로 변경하고 이후에는 해당 메서드를 더이상 인터프리팅 하지 않고, 바이너리 코드로 직접 실행하는 방식.
        -   하나씩 인터프리팅하여 실행하는 것이 아니라 바이트 코드 전체가 컴파일 된 바이너리 코드를 실행하는 것이기 때문에 전체적인 실행속도는 인터프리팅 방식보다 빠릅니다.

>   추가적으로 읽어보면 좋은 자료
>
>   [1] https://steady-snail.tistory.com/67
>
>   [2] https://aljjabaegi.tistory.com/387

# Call by value vs Call by reference

---

## call by value

>   값에 의한 호출

함수가 호출될 때, 메모리 공간 안에서는 함수를 위한 별도의 임시공간이 생성됩니다.(종료 해당 공간 사라짐)

`call by value` 호출 방식은 함수 호출 시 전달되는 변수 값을 복사해서 함수 인자로 전달합니다.

이 때 복사된 인자는 함수 안에서 지역적으로 사용되기 때문에 **local value** 속성을 가집니다.

따라서, 함수 안에서 인자 값이 변경되더라도, 외부 변수 값은 변경되지 않습니다.



**예시**

```c
void func(int n) {
    n = 20;
}
void main() {
    int n = 10;
    func(n);
    printf("%d", n);
}
```

```bash
10
```



## call by reference

>   참조에 의한 호출

call by reference 호출 방식은 함수 호출 시 인자로 전달되는 변수의 레퍼런스를 전달합니다.

따라서, 함수 안에서 인자 값이 변경되면 Argument로 전달된 객체의 값도 변경됩니다.

```c
void func(int *n) {
    *n = 20;
}
void main() {
    int n = 10;
    func(&n);
    printf("%d", n);
}
```

```bash
20
```

## Java의 함수 호출 방식

자바는 **항상 `call by value`**로 값을 넘깁니다.

`c/c++`와 같이 변수의 주소값 자체를 가져올 방법이 없으며, 이를 넘길 수 있는 방법 또한 없습니다.

`reference type(참조 자료형)`을 넘길 시에는 해당 객체의 주소값을 복사하여 이를 가지고 사용합니다.

따라서, **원본 객체의 Property**까지는 접근이 가능하나, 원본 객체 자체를 변경할 수는 없습니다.

```java
User a = new User("sunghyun"); // 1

foo(a);

public void foo(user b) {		// 2
    b = new User("kimchi");		// 3
}
```

-   **`1`** : a에 User 객체 생성 및 할당 (새로 생성된 객체의 주소값을 가지고 있다.)

    `a ---------------> User Object [name = "sunghyun"]`

-   **`2 `**: b라는 파라미터에 a가 가진 주소값을 복사하여 가짐

    `b ---------------> User Object [name = "sunghyuun"]`

-   **`3`** : 새로운 객체를 생성하고 새로 생성된 주소값을 b가 가지며 a는 그대로 원본 객체를 가리킨다.

    `a ---------------> User Object [name = "sunghyuun"]`

    `b ---------------> User Object [name = "kimchi"]`

파라미터에 객체/값의 주소값을 복사하여 넘겨주는 방식을 사용하고 있는 Java는 주소값을 넘겨 주소값에 저장되어 있는 값을 사용하는 **call by reference**라고 오해할 수 있는데요.

`c/c++`에서는 생성한 변수마다 새로운 메모리 공간을 할당하고 이에 값을 덮어 씌우는 형식으로 할당합니다. (`*` 포인터를 사용한다면, 같은 주소값을 가리킬 수 있도록 할 수 있다.)

`Java`에서 또한 생성한 변수마다 새로운 메모리 공간을 갖는 것은 마찬가지지만, 그 메모리 공간에 값 자체를 저장하는 것이 아니라 값을 다른 메모리 공간에 할당하고 이 주소값을 저장하는 것입니다.

이를 다음과 같이 나타낼 수 있습니다.

```shell
  C/C++        |        Java
               |
a -> [ 10 ]    |   a -> [ XXXX ]     [ 10 ] -> XXXX(위치)
b -> [ 10 ]    |   b -> [ XXXX ]
               |
             값 변경
a -> [ 11 ]    |   a -> [ YYYY ]     [ 10 ] -> XXXX(위치)
b -> [ 10 ]    |   b -> [ XXXX ]     [ 11 ] -> YYYY(위치)
```

`b = a;`일 때 a값을 b의 값으로 덮어 씌우는 것은 같지만, 실제 값을 저장하는 것과 값의 주소값을 저장하는 것의 차이가 존재합니다.

즉, Java에서의 변수는 `[할당된 값의 위치]`를 `[값]`으로 가지고 있는 것입니다.

`c/c++`에서는 주소값 자체를 인자로 넘겼을 때 값을 변경하면 새로운 값으로 덮어 쓰여 기존 값이 변경되고
`Java`에서는 주소값이 덮어 쓰여지므로 원본 값은 전혀 영향이 가지 않는 것입니다.(객체의 속성값에 접근하여 변경하는 것은 직접 접근하여 변경하는 것이므로 이를 가리키는 변수들에서 변경이 일어난다.)

```bash
객체 접근하여 속성값 변경

a : [ XXXX ]  [ Object [prop : ~ ] ] -> XXXX(위치)
b : [ XXXX ]

prop : ~ (이 또한 변수이므로 어딘가에 ~가 저장되어있고 prop는 이의 주소값을 가지고 있는 셈)
prop : [ YYYY ]    [ ~ ] -> YYYY(위치)

a.prop = * (a를 통해 prop를 변경) 

prop : [ ZZZZ ]    [ ~ ] -> YYYY(위치)
                   [ * ] -> ZZZZ

b -> Object에 접근 -> prop 접근 -> ZZZZ
```

위와 같은 이유로 Java에서 인자로 넘길  때는 주소값이란 값을 복사하여 넘기는 것이므로 **`call by value`**라 할 수 있다.

*( 출처 : [Is Java “pass-by-reference” or “pass-by-value”? - Stack Overflow](https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value?answertab=votes#tab-top) )*



## 정리

`Call by value`의 경우 데이터 값을 복사해서 함수로 전달하기 대문에 원본의 데이터가 변경될 가능성이 없다. 하지만 인자를 넘겨줄 때마다 메모리 공간을 할당해야 해서 메모리 공간을 더 잡아 먹습니다.

`Call by reference`의 경우 메모리 공간 할당 문제는 해결했지만, 원본 값이 변경될 수 있다는 위험이 존재합니다.

# String, StringBuffer, StringBuilder

---

| 분류   | String    | StringBuffer                    | StringBuilder        |
| ------ | --------- | ------------------------------- | -------------------- |
| 변경   | Immutable | Mutable                         | Mutable              |
| 동기화 |           | Synchronized 가능 (Thread-safe) | Synchronized 불가능. |

## String 특징

-   new 연산을 통해 생성된 인스턴스의 메모리 공간은 변하지 않습니다.(**`Immutable`**)
-   `Garbage Collector`로 제거되어야 합니다.
-   문자열 연산시 새로 객체를 만드는 Overhead가 발생합니다.
-   객체가 불변하므로, 멀티쓰레드에서 동기화를 신경 쓸 필요가 없습니다.(조회 연산에 매우 큰 장점!)

***String 클래스 : 문자열 연산이 적고, 조회가 많은 멀티쓰레드 환경에서 좋다***

## StringBuffer, StringBuilder 특징

-   공통점
    -   new 연산으로 클래스를 한 번만 만듭니다.(**`Mutable`**)
    -   문자열 연산 시 새로 객체를 만들지 않고, 크기를 변경시킵니다.
    -   StringBuffer와 StringBuilder 모두 동일한 메서드를 가지고 있습니다.
-   차이점
    -   StringBuffer는 `Thread-Safe`하고, StringBuilder는 `Thread-Safe`하지 않습니다.

***StringBuffer 클래스 : 문자열 연산이 많은 멀티쓰레드 환경***

***StringBuilder 클래스 : 문자열 연산이 많은 싱글쓰레드 혹은 Thread를 신경 안쓰는 환경***

# JVM

---

>   Java Virtual Machine
>
>   시스템 메모리를 관리하면서, 자바 기반 애플리케이션을 위해 이식 가능한 실행 환경을 제공

![image-20210525224802572](https://user-images.githubusercontent.com/58545240/119519699-9b2b4800-bdb4-11eb-8f7c-2192f135a984.png)

JVM은, 다른 프로그램을 실행시키는 것이 목적입니다.

크게 2가지 기능이 있습니다.

1.  자바 프로그램이 어느 기기나 운영체제 상에서도 실행될 수 있도록 하는 것
2.  프로그램 메모리를 관리하고 최적화 하는 것

```bash
JVM은 코드를 실행하고, 해당 코드에 대해 런타임 환경을 제공하는 프로그램에 대한 사양이다.
```



개발자들이 말하는 `JVM`은 보통 **어떤 기기상에서 실행되고 있는 프로세스, 특히 자바 앱에 대한 리소스를 대표하고 통제하는 서버**를 지칭합니다.

자바 애플리케이션을 클래스 로더를 통해 읽어들이고, 자바 API와 함께 실행하는 역할이며

`JAVA`와 `OS` 사이에서 중개자 역할을 수행하여 `OS`에 구애받지 않고 재사용을 가능하게 해줍니다.

## 메모리 관리

>   JVM 실행에 있어서 가장 일반적인 상호작용은, **힙과 스택의 메모리 사용을 확인**하는 것

**실행 과정**

1.  프로그램이 실행되면 `JVM`은 `OS`로부터 이 프로그램이 필요로하는 메모리를 할당받습니다.
    -   `JVM`은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리합니다.
2.  자바 컴파일러(`JAVAC`)가 자바 소스코드를 읽고, 자바 바이트코드(`.class`)로 변환시킵니다.
3.  변경된 `.class `파일들을 클래스 로더를 통해 `JVM` 메모리 영역으로 로딩합니다.
4.  로딩된 `.class` 파일들은 `Execution Engine`을 통해 해석됩니다.
5.  해석된 바이트 코드는 메모리 영역에 배치되어 실질적인 수행이 이루어집니다.
    -   이러한 수행 과정 속 `JVM`은 필요에 따라 스레드 동기화나 가비지 컬렉션 같은 메모리 관리 작업을 수행합니다.

![image-20210525225248440](https://user-images.githubusercontent.com/58545240/119519703-9c5c7500-bdb4-11eb-8b8f-8d9735c62a35.png)



-   **`자바 컴파일러`**
    -   자바 소스코드(`.java`)를 바이트 코드(`.class`)로 변환시킨다.
-   **`클래스 로더`**
    -   JVM은 런타임시에 처음으로 클래스를 참조할 때 해당 클래스를 로드하고 메모리 영역에 배치시킵니다.
    -   이 동적 로딩(Dynamic Loading)을 담당하는 부분이 바로 클래스 로더
-   **`Runtime Data Area`**
    -   JVM이 운영체제 위에서 실행되면서 할당받는 메모리 영역
    -   총 5가지 영역으로 나뉘어 집니다
        -   `PC 레지스터`
            -   스레드가 어떤 명령어로 실행되어야 할지 기록하는 부분(JVM 명령의 주소를 가진다)
        -   JVM 스택
            -   지역변수, 매개변수, 메서드 정보, 임시 데이터 등을 저장
        -   네이티브 메서드 스택
            -   실제 실행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역
        -   힙
            -   런타임에 동적으로 할당되는 데이터가 저장되는 영역
            -   객체나 배열 생성이 여기에 해당
        -   메서드 영역
            -   JVM이 시작될 때 생성되고, JVM이 읽은 각각의 클래스와 인터페이스에 대한 런타임 상수 풀, 필드 및 메서드 코드, 정적 변수, 메서드의 바이트 코드 등을 보관
-   **`Garbage Collection`**
    -   자바 이전에는 프로그래머가 모든 프로그램 메모리를 관리했지만 자바에서는 `JVM`이 프로그램 메모리를 관리한다.
    -   JVM은 가비지 컬렉션이라는 프로세스를 통해 메모리를 관리한다.
    -   이 가비지 컬렉션은 자바 프로그램에서 사용되지 않는 메모리를 지속적으로 찾아내서 제거하는 역할을 한다.
        1.  참조되지 않은 객체들을 탐색 후 삭제
        2.  삭제된 객체의 메모리 반환
        3.  힙 메모리 재사용

